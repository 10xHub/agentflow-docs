{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentFlow Docs","text":"<p>Welcome! This site is built with MkDocs and Material, managed via uv.</p> <ul> <li>Beautiful UI using Material for MkDocs</li> <li>Mermaid diagrams for agent/system graphs</li> <li>Ready for API docs with mkdocstrings (Python)</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>Edit Markdown under <code>docs/</code></li> <li>Navigation is defined in <code>mkdocs.yml</code></li> <li>Start a local server with: <code>uv run mkdocs serve</code></li> </ul>"},{"location":"#example-mermaid-diagram","title":"Example: Mermaid diagram","text":"<pre><code>graph TD\n    User[User] --&gt;|prompts| Planner[Planner Agent]\n    Planner --&gt;|tasks| Tools[(Tools)]\n    Tools --&gt;|results| Memory[(Memory)]\n    Memory --&gt;|context| Planner\n    Planner --&gt;|answers| User\n</code></pre>"},{"location":"cli/","title":"AgentFlow CLI - Complete Guide","text":"<p>The <code>agentflow</code> CLI is a professional command-line interface for scaffolding, running, and deploying agent-based APIs built with the AgentFlow framework.</p>"},{"location":"cli/#installation","title":"Installation","text":"<pre><code>pip install 10xscale-agentflow-cli\n</code></pre> <p>For development with all optional dependencies:</p> <pre><code>pip install \"10xscale-agentflow-cli[redis,sentry,firebase,snowflakekit,gcloud]\"\n</code></pre>"},{"location":"cli/#quick-start","title":"Quick Start","text":"<pre><code># Initialize a new project\nagentflow init\n\n# Start development server\nagentflow api\n\n# Generate Dockerfile\nagentflow build\n</code></pre>"},{"location":"cli/#commands-overview","title":"Commands Overview","text":"Command Description <code>agentflow init</code> Initialize a new project with config and graph scaffold <code>agentflow api</code> Start the development API server <code>agentflow build</code> Generate Docker deployment files <code>agentflow version</code> Display CLI and package versions"},{"location":"cli/#agentflow-init","title":"<code>agentflow init</code>","text":"<p>Initialize a new AgentFlow project with configuration and sample graph code.</p>"},{"location":"cli/#synopsis","title":"Synopsis","text":"<pre><code>agentflow init [OPTIONS]\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"Option Type Default Description <code>--path</code>, <code>-p</code> STRING <code>.</code> Directory to initialize files in <code>--force</code>, <code>-f</code> FLAG <code>False</code> Overwrite existing files <code>--prod</code> FLAG <code>False</code> Include production configuration files <code>--verbose</code>, <code>-v</code> FLAG <code>False</code> Enable verbose logging <code>--quiet</code>, <code>-q</code> FLAG <code>False</code> Suppress all output except errors"},{"location":"cli/#behavior","title":"Behavior","text":"<p>Default Mode: - Creates <code>agentflow.json</code> configuration file - Creates <code>graph/react.py</code> with a sample React-based agent - Creates <code>graph/__init__.py</code> to make it a Python package</p> <p>Production Mode (<code>--prod</code>): - All default files plus:   - <code>.pre-commit-config.yaml</code> - Pre-commit hooks configuration   - <code>pyproject.toml</code> - Python project metadata and tooling config</p>"},{"location":"cli/#examples","title":"Examples","text":"<p>Basic initialization: <pre><code>agentflow init\n</code></pre></p> <p>Initialize in a specific directory: <pre><code>agentflow init --path ./my-agent-project\n</code></pre></p> <p>Initialize with production config: <pre><code>agentflow init --prod\n</code></pre></p> <p>Overwrite existing files: <pre><code>agentflow init --force\n</code></pre></p> <p>Initialize production project in a new directory: <pre><code>agentflow init --prod --path ./production-agent --force\ncd production-agent\npre-commit install\n</code></pre></p>"},{"location":"cli/#generated-files","title":"Generated Files","text":""},{"location":"cli/#agentflowjson","title":"<code>agentflow.json</code>","text":"<pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"env\": \".env\",\n  \"auth\": null,\n  \"checkpointer\": null,\n  \"injectq\": null,\n  \"store\": null,\n  \"redis\": null,\n  \"thread_name_generator\": null\n}\n</code></pre>"},{"location":"cli/#graphreactpy","title":"<code>graph/react.py</code>","text":"<p>A fully-commented sample agent implementation featuring: - LiteLLM integration for AI completion - Tool definition and execution - State graph orchestration - Conditional routing - In-memory checkpointer</p>"},{"location":"cli/#agentflow-api","title":"<code>agentflow api</code>","text":"<p>Start the AgentFlow API development server with hot-reload support.</p>"},{"location":"cli/#synopsis_1","title":"Synopsis","text":"<pre><code>agentflow api [OPTIONS]\n</code></pre>"},{"location":"cli/#options_1","title":"Options","text":"Option Type Default Description <code>--config</code>, <code>-c</code> STRING <code>agentflow.json</code> Path to configuration file <code>--host</code>, <code>-H</code> STRING <code>0.0.0.0</code> Host to bind the server to <code>--port</code>, <code>-p</code> INTEGER <code>8000</code> Port to bind the server to <code>--reload</code> / <code>--no-reload</code> FLAG <code>True</code> Enable/disable auto-reload <code>--verbose</code>, <code>-v</code> FLAG <code>False</code> Enable verbose logging <code>--quiet</code>, <code>-q</code> FLAG <code>False</code> Suppress all output except errors"},{"location":"cli/#behavior_1","title":"Behavior","text":"<ol> <li>Loads the specified configuration file</li> <li>Loads environment variables from <code>.env</code> file (or file specified in config)</li> <li>Sets <code>GRAPH_PATH</code> environment variable</li> <li>Starts Uvicorn server with specified host and port</li> <li>Watches for file changes and auto-reloads (if <code>--reload</code> is enabled)</li> </ol>"},{"location":"cli/#examples_1","title":"Examples","text":"<p>Start with default settings: <pre><code>agentflow api\n</code></pre></p> <p>Start with custom config file: <pre><code>agentflow api --config production.json\n</code></pre></p> <p>Start on localhost only: <pre><code>agentflow api --host 127.0.0.1\n</code></pre></p> <p>Start on custom port: <pre><code>agentflow api --port 9000\n</code></pre></p> <p>Start without auto-reload (for testing): <pre><code>agentflow api --no-reload\n</code></pre></p> <p>Start with verbose logging: <pre><code>agentflow api --verbose\n</code></pre></p> <p>Combine multiple options: <pre><code>agentflow api --config staging.json --host 127.0.0.1 --port 8080 --verbose\n</code></pre></p>"},{"location":"cli/#server-access","title":"Server Access","text":"<p>Once started, the API is accessible at: - Default: <code>http://0.0.0.0:8000</code> - Local access: <code>http://localhost:8000</code> - Network access: <code>http://&lt;your-ip&gt;:8000</code></p>"},{"location":"cli/#api-endpoints","title":"API Endpoints","text":"<p>The server provides several endpoints: - <code>GET /ping</code> - Health check endpoint - <code>POST /threads</code> - Create a new thread - <code>GET /threads/{thread_id}</code> - Get thread details - <code>POST /threads/{thread_id}/messages</code> - Send a message - <code>GET /threads/{thread_id}/messages</code> - Get thread messages</p>"},{"location":"cli/#development-workflow","title":"Development Workflow","text":"<pre><code># 1. Initialize project\nagentflow init\n\n# 2. Create .env file with your API keys\necho \"GEMINI_API_KEY=your_key_here\" &gt; .env\n\n# 3. Start development server\nagentflow api --verbose\n\n# 4. Test the API\ncurl http://localhost:8000/ping\n\n# 5. Make changes to your graph - server auto-reloads\n</code></pre>"},{"location":"cli/#agentflow-build","title":"<code>agentflow build</code>","text":"<p>Generate production-ready Docker deployment files.</p>"},{"location":"cli/#synopsis_2","title":"Synopsis","text":"<pre><code>agentflow build [OPTIONS]\n</code></pre>"},{"location":"cli/#options_2","title":"Options","text":"Option Type Default Description <code>--output</code>, <code>-o</code> STRING <code>Dockerfile</code> Output Dockerfile path <code>--force</code>, <code>-f</code> FLAG <code>False</code> Overwrite existing files <code>--python-version</code> STRING <code>3.13</code> Python version for base image <code>--port</code>, <code>-p</code> INTEGER <code>8000</code> Port to expose in container <code>--docker-compose</code> FLAG <code>False</code> Also generate docker-compose.yml <code>--service-name</code> STRING <code>agentflow-cli</code> Service name in docker-compose <code>--verbose</code>, <code>-v</code> FLAG <code>False</code> Enable verbose logging <code>--quiet</code>, <code>-q</code> FLAG <code>False</code> Suppress all output except errors"},{"location":"cli/#behavior_2","title":"Behavior","text":"<ol> <li>Searches for <code>requirements.txt</code> in common locations:</li> <li><code>./requirements.txt</code></li> <li><code>./requirements/requirements.txt</code></li> <li><code>./requirements/base.txt</code></li> <li><code>./requirements/production.txt</code></li> <li>Generates optimized Dockerfile with:</li> <li>Multi-stage build support</li> <li>Non-root user for security</li> <li>Health check configuration</li> <li>Gunicorn + Uvicorn workers</li> <li>Optionally generates <code>docker-compose.yml</code></li> </ol>"},{"location":"cli/#examples_2","title":"Examples","text":"<p>Generate basic Dockerfile: <pre><code>agentflow build\n</code></pre></p> <p>Generate with custom Python version: <pre><code>agentflow build --python-version 3.12\n</code></pre></p> <p>Generate with custom port: <pre><code>agentflow build --port 9000\n</code></pre></p> <p>Generate Dockerfile and docker-compose.yml: <pre><code>agentflow build --docker-compose\n</code></pre></p> <p>Complete production setup: <pre><code>agentflow build --docker-compose --python-version 3.13 --port 8000 --force\n</code></pre></p> <p>Custom service name in docker-compose: <pre><code>agentflow build --docker-compose --service-name my-agent-api\n</code></pre></p>"},{"location":"cli/#generated-dockerfile-features","title":"Generated Dockerfile Features","text":"<ul> <li>Base Image: Python slim image for reduced size</li> <li>Security: Non-root user execution</li> <li>Optimization: Multi-layer caching for faster builds</li> <li>Health Check: Built-in <code>/ping</code> endpoint monitoring</li> <li>Production Server: Gunicorn with Uvicorn workers</li> </ul>"},{"location":"cli/#docker-build-and-run","title":"Docker Build and Run","text":"<p>After generating the Dockerfile:</p> <pre><code># Build the image\ndocker build -t my-agent-api .\n\n# Run the container\ndocker run -p 8000:8000 --env-file .env my-agent-api\n\n# Or use docker-compose\ndocker compose up --build\n</code></pre>"},{"location":"cli/#agentflow-version","title":"<code>agentflow version</code>","text":"<p>Display version information for the CLI and installed packages.</p>"},{"location":"cli/#synopsis_3","title":"Synopsis","text":"<pre><code>agentflow version [OPTIONS]\n</code></pre>"},{"location":"cli/#options_3","title":"Options","text":"Option Type Default Description <code>--verbose</code>, <code>-v</code> FLAG <code>False</code> Show additional version details <code>--quiet</code>, <code>-q</code> FLAG <code>False</code> Show only version number"},{"location":"cli/#examples_3","title":"Examples","text":"<pre><code># Show version\nagentflow version\n\n# Verbose output with dependencies\nagentflow version --verbose\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> Option Description <code>--help</code>, <code>-h</code> Show help message and exit <code>--verbose</code>, <code>-v</code> Enable verbose logging output <code>--quiet</code>, <code>-q</code> Suppress all output except errors"},{"location":"cli/#examples_4","title":"Examples","text":"<pre><code># Get help for any command\nagentflow init --help\nagentflow api --help\nagentflow build --help\n\n# Run with verbose output\nagentflow api --verbose\nagentflow build --verbose\n</code></pre>"},{"location":"cli/#configuration-file-resolution","title":"Configuration File Resolution","text":"<p>The CLI searches for configuration files in this order:</p> <ol> <li>Explicit path: If you provide <code>--config /path/to/config.json</code>, it uses that</li> <li>Current directory: Looks for <code>agentflow.json</code> in current working directory</li> <li>Relative to script: Searches relative to the CLI installation</li> <li>Package directory: Falls back to package installation location</li> </ol>"},{"location":"cli/#environment-variables","title":"Environment Variables","text":"<p>The CLI respects these environment variables:</p> Variable Purpose Used By <code>GRAPH_PATH</code> Path to active config file API server <code>GEMINI_API_KEY</code> API key for Gemini models LiteLLM <code>OPENAI_API_KEY</code> API key for OpenAI models LiteLLM <code>JWT_SECRET_KEY</code> Secret key for JWT auth Auth system <code>JWT_ALGORITHM</code> Algorithm for JWT (e.g., HS256) Auth system <code>SNOWFLAKE_*</code> Snowflake ID generator config ID generation"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> General error <code>2</code> Configuration error <code>3</code> Validation error <code>130</code> Interrupted by user (Ctrl+C)"},{"location":"cli/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/#starting-a-new-project","title":"Starting a New Project","text":"<pre><code># 1. Initialize with production config\nagentflow init --prod\n\n# 2. Install pre-commit hooks\npre-commit install\n\n# 3. Create environment file\ncat &gt; .env &lt;&lt; EOF\nGEMINI_API_KEY=your_api_key_here\nLOG_LEVEL=INFO\nEOF\n\n# 4. Install dependencies\npip install -e \".[redis,sentry]\"\n\n# 5. Start development server\nagentflow api --verbose\n</code></pre>"},{"location":"cli/#development-workflow_1","title":"Development Workflow","text":"<pre><code># Start server with auto-reload\nagentflow api --reload --verbose\n\n# In another terminal, test the API\ncurl http://localhost:8000/ping\n\n# Make changes to graph/react.py\n# Server automatically reloads\n</code></pre>"},{"location":"cli/#production-deployment","title":"Production Deployment","text":"<pre><code># 1. Generate Docker files\nagentflow build --docker-compose --force\n\n# 2. Review generated files\ncat Dockerfile\ncat docker-compose.yml\n\n# 3. Build and test locally\ndocker compose up --build\n\n# 4. Push to registry\ndocker tag agentflow-cli:latest registry.example.com/agentflow:latest\ndocker push registry.example.com/agentflow:latest\n\n# 5. Deploy to production\nkubectl apply -f k8s/deployment.yaml\n</code></pre>"},{"location":"cli/#testing-different-configurations","title":"Testing Different Configurations","text":"<pre><code># Test with different config files\nagentflow api --config dev.json --port 8001 &amp;\nagentflow api --config staging.json --port 8002 &amp;\nagentflow api --config prod.json --port 8003 &amp;\n\n# Test each endpoint\ncurl http://localhost:8001/ping\ncurl http://localhost:8002/ping\ncurl http://localhost:8003/ping\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/#server-wont-start","title":"Server won't start","text":"<p>Problem: <code>Error loading graph from graph.react:app</code></p> <p>Solution: <pre><code># Ensure your graph directory is a Python package\ntouch graph/__init__.py\n\n# Verify your PYTHONPATH\nexport PYTHONPATH=\"${PYTHONPATH}:$(pwd)\"\n\n# Check your config file\ncat agentflow.json\n</code></pre></p>"},{"location":"cli/#port-already-in-use","title":"Port already in use","text":"<p>Problem: <code>OSError: [Errno 48] Address already in use</code></p> <p>Solution: <pre><code># Find process using the port\nlsof -i :8000\n\n# Kill the process\nkill -9 &lt;PID&gt;\n\n# Or use a different port\nagentflow api --port 8001\n</code></pre></p>"},{"location":"cli/#config-file-not-found","title":"Config file not found","text":"<p>Problem: <code>ConfigurationError: Config file not found</code></p> <p>Solution: <pre><code># Check current directory\nls -la agentflow.json\n\n# Use explicit path\nagentflow api --config /full/path/to/agentflow.json\n\n# Or initialize a new config\nagentflow init\n</code></pre></p>"},{"location":"cli/#requirements-not-found-during-build","title":"Requirements not found during build","text":"<p>Problem: <code>No requirements.txt found</code></p> <p>Solution: <pre><code># Create requirements.txt\npip freeze &gt; requirements.txt\n\n# Or let build use default installation\nagentflow build  # Will install agentflow-cli from PyPI\n</code></pre></p>"},{"location":"cli/#best-practices","title":"Best Practices","text":""},{"location":"cli/#development","title":"Development","text":"<ol> <li> <p>Use verbose logging during development:    <pre><code>agentflow api --verbose\n</code></pre></p> </li> <li> <p>Keep auto-reload enabled for faster iteration:    <pre><code>agentflow api --reload\n</code></pre></p> </li> <li> <p>Use localhost for local-only access:    <pre><code>agentflow api --host 127.0.0.1\n</code></pre></p> </li> </ol>"},{"location":"cli/#production","title":"Production","text":"<ol> <li> <p>Disable auto-reload in production:    <pre><code>agentflow api --no-reload\n</code></pre></p> </li> <li> <p>Use environment-specific configs:    <pre><code>agentflow api --config production.json\n</code></pre></p> </li> <li> <p>Run behind a reverse proxy (nginx, Traefik):    <pre><code># Bind to localhost only\nagentflow api --host 127.0.0.1 --port 8000\n</code></pre></p> </li> <li> <p>Use Docker for consistent deployments:    <pre><code>agentflow build --docker-compose --force\ndocker compose up -d\n</code></pre></p> </li> </ol>"},{"location":"cli/#security","title":"Security","text":"<ol> <li>Never commit <code>.env</code> files - add to <code>.gitignore</code></li> <li>Use different secrets per environment</li> <li>Run containers as non-root user (Dockerfile does this automatically)</li> <li>Keep dependencies updated:    <pre><code>pip install --upgrade 10xscale-agentflow-cli\n</code></pre></li> </ol>"},{"location":"cli/#additional-resources","title":"Additional Resources","text":"<ul> <li>Configuration Guide - Complete configuration reference</li> <li>Deployment Guide - Production deployment strategies</li> <li>Authentication Guide - Setting up auth</li> </ul>"},{"location":"cli/#getting-help","title":"Getting Help","text":"<pre><code># Command-specific help\nagentflow init --help\nagentflow api --help\nagentflow build --help\n\n# Check version\nagentflow version\n</code></pre>"},{"location":"cli/authentication/","title":"Authentication Guide","text":"<p>This guide covers implementing authentication in your AgentFlow application using JWT or custom authentication backends.</p>"},{"location":"cli/authentication/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>No Authentication</li> <li>JWT Authentication</li> <li>Custom Authentication</li> <li>BaseAuth Interface</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"cli/authentication/#overview","title":"Overview","text":"<p>AgentFlow supports three authentication modes:</p> <ol> <li>No Authentication - For development or internal APIs</li> <li>JWT Authentication - Built-in JWT token validation</li> <li>Custom Authentication - Implement your own auth logic</li> </ol> <p>Authentication is configured in <code>agentflow.json</code>:</p> <pre><code>{\n  \"auth\": null | \"jwt\" | {\n    \"method\": \"custom\",\n    \"path\": \"module:class\"\n  }\n}\n</code></pre>"},{"location":"cli/authentication/#no-authentication","title":"No Authentication","text":""},{"location":"cli/authentication/#configuration","title":"Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"auth\": null\n}\n</code></pre></p>"},{"location":"cli/authentication/#usage","title":"Usage","text":"<p>All API endpoints will be accessible without authentication.</p> <pre><code># No auth header required\ncurl http://localhost:8000/ping\ncurl -X POST http://localhost:8000/threads\n</code></pre>"},{"location":"cli/authentication/#when-to-use","title":"When to Use","text":"<ul> <li>\u2705 Development and testing</li> <li>\u2705 Internal APIs behind a firewall</li> <li>\u2705 APIs with alternative security (API Gateway, VPN)</li> <li>\u274c Public-facing production APIs</li> <li>\u274c APIs handling sensitive data</li> </ul>"},{"location":"cli/authentication/#jwt-authentication","title":"JWT Authentication","text":""},{"location":"cli/authentication/#configuration_1","title":"Configuration","text":"<p>Step 1: Configure agentflow.json</p> <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"auth\": \"jwt\"\n}\n</code></pre> <p>Step 2: Set Environment Variables</p> <p>.env: <pre><code>JWT_SECRET_KEY=your-super-secret-key-change-this-in-production\nJWT_ALGORITHM=HS256\n</code></pre></p>"},{"location":"cli/authentication/#supported-algorithms","title":"Supported Algorithms","text":"Algorithm Type Description HS256 HMAC SHA-256 (recommended for single server) HS384 HMAC SHA-384 HS512 HMAC SHA-512 RS256 RSA SHA-256 (for distributed systems) RS384 RSA SHA-384 RS512 RSA SHA-512 ES256 ECDSA SHA-256 ES384 ECDSA SHA-384 ES512 ECDSA SHA-512"},{"location":"cli/authentication/#generating-secrets","title":"Generating Secrets","text":"<p>For HS256 (symmetric): <pre><code># Python\npython -c \"import secrets; print(secrets.token_urlsafe(32))\"\n\n# OpenSSL\nopenssl rand -base64 32\n</code></pre></p> <p>For RS256 (asymmetric): <pre><code># Generate private key\nopenssl genrsa -out private.pem 2048\n\n# Generate public key\nopenssl rsa -in private.pem -outform PEM -pubout -out public.pem\n\n# Use private key content as JWT_SECRET_KEY\ncat private.pem\n</code></pre></p>"},{"location":"cli/authentication/#creating-jwt-tokens","title":"Creating JWT Tokens","text":"<p>Python example: <pre><code>import jwt\nfrom datetime import datetime, timedelta\n\ndef create_token(user_id: str, username: str) -&gt; str:\n    payload = {\n        \"user_id\": user_id,\n        \"username\": username,\n        \"exp\": datetime.utcnow() + timedelta(hours=24),\n        \"iat\": datetime.utcnow()\n    }\n\n    token = jwt.encode(\n        payload,\n        \"your-secret-key\",\n        algorithm=\"HS256\"\n    )\n\n    return token\n\n# Usage\ntoken = create_token(\"user123\", \"john_doe\")\nprint(f\"Token: {token}\")\n</code></pre></p> <p>Node.js example: <pre><code>const jwt = require('jsonwebtoken');\n\nfunction createToken(userId, username) {\n    const payload = {\n        user_id: userId,\n        username: username,\n        exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours\n        iat: Math.floor(Date.now() / 1000)\n    };\n\n    return jwt.sign(payload, 'your-secret-key', { algorithm: 'HS256' });\n}\n\nconst token = createToken('user123', 'john_doe');\nconsole.log(`Token: ${token}`);\n</code></pre></p>"},{"location":"cli/authentication/#using-jwt-tokens","title":"Using JWT Tokens","text":"<p>With curl: <pre><code># Create a thread\ncurl -X POST http://localhost:8000/threads \\\n  -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\" \\\n  -H \"Content-Type: application/json\"\n\n# Send a message\ncurl -X POST http://localhost:8000/threads/abc123/messages \\\n  -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Hello\"}'\n</code></pre></p> <p>With Python requests: <pre><code>import requests\n\ntoken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\nheaders = {\n    \"Authorization\": f\"Bearer {token}\",\n    \"Content-Type\": \"application/json\"\n}\n\n# Create thread\nresponse = requests.post(\n    \"http://localhost:8000/threads\",\n    headers=headers\n)\n\nthread_id = response.json()[\"thread_id\"]\n\n# Send message\nresponse = requests.post(\n    f\"http://localhost:8000/threads/{thread_id}/messages\",\n    headers=headers,\n    json={\"content\": \"Hello, AI!\"}\n)\n\nprint(response.json())\n</code></pre></p> <p>With JavaScript fetch: <pre><code>const token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\";\nconst headers = {\n    \"Authorization\": `Bearer ${token}`,\n    \"Content-Type\": \"application/json\"\n};\n\n// Create thread\nfetch(\"http://localhost:8000/threads\", {\n    method: \"POST\",\n    headers: headers\n})\n.then(res =&gt; res.json())\n.then(data =&gt; {\n    const threadId = data.thread_id;\n\n    // Send message\n    return fetch(`http://localhost:8000/threads/${threadId}/messages`, {\n        method: \"POST\",\n        headers: headers,\n        body: JSON.stringify({ content: \"Hello, AI!\" })\n    });\n})\n.then(res =&gt; res.json())\n.then(data =&gt; console.log(data));\n</code></pre></p>"},{"location":"cli/authentication/#jwt-token-structure","title":"JWT Token Structure","text":"<p>A JWT consists of three parts: Header, Payload, and Signature.</p> <p>Header: <pre><code>{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre></p> <p>Payload (claims): <pre><code>{\n  \"user_id\": \"user123\",\n  \"username\": \"john_doe\",\n  \"email\": \"john@example.com\",\n  \"roles\": [\"user\", \"admin\"],\n  \"exp\": 1735689600,  // Expiration time\n  \"iat\": 1735603200   // Issued at\n}\n</code></pre></p> <p>Signature: <pre><code>HMACSHA256(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  secret\n)\n</code></pre></p>"},{"location":"cli/authentication/#token-validation","title":"Token Validation","text":"<p>The JWT middleware automatically validates: - \u2705 Token signature - \u2705 Token expiration (<code>exp</code> claim) - \u2705 Token format</p>"},{"location":"cli/authentication/#error-responses","title":"Error Responses","text":"<p>Missing token: <pre><code>{\n  \"detail\": \"Not authenticated\"\n}\n</code></pre> Status: 401 Unauthorized</p> <p>Invalid token: <pre><code>{\n  \"detail\": \"Could not validate credentials\"\n}\n</code></pre> Status: 401 Unauthorized</p> <p>Expired token: <pre><code>{\n  \"detail\": \"Token has expired\"\n}\n</code></pre> Status: 401 Unauthorized</p>"},{"location":"cli/authentication/#custom-authentication","title":"Custom Authentication","text":""},{"location":"cli/authentication/#overview_1","title":"Overview","text":"<p>Implement custom authentication for: - OAuth 2.0 / OpenID Connect - API keys - Firebase Authentication - Auth0 - Custom database authentication - Multi-factor authentication</p>"},{"location":"cli/authentication/#configuration_2","title":"Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"auth\": {\n    \"method\": \"custom\",\n    \"path\": \"auth.custom:MyAuthBackend\"\n  }\n}\n</code></pre></p>"},{"location":"cli/authentication/#implementation","title":"Implementation","text":"<p>auth/custom.py: <pre><code>from agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom typing import Any\n\nclass MyAuthBackend(BaseAuth):\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Authenticate user based on credentials.\n\n        Args:\n            res: FastAPI Response object (for setting cookies, headers)\n            credential: HTTPAuthorizationCredentials with token\n\n        Returns:\n            dict with user info including 'user_id', or raises HTTPException\n        \"\"\"\n        token = credential.credentials\n\n        # Your authentication logic here\n        user = self.verify_token(token)\n\n        if not user:\n            raise HTTPException(\n                status_code=401,\n                detail=\"Invalid authentication credentials\"\n            )\n\n        # Return user information\n        # This will be merged with the graph config\n        return {\n            \"user_id\": user[\"id\"],\n            \"username\": user[\"username\"],\n            \"email\": user[\"email\"],\n            \"roles\": user[\"roles\"]\n        }\n\n    def verify_token(self, token: str) -&gt; dict | None:\n        \"\"\"Implement your token verification logic.\"\"\"\n        # Example: Query database, call external API, etc.\n        pass\n</code></pre></p>"},{"location":"cli/authentication/#baseauth-interface","title":"BaseAuth Interface","text":""},{"location":"cli/authentication/#abstract-method","title":"Abstract Method","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Any\nfrom fastapi import Response\nfrom fastapi.security import HTTPAuthorizationCredentials\n\nclass BaseAuth(ABC):\n    @abstractmethod\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Authenticate the user based on credentials.\n\n        Returns:\n            - Empty dict {} if no authentication required\n            - Dict with user info if authentication successful\n            - Raises HTTPException if authentication fails\n\n        The returned dict should contain at least:\n            - user_id: Unique user identifier\n\n        Optional fields:\n            - username: User's username\n            - email: User's email\n            - roles: List of user roles\n            - Any other user-specific data\n\n        These fields will be merged with the graph config,\n        making them available throughout your agent graph.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"cli/authentication/#return-values","title":"Return Values","text":"<p>No authentication required: <pre><code>return {}\n</code></pre></p> <p>Authentication successful: <pre><code>return {\n    \"user_id\": \"user123\",\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\",\n    \"roles\": [\"user\", \"premium\"],\n    \"subscription\": \"pro\"\n}\n</code></pre></p> <p>Authentication failed: <pre><code>from fastapi import HTTPException\n\nraise HTTPException(\n    status_code=401,\n    detail=\"Invalid token\"\n)\n</code></pre></p>"},{"location":"cli/authentication/#best-practices","title":"Best Practices","text":""},{"location":"cli/authentication/#security","title":"Security","text":"<ol> <li> <p>Use strong secrets: <pre><code># Generate a secure secret\npython -c \"import secrets; print(secrets.token_urlsafe(32))\"\n</code></pre></p> </li> <li> <p>Never commit secrets: <pre><code># Add to .gitignore\necho \".env\" &gt;&gt; .gitignore\necho \".env.*\" &gt;&gt; .gitignore\necho \"!.env.example\" &gt;&gt; .gitignore\n</code></pre></p> </li> <li> <p>Use environment-specific secrets: <pre><code># Development\nJWT_SECRET_KEY=dev-secret-key\n\n# Production (different secret!)\nJWT_SECRET_KEY=prod-super-secure-key-87y23h9823h\n</code></pre></p> </li> <li> <p>Rotate secrets regularly: <pre><code># Support multiple keys for rotation\nJWT_SECRET_KEYS = [\n    \"new-key\",  # Try this first\n    \"old-key\"   # Fallback for old tokens\n]\n</code></pre></p> </li> <li> <p>Use HTTPS in production:</p> </li> <li>JWT tokens should only be transmitted over HTTPS</li> <li>Configure SSL/TLS on your server or load balancer</li> </ol>"},{"location":"cli/authentication/#token-management","title":"Token Management","text":"<ol> <li> <p>Set appropriate expiration: <pre><code># Short-lived for sensitive operations\nexp = datetime.utcnow() + timedelta(hours=1)\n\n# Longer for regular use\nexp = datetime.utcnow() + timedelta(days=7)\n</code></pre></p> </li> <li> <p>Include required claims: <pre><code>payload = {\n    \"user_id\": user_id,      # Required\n    \"exp\": expiration,        # Required\n    \"iat\": issued_at,         # Recommended\n    \"jti\": token_id,          # For revocation\n    \"aud\": \"agentflow-api\",   # Audience\n    \"iss\": \"auth-service\"     # Issuer\n}\n</code></pre></p> </li> <li> <p>Implement token refresh: <pre><code># Issue refresh token separately\naccess_token = create_token(user_id, expires_in=timedelta(hours=1))\nrefresh_token = create_refresh_token(user_id, expires_in=timedelta(days=30))\n</code></pre></p> </li> <li> <p>Validate all claims: <pre><code># Check expiration\nif payload[\"exp\"] &lt; time.time():\n    raise TokenExpired\n\n# Check audience\nif payload[\"aud\"] != \"agentflow-api\":\n    raise InvalidAudience\n</code></pre></p> </li> </ol>"},{"location":"cli/authentication/#error-handling","title":"Error Handling","text":"<ol> <li> <p>Provide clear error messages: <pre><code>if not token:\n    raise HTTPException(401, \"Authorization header missing\")\n\nif token_expired:\n    raise HTTPException(401, \"Token has expired\")\n\nif invalid_signature:\n    raise HTTPException(401, \"Invalid token signature\")\n</code></pre></p> </li> <li> <p>Log authentication failures: <pre><code>logger.warning(\n    f\"Failed authentication attempt from {request.client.host}\"\n)\n</code></pre></p> </li> <li> <p>Rate limit authentication attempts: <pre><code># Use Redis or similar\nattempts = redis.incr(f\"auth_attempts:{ip}\")\nif attempts &gt; 10:\n    raise HTTPException(429, \"Too many attempts\")\n</code></pre></p> </li> </ol>"},{"location":"cli/authentication/#examples","title":"Examples","text":""},{"location":"cli/authentication/#firebase-authentication","title":"Firebase Authentication","text":"<pre><code># auth/firebase.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nimport firebase_admin\nfrom firebase_admin import credentials, auth\n\n# Initialize Firebase\ncred = credentials.Certificate(\"firebase-credentials.json\")\nfirebase_admin.initialize_app(cred)\n\nclass FirebaseAuth(BaseAuth):\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict:\n        try:\n            # Verify Firebase ID token\n            decoded_token = auth.verify_id_token(credential.credentials)\n            uid = decoded_token['uid']\n\n            return {\n                \"user_id\": uid,\n                \"email\": decoded_token.get('email'),\n                \"email_verified\": decoded_token.get('email_verified'),\n                \"name\": decoded_token.get('name')\n            }\n        except Exception as e:\n            raise HTTPException(401, f\"Invalid Firebase token: {e}\")\n</code></pre> <p>agentflow.json: <pre><code>{\n  \"auth\": {\n    \"method\": \"custom\",\n    \"path\": \"auth.firebase:FirebaseAuth\"\n  }\n}\n</code></pre></p>"},{"location":"cli/authentication/#api-key-authentication","title":"API Key Authentication","text":"<pre><code># auth/api_key.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nimport hashlib\n\nclass APIKeyAuth(BaseAuth):\n    def __init__(self):\n        # In production, load from database\n        self.api_keys = {\n            \"hashed_key_1\": {\n                \"user_id\": \"user1\",\n                \"name\": \"Service Account 1\",\n                \"permissions\": [\"read\", \"write\"]\n            },\n            \"hashed_key_2\": {\n                \"user_id\": \"user2\",\n                \"name\": \"Service Account 2\",\n                \"permissions\": [\"read\"]\n            }\n        }\n\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict:\n        # Hash the provided API key\n        api_key = credential.credentials\n        key_hash = hashlib.sha256(api_key.encode()).hexdigest()\n\n        # Look up in database\n        user_data = self.api_keys.get(key_hash)\n\n        if not user_data:\n            raise HTTPException(401, \"Invalid API key\")\n\n        return {\n            \"user_id\": user_data[\"user_id\"],\n            \"name\": user_data[\"name\"],\n            \"permissions\": user_data[\"permissions\"]\n        }\n</code></pre>"},{"location":"cli/authentication/#oauth-20-authentication","title":"OAuth 2.0 Authentication","text":"<pre><code># auth/oauth.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nimport requests\n\nclass OAuth2Auth(BaseAuth):\n    def __init__(self):\n        self.oauth_server = \"https://oauth.example.com\"\n\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict:\n        # Verify token with OAuth server\n        response = requests.get(\n            f\"{self.oauth_server}/userinfo\",\n            headers={\"Authorization\": f\"Bearer {credential.credentials}\"}\n        )\n\n        if response.status_code != 200:\n            raise HTTPException(401, \"Invalid OAuth token\")\n\n        user_info = response.json()\n\n        return {\n            \"user_id\": user_info[\"sub\"],\n            \"email\": user_info[\"email\"],\n            \"name\": user_info[\"name\"],\n            \"picture\": user_info.get(\"picture\")\n        }\n</code></pre>"},{"location":"cli/authentication/#database-authentication","title":"Database Authentication","text":"<pre><code># auth/database.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nimport jwt\n\nclass DatabaseAuth(BaseAuth):\n    def __init__(self):\n        self.db = self.get_db_connection()\n        self.secret_key = \"your-secret-key\"\n\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict:\n        try:\n            # Decode JWT\n            payload = jwt.decode(\n                credential.credentials,\n                self.secret_key,\n                algorithms=[\"HS256\"]\n            )\n\n            user_id = payload[\"user_id\"]\n\n            # Query database\n            user = self.db.query(User).filter(User.id == user_id).first()\n\n            if not user or not user.is_active:\n                raise HTTPException(401, \"User not found or inactive\")\n\n            return {\n                \"user_id\": user.id,\n                \"username\": user.username,\n                \"email\": user.email,\n                \"roles\": [role.name for role in user.roles],\n                \"permissions\": user.get_permissions()\n            }\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(401, \"Token has expired\")\n        except jwt.InvalidTokenError:\n            raise HTTPException(401, \"Invalid token\")\n\n    def get_db_connection(self) -&gt; Session:\n        # Implement your database connection\n        pass\n</code></pre>"},{"location":"cli/authentication/#multi-factor-authentication","title":"Multi-Factor Authentication","text":"<pre><code># auth/mfa.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials\nimport pyotp\n\nclass MFAAuth(BaseAuth):\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict:\n        # Token format: \"jwt_token:mfa_code\"\n        try:\n            jwt_token, mfa_code = credential.credentials.split(\":\")\n        except ValueError:\n            raise HTTPException(401, \"Invalid token format. Expected: jwt:mfa_code\")\n\n        # Verify JWT\n        user_data = self.verify_jwt(jwt_token)\n\n        # Verify MFA code\n        totp = pyotp.TOTP(user_data[\"mfa_secret\"])\n        if not totp.verify(mfa_code):\n            raise HTTPException(401, \"Invalid MFA code\")\n\n        return {\n            \"user_id\": user_data[\"user_id\"],\n            \"username\": user_data[\"username\"],\n            \"mfa_verified\": True\n        }\n\n    def verify_jwt(self, token: str) -&gt; dict:\n        # Implement JWT verification\n        pass\n</code></pre>"},{"location":"cli/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"cli/authentication/#testing-with-curl","title":"Testing with curl","text":"<pre><code># No auth\ncurl http://localhost:8000/ping\n\n# JWT auth\nTOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\ncurl -H \"Authorization: Bearer $TOKEN\" http://localhost:8000/threads\n\n# API key\ncurl -H \"Authorization: Bearer your-api-key\" http://localhost:8000/threads\n</code></pre>"},{"location":"cli/authentication/#testing-with-pytest","title":"Testing with pytest","text":"<pre><code># tests/test_auth.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom app.main import app\nimport jwt\nfrom datetime import datetime, timedelta\n\nclient = TestClient(app)\n\ndef create_test_token(user_id=\"test_user\"):\n    payload = {\n        \"user_id\": user_id,\n        \"exp\": datetime.utcnow() + timedelta(hours=1)\n    }\n    return jwt.encode(payload, \"test-secret\", algorithm=\"HS256\")\n\ndef test_no_auth_fails():\n    response = client.post(\"/threads\")\n    assert response.status_code == 401\n\ndef test_invalid_token_fails():\n    headers = {\"Authorization\": \"Bearer invalid_token\"}\n    response = client.post(\"/threads\", headers=headers)\n    assert response.status_code == 401\n\ndef test_valid_token_succeeds():\n    token = create_test_token()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = client.post(\"/threads\", headers=headers)\n    assert response.status_code == 200\n\ndef test_expired_token_fails():\n    payload = {\n        \"user_id\": \"test_user\",\n        \"exp\": datetime.utcnow() - timedelta(hours=1)  # Expired\n    }\n    token = jwt.encode(payload, \"test-secret\", algorithm=\"HS256\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = client.post(\"/threads\", headers=headers)\n    assert response.status_code == 401\n</code></pre>"},{"location":"cli/authentication/#additional-resources","title":"Additional Resources","text":"<ul> <li>JWT.io - JWT debugger and documentation</li> <li>Configuration Guide - Complete configuration reference</li> <li>Deployment Guide - Production deployment strategies</li> <li>FastAPI Security - FastAPI security documentation</li> </ul>"},{"location":"cli/cli/","title":"Pyagenity CLI Reference","text":"<p><code>agentflow</code> is the command-line interface for scaffolding, running, and packaging Pyagenity-based agent APIs.</p>"},{"location":"cli/cli/#commands","title":"Commands","text":"Command Description <code>agentflow init</code> Create <code>agentflow.json</code> and sample graph under <code>graph/</code> <code>agentflow init --prod</code> Same as init plus tooling files (<code>pyproject.toml</code>, <code>.pre-commit-config.yaml</code>) <code>agentflow api</code> Run development API server (FastAPI + Uvicorn) <code>agentflow build</code> Generate Dockerfile (and optional docker-compose.yml) <code>agentflow version</code> Show CLI and installed package versions <p>Run <code>agentflow &lt;command&gt; --help</code> for option details.</p>"},{"location":"cli/cli/#init","title":"Init","text":"<p>Scaffolds a runnable agent graph.</p>"},{"location":"cli/cli/#default-files","title":"Default Files","text":"<ul> <li><code>agentflow.json</code> \u2013 main configuration</li> <li><code>graph/react.py</code> \u2013 example agent graph (tool, routing, LiteLLM call)</li> <li><code>graph/__init__.py</code></li> </ul>"},{"location":"cli/cli/#with-prod","title":"With <code>--prod</code>","text":"<p>Adds: * <code>.pre-commit-config.yaml</code> * <code>pyproject.toml</code></p> <p>Flags:</p> Flag Meaning <code>--path/-p</code> Target directory (default <code>.</code>) <code>--force/-f</code> Overwrite existing files <code>--prod</code> Include production tooling <p>Example: <pre><code>agentflow init --prod --path myservice\ncd myservice\npre-commit install\n</code></pre></p>"},{"location":"cli/cli/#api","title":"API","text":"<p>Starts a development server (hot reload by default).</p> <p>Key options:</p> Option Default Notes <code>--config/-c</code> <code>agentflow.json</code> Config file path <code>--host/-H</code> <code>0.0.0.0</code> Use <code>127.0.0.1</code> for local only <code>--port/-p</code> <code>8000</code> Port to bind <code>--reload/--no-reload</code> reload on Auto-reload for dev <p>Behavior: * Loads <code>.env</code> (or file specified in config). * Sets <code>GRAPH_PATH</code> env var for runtime.</p>"},{"location":"cli/cli/#build","title":"Build","text":"<p>Generates production Docker artifacts.</p> <p>Options:</p> Option Default Description <code>--output/-o</code> <code>Dockerfile</code> Dockerfile path <code>--python-version</code> <code>3.13</code> Base image tag <code>--port/-p</code> <code>8000</code> Exposed container port <code>--docker-compose</code> off Also create <code>docker-compose.yml</code> and omit CMD <code>--service-name</code> <code>agentflow-cli</code> Compose service name <p>Features: * Auto-detects requirements file (fallback installs <code>agentflow-cli</code>). * Adds health check to <code>/ping</code>. * Uses <code>gunicorn</code> + uvicorn worker (production pattern).</p>"},{"location":"cli/cli/#version","title":"Version","text":"<p>Displays both the CLI internal version and the package version read from <code>pyproject.toml</code>.</p>"},{"location":"cli/cli/#environment-variables-used","title":"Environment Variables Used","text":"Variable Purpose <code>GRAPH_PATH</code> Path to active config file for graph loading <code>PYTHONDONTWRITEBYTECODE</code> Disable <code>.pyc</code> (Docker) <code>PYTHONUNBUFFERED</code> Unbuffered I/O (Docker)"},{"location":"cli/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Generic failure 2 Configuration error 3 Validation error"},{"location":"cli/cli/#quick-reference","title":"Quick Reference","text":"<pre><code>agentflow init\nagentflow init --prod\nagentflow api --reload\nagentflow build --docker-compose\nagentflow version\n</code></pre>"},{"location":"cli/cli/#suggestions-after-prod","title":"Suggestions After <code>--prod</code>","text":"<ol> <li>Edit metadata in <code>pyproject.toml</code>.</li> <li>Install hooks: <code>pre-commit install</code>.</li> <li>Run tests: <code>pytest</code>.</li> <li>Build image: <code>agentflow build</code>.</li> <li>Deploy container.</li> </ol>"},{"location":"cli/configuration/","title":"Configuration Reference","text":"<p>This document provides a complete reference for configuring your AgentFlow application through <code>agentflow.json</code> and environment variables.</p>"},{"location":"cli/configuration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Configuration File</li> <li>Core Configuration</li> <li>Authentication</li> <li>Dependency Injection</li> <li>Storage &amp; Persistence</li> <li>Environment Variables</li> <li>Application Settings</li> <li>Examples</li> </ul>"},{"location":"cli/configuration/#configuration-file","title":"Configuration File","text":""},{"location":"cli/configuration/#location","title":"Location","text":"<p>The configuration file is typically named <code>agentflow.json</code> and should be placed in your project root. You can specify a custom location:</p> <pre><code>agentflow api --config /path/to/config.json\n</code></pre>"},{"location":"cli/configuration/#file-resolution-order","title":"File Resolution Order","text":"<ol> <li>Explicit path provided via <code>--config</code> flag</li> <li>Current working directory</li> <li>Relative to CLI installation</li> <li>Package directory</li> </ol>"},{"location":"cli/configuration/#basic-structure","title":"Basic Structure","text":"<pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"env\": \".env\",\n  \"auth\": null,\n  \"checkpointer\": null,\n  \"injectq\": null,\n  \"store\": null,\n  \"redis\": null,\n  \"thread_name_generator\": null\n}\n</code></pre>"},{"location":"cli/configuration/#core-configuration","title":"Core Configuration","text":""},{"location":"cli/configuration/#agent-required","title":"<code>agent</code> (Required)","text":"<p>Path to your compiled agent graph.</p> <p>Format: <code>module.path:variable_name</code></p> <p>Example: <pre><code>{\n  \"agent\": \"graph.react:app\"\n}\n</code></pre></p> <p>This resolves to: <pre><code># graph/react.py\nfrom agentflow.graph import StateGraph\n\ngraph = StateGraph()\n# ... graph configuration ...\napp = graph.compile()\n</code></pre></p> <p>Multiple Graphs: <pre><code>{\n  \"agent\": \"graph.customer_service:support_agent\"\n}\n</code></pre></p> <pre><code># graph/customer_service.py\nsupport_agent = graph.compile(checkpointer=checkpointer)\n</code></pre>"},{"location":"cli/configuration/#env","title":"<code>env</code>","text":"<p>Path to environment variables file.</p> <p>Type: <code>string | null</code></p> <p>Default: <code>.env</code></p> <p>Examples: <pre><code>// Use default .env file\n{\n  \"env\": \".env\"\n}\n\n// Use environment-specific file\n{\n  \"env\": \".env.production\"\n}\n\n// Multiple environment files\n{\n  \"env\": \".env.local\"  // This will be loaded\n}\n\n// Disable env file loading\n{\n  \"env\": null\n}\n</code></pre></p> <p>Best Practice: <pre><code># Development\n.env.development\n\n# Staging\n.env.staging\n\n# Production\n.env.production\n</code></pre></p>"},{"location":"cli/configuration/#authentication","title":"Authentication","text":""},{"location":"cli/configuration/#auth","title":"<code>auth</code>","text":"<p>Configure authentication for your API.</p> <p>Type: <code>null | \"jwt\" | { \"method\": \"custom\", \"path\": \"module:class\" }</code></p>"},{"location":"cli/configuration/#no-authentication","title":"No Authentication","text":"<pre><code>{\n  \"auth\": null\n}\n</code></pre>"},{"location":"cli/configuration/#jwt-authentication","title":"JWT Authentication","text":"<pre><code>{\n  \"auth\": \"jwt\"\n}\n</code></pre> <p>Required Environment Variables: <pre><code>JWT_SECRET_KEY=your-super-secret-key-change-this\nJWT_ALGORITHM=HS256\n</code></pre></p> <p>Supported Algorithms: - HS256 (HMAC with SHA-256) - HS384 (HMAC with SHA-384) - HS512 (HMAC with SHA-512) - RS256 (RSA with SHA-256) - RS384 (RSA with SHA-384) - RS512 (RSA with SHA-512) - ES256 (ECDSA with SHA-256) - ES384 (ECDSA with SHA-384) - ES512 (ECDSA with SHA-512)</p>"},{"location":"cli/configuration/#custom-authentication","title":"Custom Authentication","text":"<pre><code>{\n  \"auth\": {\n    \"method\": \"custom\",\n    \"path\": \"auth.custom:CustomAuthBackend\"\n  }\n}\n</code></pre> <p>Implementation: <pre><code># auth/custom.py\nfrom agentflow_cli import BaseAuth\nfrom fastapi import Response\nfrom fastapi.security import HTTPAuthorizationCredentials\n\nclass CustomAuthBackend(BaseAuth):\n    def authenticate(\n        self,\n        res: Response,\n        credential: HTTPAuthorizationCredentials\n    ) -&gt; dict[str, any] | None:\n        \"\"\"\n        Authenticate the user based on credentials.\n\n        Returns:\n            dict with user info including 'user_id', or None if auth fails\n        \"\"\"\n        token = credential.credentials\n\n        # Your custom authentication logic\n        user = verify_custom_token(token)\n\n        if not user:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n        return {\n            \"user_id\": user.id,\n            \"username\": user.username,\n            \"email\": user.email,\n            \"roles\": user.roles\n        }\n</code></pre></p> <p>See also: Authentication Guide</p>"},{"location":"cli/configuration/#dependency-injection","title":"Dependency Injection","text":""},{"location":"cli/configuration/#injectq","title":"<code>injectq</code>","text":"<p>Path to custom InjectQ container for dependency injection.</p> <p>Type: <code>string | null</code></p> <p>Format: <code>module.path:container_instance</code></p> <p>Example: <pre><code>{\n  \"injectq\": \"app.container:container\"\n}\n</code></pre></p> <p>Implementation: <pre><code># app/container.py\nfrom injectq import InjectQ\nfrom redis import Redis\n\ncontainer = InjectQ()\n\n# Bind services\ncontainer.bind_instance(Redis, Redis(host='localhost', port=6379))\n\n# Bind configurations\ncontainer.bind_instance(dict, {\"api_key\": \"xxx\"}, name=\"config\")\n</code></pre></p> <p>Default Behavior: If not specified, AgentFlow creates a default container with: - GraphConfig instance - BaseAuth (if configured) - ThreadNameGenerator (if configured)</p>"},{"location":"cli/configuration/#storage-persistence","title":"Storage &amp; Persistence","text":""},{"location":"cli/configuration/#checkpointer","title":"<code>checkpointer</code>","text":"<p>Path to checkpointer for conversation state persistence.</p> <p>Type: <code>string | null</code></p> <p>Format: <code>module.path:checkpointer_instance</code></p> <p>Example: <pre><code>{\n  \"checkpointer\": \"storage.checkpointer:redis_checkpointer\"\n}\n</code></pre></p> <p>Implementation: <pre><code># storage/checkpointer.py\nfrom agentflow.checkpointer import RedisCheckpointer\n\nredis_checkpointer = RedisCheckpointer(\n    redis_url=\"redis://localhost:6379\",\n    ttl=3600  # 1 hour\n)\n</code></pre></p> <p>Built-in Checkpointers: - <code>InMemoryCheckpointer</code> - For development/testing - <code>RedisCheckpointer</code> - For production with Redis - <code>PostgresCheckpointer</code> - For PostgreSQL storage</p>"},{"location":"cli/configuration/#store","title":"<code>store</code>","text":"<p>Path to store for additional data persistence.</p> <p>Type: <code>string | null</code></p> <p>Format: <code>module.path:store_instance</code></p> <p>Example: <pre><code>{\n  \"store\": \"storage.store:redis_store\"\n}\n</code></pre></p> <p>Implementation: <pre><code># storage/store.py\nfrom agentflow.store import RedisStore\n\nredis_store = RedisStore(\n    redis_url=\"redis://localhost:6379\"\n)\n</code></pre></p>"},{"location":"cli/configuration/#redis","title":"<code>redis</code>","text":"<p>Redis connection URL for caching and sessions.</p> <p>Type: <code>string | null</code></p> <p>Format: <code>redis://[username:password@]host:port[/database]</code></p> <p>Examples: <pre><code>// Local Redis\n{\n  \"redis\": \"redis://localhost:6379\"\n}\n\n// With authentication\n{\n  \"redis\": \"redis://user:password@redis-host:6379\"\n}\n\n// Specific database\n{\n  \"redis\": \"redis://localhost:6379/1\"\n}\n\n// Redis Cluster\n{\n  \"redis\": \"redis://node1:6379,node2:6379,node3:6379\"\n}\n\n// Use environment variable\n{\n  \"redis\": \"${REDIS_URL}\"\n}\n</code></pre></p> <p>Environment Variable: <pre><code>REDIS_URL=redis://localhost:6379\n</code></pre></p>"},{"location":"cli/configuration/#thread-name-generation","title":"Thread Name Generation","text":""},{"location":"cli/configuration/#thread_name_generator","title":"<code>thread_name_generator</code>","text":"<p>Path to custom thread name generator.</p> <p>Type: <code>string | null</code></p> <p>Format: <code>module.path:generator_class</code></p> <p>Example: <pre><code>{\n  \"thread_name_generator\": \"utils.naming:CustomNameGenerator\"\n}\n</code></pre></p> <p>Implementation: <pre><code># utils/naming.py\nfrom agentflow_cli import ThreadNameGenerator\n\nclass CustomNameGenerator(ThreadNameGenerator):\n    async def generate_name(self, messages: list[str]) -&gt; str:\n        \"\"\"Generate a custom thread name from messages.\"\"\"\n        # Custom logic here\n        return f\"thread-{uuid.uuid4().hex[:8]}\"\n</code></pre></p> <p>Default Behavior: If not specified, the system uses <code>AIThreadNameGenerator</code> which generates names like: - <code>thoughtful-dialogue</code> - <code>exploring-ideas</code> - <code>deep-dive</code></p> <p>See also: Thread Name Generator Guide</p>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"cli/configuration/#core-variables","title":"Core Variables","text":"Variable Type Description Default <code>GRAPH_PATH</code> string Path to agentflow.json Set by CLI <code>ENVIRONMENT</code> string Environment name <code>development</code> <code>LOG_LEVEL</code> string Logging level <code>INFO</code> <code>DEBUG</code> boolean Debug mode <code>false</code>"},{"location":"cli/configuration/#application-settings","title":"Application Settings","text":"Variable Type Description Default <code>APP_NAME</code> string Application name <code>MyApp</code> <code>APP_VERSION</code> string Application version <code>0.1.0</code> <code>MODE</code> string Running mode <code>development</code> <code>SUMMARY</code> string API summary <code>Pyagenity Backend</code>"},{"location":"cli/configuration/#server-settings","title":"Server Settings","text":"Variable Type Description Default <code>ORIGINS</code> string CORS allowed origins <code>*</code> <code>ALLOWED_HOST</code> string Allowed hosts <code>*</code> <code>ROOT_PATH</code> string API root path `` <code>DOCS_PATH</code> string Swagger docs path `` <code>REDOCS_PATH</code> string ReDoc path ``"},{"location":"cli/configuration/#authentication_1","title":"Authentication","text":"Variable Type Description Required <code>JWT_SECRET_KEY</code> string JWT signing key Yes (if JWT auth) <code>JWT_ALGORITHM</code> string JWT algorithm Yes (if JWT auth)"},{"location":"cli/configuration/#api-keys","title":"API Keys","text":"Variable Type Description <code>GEMINI_API_KEY</code> string Google Gemini API key <code>OPENAI_API_KEY</code> string OpenAI API key <code>ANTHROPIC_API_KEY</code> string Anthropic Claude API key"},{"location":"cli/configuration/#snowflake-id-generator","title":"Snowflake ID Generator","text":"Variable Type Description Default <code>SNOWFLAKE_EPOCH</code> integer Epoch timestamp (ms) <code>1609459200000</code> <code>SNOWFLAKE_NODE_ID</code> integer Node ID <code>1</code> <code>SNOWFLAKE_WORKER_ID</code> integer Worker ID <code>2</code> <code>SNOWFLAKE_TIME_BITS</code> integer Time bits <code>39</code> <code>SNOWFLAKE_NODE_BITS</code> integer Node bits <code>5</code> <code>SNOWFLAKE_WORKER_BITS</code> integer Worker bits <code>8</code> <code>SNOWFLAKE_TOTAL_BITS</code> integer Total bits <code>64</code>"},{"location":"cli/configuration/#redis_1","title":"Redis","text":"Variable Type Description Default <code>REDIS_URL</code> string Redis connection URL <code>null</code>"},{"location":"cli/configuration/#sentry","title":"Sentry","text":"Variable Type Description Default <code>SENTRY_DSN</code> string Sentry DSN for error tracking <code>null</code>"},{"location":"cli/configuration/#application-settings_1","title":"Application Settings","text":"<p>Settings are defined in <code>agentflow_cli/src/app/core/config/settings.py</code>.</p>"},{"location":"cli/configuration/#settings-class","title":"Settings Class","text":"<pre><code>from agentflow_cli.src.app.core import get_settings\n\nsettings = get_settings()\n\n# Access settings\nprint(settings.APP_NAME)\nprint(settings.LOG_LEVEL)\nprint(settings.REDIS_URL)\n</code></pre>"},{"location":"cli/configuration/#available-settings","title":"Available Settings","text":"<pre><code>class Settings(BaseSettings):\n    # Application Info\n    APP_NAME: str = \"MyApp\"\n    APP_VERSION: str = \"0.1.0\"\n    MODE: str = \"development\"\n    LOG_LEVEL: str = \"INFO\"\n    IS_DEBUG: bool = True\n    SUMMARY: str = \"Pyagenity Backend\"\n\n    # CORS\n    ORIGINS: str = \"*\"\n    ALLOWED_HOST: str = \"*\"\n\n    # Paths\n    ROOT_PATH: str = \"\"\n    DOCS_PATH: str = \"\"\n    REDOCS_PATH: str = \"\"\n\n    # Redis\n    REDIS_URL: str | None = None\n\n    # Sentry\n    SENTRY_DSN: str | None = None\n\n    # Snowflake ID Generator\n    SNOWFLAKE_EPOCH: int = 1609459200000\n    SNOWFLAKE_NODE_ID: int = 1\n    SNOWFLAKE_WORKER_ID: int = 2\n    SNOWFLAKE_TIME_BITS: int = 39\n    SNOWFLAKE_NODE_BITS: int = 5\n    SNOWFLAKE_WORKER_BITS: int = 8\n</code></pre>"},{"location":"cli/configuration/#custom-settings","title":"Custom Settings","text":"<p>Create a custom settings file:</p> <pre><code># app/settings.py\nfrom agentflow_cli.src.app.core.config.settings import Settings\n\nclass CustomSettings(Settings):\n    # Add your custom settings\n    CUSTOM_API_KEY: str = \"\"\n    MAX_UPLOAD_SIZE: int = 10_000_000  # 10 MB\n    RATE_LIMIT: int = 100\n</code></pre>"},{"location":"cli/configuration/#examples","title":"Examples","text":""},{"location":"cli/configuration/#development-configuration","title":"Development Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"env\": \".env.development\",\n  \"auth\": null,\n  \"checkpointer\": null,\n  \"redis\": null,\n  \"thread_name_generator\": null\n}\n</code></pre></p> <p>.env.development: <pre><code>ENVIRONMENT=development\nLOG_LEVEL=DEBUG\nDEBUG=true\n\n# API Keys for testing\nGEMINI_API_KEY=your_dev_key\n\n# No Redis in development\nREDIS_URL=\n</code></pre></p>"},{"location":"cli/configuration/#staging-configuration","title":"Staging Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"env\": \".env.staging\",\n  \"auth\": \"jwt\",\n  \"checkpointer\": \"storage.checkpointer:redis_checkpointer\",\n  \"redis\": \"${REDIS_URL}\",\n  \"store\": \"storage.store:redis_store\"\n}\n</code></pre></p> <p>.env.staging: <pre><code>ENVIRONMENT=staging\nLOG_LEVEL=INFO\nDEBUG=false\n\n# JWT Auth\nJWT_SECRET_KEY=staging-secret-key\nJWT_ALGORITHM=HS256\n\n# API Keys\nGEMINI_API_KEY=your_staging_key\n\n# Redis\nREDIS_URL=redis://staging-redis:6379\n\n# Sentry\nSENTRY_DSN=https://xxx@sentry.io/staging-project\n</code></pre></p>"},{"location":"cli/configuration/#production-configuration","title":"Production Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"graph.production:production_app\",\n  \"env\": \".env.production\",\n  \"auth\": {\n    \"method\": \"custom\",\n    \"path\": \"auth.production:ProductionAuth\"\n  },\n  \"checkpointer\": \"storage.checkpointer:redis_checkpointer\",\n  \"injectq\": \"app.container:production_container\",\n  \"store\": \"storage.store:postgres_store\",\n  \"redis\": \"${REDIS_URL}\",\n  \"thread_name_generator\": \"utils.naming:ProductionNameGenerator\"\n}\n</code></pre></p> <p>.env.production: <pre><code>ENVIRONMENT=production\nLOG_LEVEL=WARNING\nDEBUG=false\n\n# Application\nAPP_NAME=AgentFlow Production API\nAPP_VERSION=1.0.0\nSUMMARY=Production Agent API\n\n# CORS (restrict origins)\nORIGINS=https://app.example.com,https://admin.example.com\nALLOWED_HOST=api.example.com\n\n# JWT Auth\nJWT_SECRET_KEY=super-secure-production-key\nJWT_ALGORITHM=RS256\n\n# API Keys\nGEMINI_API_KEY=your_production_key\n\n# Redis with auth\nREDIS_URL=redis://user:password@prod-redis:6379/0\n\n# Sentry\nSENTRY_DSN=https://xxx@sentry.io/production-project\n\n# Snowflake ID\nSNOWFLAKE_EPOCH=1609459200000\nSNOWFLAKE_NODE_ID=1\nSNOWFLAKE_WORKER_ID=1\n</code></pre></p>"},{"location":"cli/configuration/#multi-agent-configuration","title":"Multi-Agent Configuration","text":"<p>agentflow.json: <pre><code>{\n  \"agent\": \"agents.orchestrator:main_agent\",\n  \"env\": \".env\",\n  \"auth\": \"jwt\",\n  \"checkpointer\": \"storage.checkpointer:redis_checkpointer\",\n  \"injectq\": \"agents.container:agent_container\",\n  \"redis\": \"${REDIS_URL}\"\n}\n</code></pre></p> <p>agents/orchestrator.py: <pre><code>from agentflow.graph import StateGraph\n\n# Customer Service Agent\ncustomer_service = StateGraph()\n# ... configure ...\ncustomer_agent = customer_service.compile()\n\n# Sales Agent\nsales_graph = StateGraph()\n# ... configure ...\nsales_agent = sales_graph.compile()\n\n# Main Orchestrator\nmain_graph = StateGraph()\n# ... configure with sub-agents ...\nmain_agent = main_graph.compile(checkpointer=redis_checkpointer)\n</code></pre></p>"},{"location":"cli/configuration/#microservices-configuration","title":"Microservices Configuration","text":"<p>Service 1 (Auth Service): <pre><code>{\n  \"agent\": \"services.auth:auth_agent\",\n  \"env\": \".env.auth\",\n  \"auth\": \"jwt\",\n  \"redis\": \"${REDIS_URL}\"\n}\n</code></pre></p> <p>Service 2 (Chat Service): <pre><code>{\n  \"agent\": \"services.chat:chat_agent\",\n  \"env\": \".env.chat\",\n  \"auth\": \"jwt\",\n  \"checkpointer\": \"storage.checkpointer:redis_checkpointer\",\n  \"redis\": \"${REDIS_URL}\",\n  \"thread_name_generator\": \"services.chat.naming:ChatNameGenerator\"\n}\n</code></pre></p> <p>Service 3 (Analytics Service): <pre><code>{\n  \"agent\": \"services.analytics:analytics_agent\",\n  \"env\": \".env.analytics\",\n  \"auth\": null,\n  \"store\": \"storage.store:analytics_store\",\n  \"redis\": \"${REDIS_URL}\"\n}\n</code></pre></p>"},{"location":"cli/configuration/#configuration-validation","title":"Configuration Validation","text":""},{"location":"cli/configuration/#validate-configuration","title":"Validate Configuration","text":"<p>The CLI automatically validates your configuration on startup. Common validation errors:</p> <p>Missing Required Fields: <pre><code>ConfigurationError: 'agent' field is required in agentflow.json\n</code></pre></p> <p>Invalid Module Path: <pre><code>ConfigurationError: Cannot load module 'graph.react'\n</code></pre></p> <p>JWT Configuration Missing: <pre><code>ValueError: JWT_SECRET_KEY and JWT_ALGORITHM must be set in environment variables\n</code></pre></p> <p>Invalid Auth Method: <pre><code>ValueError: Unsupported auth method: invalid_method\n</code></pre></p>"},{"location":"cli/configuration/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Environment Variables for Secrets: <pre><code>{\n  \"redis\": \"${REDIS_URL}\"\n}\n</code></pre></p> </li> <li> <p>Separate Configs per Environment:</p> </li> <li><code>.env.development</code></li> <li><code>.env.staging</code></li> <li> <p><code>.env.production</code></p> </li> <li> <p>Version Control:</p> </li> <li>\u2705 Commit: <code>agentflow.json</code></li> <li>\u2705 Commit: <code>.env.example</code></li> <li> <p>\u274c Never commit: <code>.env</code>, <code>.env.production</code></p> </li> <li> <p>Document Custom Settings: <pre><code>class Settings(BaseSettings):\n    CUSTOM_SETTING: str = \"default\"\n    \"\"\"Description of what this setting does\"\"\"\n</code></pre></p> </li> <li> <p>Validate on Startup: <pre><code>settings = get_settings()\nif not settings.GEMINI_API_KEY:\n    raise ValueError(\"GEMINI_API_KEY is required\")\n</code></pre></p> </li> </ol>"},{"location":"cli/deployment/","title":"Deployment Guide","text":"<p>This guide covers deploying your AgentFlow application to production using various deployment strategies.</p>"},{"location":"cli/deployment/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Docker Deployment</li> <li>Docker Compose</li> <li>Kubernetes</li> <li>Cloud Platforms</li> <li>Production Checklist</li> <li>Monitoring &amp; Logging</li> <li>Scaling</li> </ul>"},{"location":"cli/deployment/#quick-start","title":"Quick Start","text":"<p>The fastest way to deploy your AgentFlow application:</p> <pre><code># 1. Generate Docker files\nagentflow build --docker-compose --force\n\n# 2. Build and run\ndocker compose up --build -d\n\n# 3. Verify deployment\ncurl http://localhost:8000/ping\n</code></pre>"},{"location":"cli/deployment/#docker-deployment","title":"Docker Deployment","text":""},{"location":"cli/deployment/#step-1-generate-dockerfile","title":"Step 1: Generate Dockerfile","text":"<pre><code>agentflow build --python-version 3.13 --port 8000\n</code></pre> <p>This generates an optimized production Dockerfile with: - \u2705 Python 3.13 slim base image - \u2705 Non-root user for security - \u2705 Health checks - \u2705 Gunicorn + Uvicorn workers - \u2705 Multi-layer caching</p>"},{"location":"cli/deployment/#step-2-build-docker-image","title":"Step 2: Build Docker Image","text":"<pre><code># Basic build\ndocker build -t agentflow-api:latest .\n\n# Build with custom tag\ndocker build -t mycompany/agentflow-api:v1.0.0 .\n\n# Build with build args\ndocker build \\\n  --build-arg PYTHON_VERSION=3.13 \\\n  -t agentflow-api:latest \\\n  .\n</code></pre>"},{"location":"cli/deployment/#step-3-run-container","title":"Step 3: Run Container","text":"<p>Basic run: <pre><code>docker run -p 8000:8000 agentflow-api:latest\n</code></pre></p> <p>With environment file: <pre><code>docker run -p 8000:8000 --env-file .env agentflow-api:latest\n</code></pre></p> <p>With environment variables: <pre><code>docker run -p 8000:8000 \\\n  -e GEMINI_API_KEY=your_key \\\n  -e LOG_LEVEL=INFO \\\n  agentflow-api:latest\n</code></pre></p> <p>Detached mode with restart policy: <pre><code>docker run -d \\\n  --name agentflow-api \\\n  --restart unless-stopped \\\n  -p 8000:8000 \\\n  --env-file .env \\\n  agentflow-api:latest\n</code></pre></p>"},{"location":"cli/deployment/#step-4-verify-deployment","title":"Step 4: Verify Deployment","text":"<pre><code># Check container status\ndocker ps\n\n# Check logs\ndocker logs agentflow-api\n\n# Follow logs\ndocker logs -f agentflow-api\n\n# Health check\ncurl http://localhost:8000/ping\n</code></pre>"},{"location":"cli/deployment/#docker-best-practices","title":"Docker Best Practices","text":"<ol> <li> <p>Use specific Python versions instead of <code>latest</code>:    <pre><code>agentflow build --python-version 3.13\n</code></pre></p> </li> <li> <p>Tag images with versions:    <pre><code>docker build -t myapp:v1.0.0 .\ndocker build -t myapp:latest .\n</code></pre></p> </li> <li> <p>Use multi-stage builds for smaller images (already done in generated Dockerfile)</p> </li> <li> <p>Scan images for vulnerabilities:    <pre><code>docker scan agentflow-api:latest\n</code></pre></p> </li> <li> <p>Use Docker secrets for sensitive data:    <pre><code>echo \"my-secret\" | docker secret create api_key -\n</code></pre></p> </li> </ol>"},{"location":"cli/deployment/#docker-compose","title":"Docker Compose","text":""},{"location":"cli/deployment/#generate-docker-composeyml","title":"Generate docker-compose.yml","text":"<pre><code>agentflow build --docker-compose --service-name my-agent-api\n</code></pre>"},{"location":"cli/deployment/#basic-docker-composeyml","title":"Basic docker-compose.yml","text":"<pre><code>services:\n  agentflow-cli:\n    build: .\n    image: agentflow-cli:latest\n    environment:\n      - PYTHONUNBUFFERED=1\n      - PYTHONDONTWRITEBYTECODE=1\n    ports:\n      - '8000:8000'\n    command: ['gunicorn', '-k', 'uvicorn.workers.UvicornWorker', '-b', '0.0.0.0:8000', 'agentflow_cli.src.app.main:app']\n    restart: unless-stopped\n</code></pre>"},{"location":"cli/deployment/#production-docker-composeyml","title":"Production docker-compose.yml","text":"<pre><code>version: '3.8'\n\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    image: agentflow-api:latest\n    container_name: agentflow-api\n    restart: unless-stopped\n    ports:\n      - \"8000:8000\"\n    env_file:\n      - .env\n    environment:\n      - ENVIRONMENT=production\n      - LOG_LEVEL=INFO\n      - WORKERS=4\n    volumes:\n      - ./logs:/app/logs\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/ping\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n    networks:\n      - agentflow-network\n    depends_on:\n      redis:\n        condition: service_healthy\n    deploy:\n      resources:\n        limits:\n          cpus: '2.0'\n          memory: 2G\n        reservations:\n          cpus: '1.0'\n          memory: 1G\n\n  redis:\n    image: redis:7-alpine\n    container_name: agentflow-redis\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - agentflow-network\n\n  nginx:\n    image: nginx:alpine\n    container_name: agentflow-nginx\n    restart: unless-stopped\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./ssl:/etc/nginx/ssl:ro\n    depends_on:\n      - api\n    networks:\n      - agentflow-network\n\nvolumes:\n  redis-data:\n\nnetworks:\n  agentflow-network:\n    driver: bridge\n</code></pre>"},{"location":"cli/deployment/#commands","title":"Commands","text":"<pre><code># Start services\ndocker compose up -d\n\n# Build and start\ndocker compose up --build -d\n\n# View logs\ndocker compose logs -f\n\n# View specific service logs\ndocker compose logs -f api\n\n# Stop services\ndocker compose down\n\n# Stop and remove volumes\ndocker compose down -v\n\n# Restart a service\ndocker compose restart api\n\n# Scale service\ndocker compose up -d --scale api=3\n</code></pre>"},{"location":"cli/deployment/#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code># Application\nENVIRONMENT=production\nLOG_LEVEL=INFO\nDEBUG=false\n\n# API Keys\nGEMINI_API_KEY=your_gemini_api_key\nOPENAI_API_KEY=your_openai_api_key\n\n# JWT Authentication\nJWT_SECRET_KEY=your-super-secret-key-change-this\nJWT_ALGORITHM=HS256\n\n# Redis\nREDIS_URL=redis://redis:6379\n\n# Sentry (optional)\nSENTRY_DSN=your_sentry_dsn\n\n# Snowflake ID Generator\nSNOWFLAKE_EPOCH=1609459200000\nSNOWFLAKE_NODE_ID=1\nSNOWFLAKE_WORKER_ID=1\n</code></pre>"},{"location":"cli/deployment/#kubernetes","title":"Kubernetes","text":""},{"location":"cli/deployment/#basic-deployment","title":"Basic Deployment","text":"<p>deployment.yaml: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: agentflow-api\n  labels:\n    app: agentflow-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: agentflow-api\n  template:\n    metadata:\n      labels:\n        app: agentflow-api\n    spec:\n      containers:\n      - name: api\n        image: myregistry/agentflow-api:latest\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8000\n          name: http\n        env:\n        - name: ENVIRONMENT\n          value: \"production\"\n        - name: LOG_LEVEL\n          value: \"INFO\"\n        - name: GEMINI_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: api-secrets\n              key: gemini-api-key\n        - name: JWT_SECRET_KEY\n          valueFrom:\n            secretKeyRef:\n              name: api-secrets\n              key: jwt-secret\n        - name: REDIS_URL\n          value: \"redis://redis-service:6379\"\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"2Gi\"\n            cpu: \"2000m\"\n        livenessProbe:\n          httpGet:\n            path: /ping\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /ping\n            port: 8000\n          initialDelaySeconds: 10\n          periodSeconds: 5\n          timeoutSeconds: 3\n          failureThreshold: 3\n</code></pre></p> <p>service.yaml: <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: agentflow-api-service\nspec:\n  selector:\n    app: agentflow-api\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8000\n  type: LoadBalancer\n</code></pre></p> <p>secrets.yaml: <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: api-secrets\ntype: Opaque\nstringData:\n  gemini-api-key: \"your_gemini_api_key\"\n  jwt-secret: \"your-jwt-secret-key\"\n</code></pre></p> <p>configmap.yaml: <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: agentflow-config\ndata:\n  agentflow.json: |\n    {\n      \"agent\": \"graph.react:app\",\n      \"env\": \".env\",\n      \"auth\": \"jwt\",\n      \"redis\": \"redis://redis-service:6379\"\n    }\n</code></pre></p>"},{"location":"cli/deployment/#deploy-to-kubernetes","title":"Deploy to Kubernetes","text":"<pre><code># Create secrets (from .env file or manually)\nkubectl create secret generic api-secrets \\\n  --from-literal=gemini-api-key=your_key \\\n  --from-literal=jwt-secret=your_jwt_secret\n\n# Apply configurations\nkubectl apply -f configmap.yaml\nkubectl apply -f deployment.yaml\nkubectl apply -f service.yaml\n\n# Check status\nkubectl get pods\nkubectl get services\nkubectl get deployments\n\n# View logs\nkubectl logs -f deployment/agentflow-api\n\n# Scale deployment\nkubectl scale deployment agentflow-api --replicas=5\n\n# Update image\nkubectl set image deployment/agentflow-api api=myregistry/agentflow-api:v2.0.0\n\n# Rollback\nkubectl rollout undo deployment/agentflow-api\n</code></pre>"},{"location":"cli/deployment/#ingress","title":"Ingress","text":"<p>ingress.yaml: <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: agentflow-ingress\n  annotations:\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - api.example.com\n    secretName: agentflow-tls\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: agentflow-api-service\n            port:\n              number: 80\n</code></pre></p>"},{"location":"cli/deployment/#cloud-platforms","title":"Cloud Platforms","text":""},{"location":"cli/deployment/#aws-ecs","title":"AWS ECS","text":"<p>task-definition.json: <pre><code>{\n  \"family\": \"agentflow-api\",\n  \"networkMode\": \"awsvpc\",\n  \"requiresCompatibilities\": [\"FARGATE\"],\n  \"cpu\": \"1024\",\n  \"memory\": \"2048\",\n  \"containerDefinitions\": [\n    {\n      \"name\": \"api\",\n      \"image\": \"your-ecr-repo/agentflow-api:latest\",\n      \"portMappings\": [\n        {\n          \"containerPort\": 8000,\n          \"protocol\": \"tcp\"\n        }\n      ],\n      \"environment\": [\n        {\n          \"name\": \"ENVIRONMENT\",\n          \"value\": \"production\"\n        }\n      ],\n      \"secrets\": [\n        {\n          \"name\": \"GEMINI_API_KEY\",\n          \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:gemini-key\"\n        }\n      ],\n      \"logConfiguration\": {\n        \"logDriver\": \"awslogs\",\n        \"options\": {\n          \"awslogs-group\": \"/ecs/agentflow-api\",\n          \"awslogs-region\": \"us-east-1\",\n          \"awslogs-stream-prefix\": \"ecs\"\n        }\n      },\n      \"healthCheck\": {\n        \"command\": [\"CMD-SHELL\", \"curl -f http://localhost:8000/ping || exit 1\"],\n        \"interval\": 30,\n        \"timeout\": 5,\n        \"retries\": 3,\n        \"startPeriod\": 60\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"cli/deployment/#google-cloud-run","title":"Google Cloud Run","text":"<pre><code># Build and push to GCR\ndocker build -t gcr.io/your-project/agentflow-api:latest .\ndocker push gcr.io/your-project/agentflow-api:latest\n\n# Deploy to Cloud Run\ngcloud run deploy agentflow-api \\\n  --image gcr.io/your-project/agentflow-api:latest \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated \\\n  --set-env-vars ENVIRONMENT=production \\\n  --set-secrets GEMINI_API_KEY=gemini-key:latest \\\n  --memory 2Gi \\\n  --cpu 2 \\\n  --min-instances 1 \\\n  --max-instances 10\n</code></pre>"},{"location":"cli/deployment/#azure-container-instances","title":"Azure Container Instances","text":"<pre><code># Create resource group\naz group create --name agentflow-rg --location eastus\n\n# Create container\naz container create \\\n  --resource-group agentflow-rg \\\n  --name agentflow-api \\\n  --image myregistry.azurecr.io/agentflow-api:latest \\\n  --cpu 2 \\\n  --memory 4 \\\n  --ports 8000 \\\n  --environment-variables \\\n    ENVIRONMENT=production \\\n    LOG_LEVEL=INFO \\\n  --secure-environment-variables \\\n    GEMINI_API_KEY=your_key \\\n  --dns-name-label agentflow-api\n</code></pre>"},{"location":"cli/deployment/#heroku","title":"Heroku","text":"<pre><code># Login to Heroku\nheroku login\n\n# Create app\nheroku create agentflow-api\n\n# Set environment variables\nheroku config:set GEMINI_API_KEY=your_key\nheroku config:set JWT_SECRET_KEY=your_secret\n\n# Deploy\ngit push heroku main\n\n# Scale\nheroku ps:scale web=2\n\n# View logs\nheroku logs --tail\n</code></pre>"},{"location":"cli/deployment/#production-checklist","title":"Production Checklist","text":""},{"location":"cli/deployment/#before-deployment","title":"Before Deployment","text":"<ul> <li> Environment Variables: All required env vars set</li> <li> Secrets Management: API keys stored securely</li> <li> Database: Migrations run and tested</li> <li> Dependencies: All packages pinned in requirements.txt</li> <li> Config Files: Production config reviewed</li> <li> Tests: All tests passing</li> <li> Security Scan: Docker image scanned for vulnerabilities</li> <li> Performance: Load tested</li> <li> Logging: Log levels configured correctly</li> <li> Monitoring: Health checks and metrics configured</li> </ul>"},{"location":"cli/deployment/#security","title":"Security","text":"<pre><code># 1. Use secrets management\n# AWS Secrets Manager, Google Secret Manager, Azure Key Vault\n\n# 2. Never commit secrets\necho \".env\" &gt;&gt; .gitignore\necho \"secrets.yaml\" &gt;&gt; .gitignore\n\n# 3. Use SSL/TLS\n# Configure HTTPS with Let's Encrypt or cloud provider certs\n\n# 4. Enable CORS properly\n# Review ALLOWED_HOST and ORIGINS in settings\n\n# 5. Run as non-root user\n# Already configured in generated Dockerfile\n\n# 6. Keep dependencies updated\npip install --upgrade 10xscale-agentflow-cli\n\n# 7. Enable rate limiting\n# Use nginx, Traefik, or API Gateway\n</code></pre>"},{"location":"cli/deployment/#performance","title":"Performance","text":"<pre><code># 1. Use multiple workers\n# Configured in Dockerfile with Gunicorn\n\n# 2. Enable caching\n# Configure Redis for session/response caching\n\n# 3. Use CDN for static assets\n# CloudFront, Cloudflare, etc.\n\n# 4. Database connection pooling\n# Configure in database settings\n\n# 5. Optimize Docker image\n# Multi-stage builds (already in generated Dockerfile)\n</code></pre>"},{"location":"cli/deployment/#monitoring-logging","title":"Monitoring &amp; Logging","text":""},{"location":"cli/deployment/#application-logs","title":"Application Logs","text":"<p>With Docker: <pre><code># View logs\ndocker logs agentflow-api\n\n# Follow logs\ndocker logs -f agentflow-api\n\n# Last 100 lines\ndocker logs --tail 100 agentflow-api\n\n# Since timestamp\ndocker logs --since 2024-01-01T00:00:00 agentflow-api\n</code></pre></p> <p>With Docker Compose: <pre><code>docker compose logs -f api\n</code></pre></p> <p>With Kubernetes: <pre><code>kubectl logs -f deployment/agentflow-api\nkubectl logs -f -l app=agentflow-api\n</code></pre></p>"},{"location":"cli/deployment/#sentry-integration","title":"Sentry Integration","text":"<p>Add Sentry to your project:</p> <pre><code>pip install \"10xscale-agentflow-cli[sentry]\"\n</code></pre> <p>Configure in <code>.env</code>: <pre><code>SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id\n</code></pre></p> <p>Update <code>agentflow.json</code>: <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"sentry\": {\n    \"dsn\": \"${SENTRY_DSN}\",\n    \"environment\": \"production\",\n    \"traces_sample_rate\": 0.1\n  }\n}\n</code></pre></p>"},{"location":"cli/deployment/#health-checks","title":"Health Checks","text":"<p>The generated Dockerfile includes a health check:</p> <pre><code>HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/ping || exit 1\n</code></pre> <p>Test health check: <pre><code>curl http://localhost:8000/ping\n# Expected: {\"status\": \"ok\"}\n</code></pre></p>"},{"location":"cli/deployment/#metrics","title":"Metrics","text":"<p>Integrate with Prometheus:</p> <pre><code># prometheus.yml\nscrape_configs:\n  - job_name: 'agentflow-api'\n    static_configs:\n      - targets: ['agentflow-api:8000']\n    metrics_path: '/metrics'\n</code></pre>"},{"location":"cli/deployment/#scaling","title":"Scaling","text":""},{"location":"cli/deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Docker Compose: <pre><code>docker compose up -d --scale api=5\n</code></pre></p> <p>Kubernetes: <pre><code># Manual scaling\nkubectl scale deployment agentflow-api --replicas=5\n\n# Auto-scaling\nkubectl autoscale deployment agentflow-api \\\n  --min=2 --max=10 --cpu-percent=80\n</code></pre></p>"},{"location":"cli/deployment/#load-balancing","title":"Load Balancing","text":"<p>Nginx: <pre><code>upstream agentflow_backend {\n    least_conn;\n    server api1:8000;\n    server api2:8000;\n    server api3:8000;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n\n    location / {\n        proxy_pass http://agentflow_backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre></p>"},{"location":"cli/deployment/#database-scaling","title":"Database Scaling","text":"<p>For PostgreSQL with connection pooling:</p> <pre><code># settings.py\nDATABASE_URL = \"postgresql://user:pass@host:5432/db\"\nDATABASE_POOL_SIZE = 20\nDATABASE_MAX_OVERFLOW = 10\n</code></pre>"},{"location":"cli/deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/deployment/#container-wont-start","title":"Container won't start","text":"<pre><code># Check logs\ndocker logs agentflow-api\n\n# Check if port is available\nlsof -i :8000\n\n# Inspect container\ndocker inspect agentflow-api\n\n# Run interactively for debugging\ndocker run -it --entrypoint /bin/sh agentflow-api:latest\n</code></pre>"},{"location":"cli/deployment/#high-memory-usage","title":"High memory usage","text":"<pre><code># Check container stats\ndocker stats agentflow-api\n\n# Set memory limits\ndocker run -m 2g agentflow-api:latest\n\n# In docker-compose.yml\ndeploy:\n  resources:\n    limits:\n      memory: 2G\n</code></pre>"},{"location":"cli/deployment/#connection-refused","title":"Connection refused","text":"<pre><code># Check if service is running\ndocker ps\n\n# Check port mapping\ndocker port agentflow-api\n\n# Test from inside container\ndocker exec agentflow-api curl http://localhost:8000/ping\n</code></pre>"},{"location":"cli/deployment/#additional-resources","title":"Additional Resources","text":"<ul> <li>Docker Documentation</li> <li>Kubernetes Documentation</li> <li>AWS ECS Documentation</li> <li>Google Cloud Run Documentation</li> <li>Configuration Guide</li> <li>Authentication Guide</li> </ul>"},{"location":"cli/id-generation/","title":"ID Generation Guide","text":"<p>This guide covers using the Snowflake ID generator for generating unique, distributed, and time-sortable IDs in your AgentFlow application.</p>"},{"location":"cli/id-generation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>What is Snowflake ID?</li> <li>Installation</li> <li>Basic Usage</li> <li>Configuration</li> <li>Best Practices</li> </ul>"},{"location":"cli/id-generation/#overview","title":"Overview","text":"<p>AgentFlow includes a Snowflake ID generator based on Twitter's Snowflake algorithm for generating unique, distributed, time-sortable 64-bit IDs.</p>"},{"location":"cli/id-generation/#key-features","title":"Key Features","text":"<ul> <li>\u2705 Unique: Guaranteed unique across distributed systems</li> <li>\u2705 Time-sortable: IDs are roughly chronological</li> <li>\u2705 High performance: Can generate thousands of IDs per second</li> <li>\u2705 Distributed: Works across multiple nodes and workers</li> <li>\u2705 64-bit integers: Efficient storage and indexing</li> <li>\u2705 Configurable: Adjust bit allocation for your needs</li> </ul>"},{"location":"cli/id-generation/#what-is-snowflake-id","title":"What is Snowflake ID?","text":"<p>A Snowflake ID is a 64-bit integer composed of:</p> <pre><code>|-------|-----------|--------|--------|----------|\n|  Sign |   Time    |  Node  | Worker | Sequence |\n|   1   |    39     |   5    |   8    |    11    |\n|-------|-----------|--------|--------|----------|\n</code></pre>"},{"location":"cli/id-generation/#default-bit-allocation","title":"Default Bit Allocation","text":"Component Bits Range Description Sign 1 0 Always 0 (positive) Time 39 0 - 17.4 years Milliseconds since epoch Node 5 0 - 31 Node/datacenter ID Worker 8 0 - 255 Worker/process ID Sequence 11 0 - 4095 Per-millisecond counter"},{"location":"cli/id-generation/#example-id","title":"Example ID","text":"<pre><code>ID: 1234567890123456789\n\nBreakdown:\n- Time: 1609459200000 (Jan 1, 2021 00:00:00 UTC + offset)\n- Node ID: 5\n- Worker ID: 3\n- Sequence: 42\n</code></pre>"},{"location":"cli/id-generation/#advantages","title":"Advantages","text":"<ol> <li>Distributed Generation: No coordination needed between nodes</li> <li>Time Ordering: IDs generated later have higher values</li> <li>Database Friendly: 64-bit integers are efficiently indexed</li> <li>High Throughput: Up to 4096 IDs per millisecond per worker</li> <li>No Lookups: No need to query a database or service</li> </ol>"},{"location":"cli/id-generation/#installation","title":"Installation","text":""},{"location":"cli/id-generation/#required-package","title":"Required Package","text":"<pre><code>pip install snowflakekit\n</code></pre> <p>Or install with agentflow-cli:</p> <pre><code>pip install \"10xscale-agentflow-cli[snowflakekit]\"\n</code></pre>"},{"location":"cli/id-generation/#verify-installation","title":"Verify Installation","text":"<pre><code>from agentflow_cli import SnowFlakeIdGenerator\n\n# This will raise ImportError if snowflakekit is not installed\ngenerator = SnowFlakeIdGenerator()\n</code></pre>"},{"location":"cli/id-generation/#basic-usage","title":"Basic Usage","text":""},{"location":"cli/id-generation/#import","title":"Import","text":"<pre><code>from agentflow_cli import SnowFlakeIdGenerator\nfrom agentflow.graph import StateGraph\n</code></pre>"},{"location":"cli/id-generation/#create-generator-and-use-with-stategraph","title":"Create Generator and Use with StateGraph","text":"<pre><code># Create generator (reads configuration from environment variables)\nid_generator = SnowFlakeIdGenerator()\n\n# Use with StateGraph\ngraph = StateGraph[MyAgentState](MyAgentState(), id_generator=id_generator)\n</code></pre> <p>The generator will automatically read configuration from environment variables (recommended for production).</p>"},{"location":"cli/id-generation/#configuration","title":"Configuration","text":""},{"location":"cli/id-generation/#environment-variables","title":"Environment Variables","text":"<p>Set these in your <code>.env</code> file:</p> <pre><code># Required\nSNOWFLAKE_EPOCH=1609459200000  # Milliseconds since Unix epoch\n\n# Node and Worker IDs (required)\nSNOWFLAKE_NODE_ID=1            # 0-31 (with 5 bits)\nSNOWFLAKE_WORKER_ID=1          # 0-255 (with 8 bits)\n\n# Optional (defaults shown)\nSNOWFLAKE_TOTAL_BITS=64\nSNOWFLAKE_TIME_BITS=39\nSNOWFLAKE_NODE_BITS=5\nSNOWFLAKE_WORKER_BITS=8\n</code></pre>"},{"location":"cli/id-generation/#choosing-an-epoch","title":"Choosing an Epoch","text":"<p>The epoch is the starting point for time measurement. Choose a date close to your service launch:</p> <pre><code>from datetime import datetime\n\n# Calculate epoch in milliseconds\nepoch_date = datetime(2024, 1, 1, 0, 0, 0)\nepoch_ms = int(epoch_date.timestamp() * 1000)\nprint(f\"SNOWFLAKE_EPOCH={epoch_ms}\")\n\n# Output: SNOWFLAKE_EPOCH=1704067200000\n</code></pre> <p>Why choose a custom epoch? - Extends the time range (default 39 bits = ~17.4 years from epoch) - If epoch = Jan 1, 2024, you can generate IDs until ~2041</p>"},{"location":"cli/id-generation/#node-and-worker-ids","title":"Node and Worker IDs","text":"<p>Assign unique IDs across your infrastructure:</p> <pre><code># Production setup\n# Server 1\nSNOWFLAKE_NODE_ID=1\nSNOWFLAKE_WORKER_ID=1\n\n# Server 2\nSNOWFLAKE_NODE_ID=1\nSNOWFLAKE_WORKER_ID=2\n\n# Server 3 (different datacenter)\nSNOWFLAKE_NODE_ID=2\nSNOWFLAKE_WORKER_ID=1\n</code></pre>"},{"location":"cli/id-generation/#bit-allocation","title":"Bit Allocation","text":"<p>Customize bit allocation for your use case:</p> <p>Default (total 64 bits): <pre><code>SNOWFLAKE_TIME_BITS=39     # ~17 years\nSNOWFLAKE_NODE_BITS=5      # 32 nodes\nSNOWFLAKE_WORKER_BITS=8    # 256 workers per node\n# Sequence bits = 64 - 1 - 39 - 5 - 8 = 11 bits = 4096 IDs/ms\n</code></pre></p> <p>High concurrency (fewer nodes, more throughput): <pre><code>SNOWFLAKE_TIME_BITS=39     # ~17 years\nSNOWFLAKE_NODE_BITS=3      # 8 nodes\nSNOWFLAKE_WORKER_BITS=6    # 64 workers per node\n# Sequence bits = 15 bits = 32768 IDs/ms\n</code></pre></p> <p>Many nodes (distributed): <pre><code>SNOWFLAKE_TIME_BITS=39     # ~17 years\nSNOWFLAKE_NODE_BITS=8      # 256 nodes\nSNOWFLAKE_WORKER_BITS=5    # 32 workers per node\n# Sequence bits = 11 bits = 4096 IDs/ms\n</code></pre></p> <p>Long time range: <pre><code>SNOWFLAKE_TIME_BITS=41     # ~69 years\nSNOWFLAKE_NODE_BITS=4      # 16 nodes\nSNOWFLAKE_WORKER_BITS=7    # 128 workers per node\n# Sequence bits = 11 bits = 4096 IDs/ms\n</code></pre></p>"},{"location":"cli/id-generation/#validation","title":"Validation","text":"<p>Bit allocation must follow these rules:</p> <ol> <li>Total must equal 64: <code>1 + time + node + worker + sequence = 64</code></li> <li>All components must be positive</li> <li>Node ID must be &lt; 2^node_bits</li> <li>Worker ID must be &lt; 2^worker_bits</li> </ol>"},{"location":"cli/id-generation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/id-generation/#importerror-no-module-named-snowflakekit","title":"ImportError: No module named 'snowflakekit'","text":"<p>Solution: <pre><code>pip install snowflakekit\n</code></pre></p>"},{"location":"cli/id-generation/#valueerror-all-configuration-parameters-must-be-provided","title":"ValueError: All configuration parameters must be provided","text":"<p>Solution: Set all required environment variables:</p> <pre><code># .env\nSNOWFLAKE_EPOCH=1704067200000\nSNOWFLAKE_NODE_ID=1\nSNOWFLAKE_WORKER_ID=1\n</code></pre>"},{"location":"cli/id-generation/#duplicate-ids-generated","title":"Duplicate IDs Generated","text":"<p>Possible causes: 1. Same NODE_ID and WORKER_ID on multiple servers 2. System clock went backwards 3. Generating IDs faster than supported (&gt;4096/ms)</p> <p>Solutions: - Ensure unique NODE_ID/WORKER_ID combinations per server instance - Use NTP to keep clocks synchronized - Increase sequence bits if higher throughput is needed</p>"},{"location":"cli/id-generation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Twitter Snowflake - Original Snowflake algorithm</li> <li>Configuration Guide - Complete configuration reference</li> <li>Deployment Guide - Production deployment strategies</li> </ul>"},{"location":"cli/thread-name-generator/","title":"Thread Name Generator Guide","text":"<p>This guide covers creating custom thread name generators for your AgentFlow application. This allows you to generate meaningful names for AI conversation threads based on the content of the conversations. It will be generated only when a new thread is created. </p> <p>Logic For New Thread</p> <p>If thread id not provided with the api call, a new thread id will be created and it will use the response and generate the thread name using the configured ThreadNameGenerator class.</p>"},{"location":"cli/thread-name-generator/#overview","title":"Overview","text":"<p>Thread name generators create meaningful names for AI conversation threads. You can implement custom logic to generate names based on conversation content.</p>"},{"location":"cli/thread-name-generator/#threadnamegenerator-interface","title":"ThreadNameGenerator Interface","text":""},{"location":"cli/thread-name-generator/#import","title":"Import","text":"<pre><code>from agentflow_cli import ThreadNameGenerator\n</code></pre>"},{"location":"cli/thread-name-generator/#interface-definition","title":"Interface Definition","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass ThreadNameGenerator(ABC):\n    @abstractmethod\n    async def generate_name(self, messages: list[str]) -&gt; str:\n        \"\"\"Generate a thread name from conversation messages.\n\n        Args:\n            messages: List of message content strings\n\n        Returns:\n            str: A meaningful thread name\n        \"\"\"\n        pass\n</code></pre>"},{"location":"cli/thread-name-generator/#basic-implementation","title":"Basic Implementation","text":""},{"location":"cli/thread-name-generator/#simple-static-name","title":"Simple Static Name","text":"<pre><code>from agentflow_cli import ThreadNameGenerator\n\nclass MyNameGenerator(ThreadNameGenerator):\n    async def generate_name(self, messages: list[str]) -&gt; str:\n        return \"MyCustomThreadName\"\n</code></pre>"},{"location":"cli/thread-name-generator/#ai-powered-name-generation","title":"AI-Powered Name Generation","text":"<pre><code>from agentflow_cli import ThreadNameGenerator\nfrom litellm import acompletion\n\nclass MyNameGenerator(ThreadNameGenerator):\n    async def generate_name(self, messages: list[str]) -&gt; str:\n        \"\"\"Generate thread name using AI.\"\"\"\n        if not messages:\n            return \"new-conversation\"\n\n        # Call AI to generate a meaningful name\n        response = await acompletion(\n            model=\"gemini/gemini-2.0-flash-exp\",\n            messages=[{\n                \"role\": \"user\",\n                \"content\": f\"\"\"Please generate a short thread name (2-3 words, hyphen-separated) \nfor this conversation:\n{chr(10).join(messages)}\nReply only with the thread name, nothing else.\"\"\"\n            }],\n            max_tokens=20\n        )\n\n        return response.choices[0].message.content.strip()\n</code></pre>"},{"location":"cli/thread-name-generator/#configuration-in-agentflowjson","title":"Configuration in agentflow.json","text":"<p>Register your generator in the agentflow.json configuration:</p> <pre><code>{\n  \"agent\": \"graph.react:app\",\n  \"thread_name_generator\": \"graph.thread_name_generator:MyNameGenerator\",\n  \"env\": \".env\",\n  \"auth\": null\n}\n</code></pre> <p>The path format is: <code>\"module.path:ClassName\"</code></p>"},{"location":"cli/thread-name-generator/#example-directory-structure","title":"Example Directory Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 graph/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 react.py\n\u2502   \u2514\u2500\u2500 thread_name_generator.py\n\u251c\u2500\u2500 agentflow.json\n\u2514\u2500\u2500 .env\n</code></pre>"},{"location":"cli/thread-name-generator/#example-implementation-file","title":"Example Implementation File","text":"<p>graph/thread_name_generator.py: <pre><code>from agentflow_cli import ThreadNameGenerator\nfrom litellm import acompletion\n\nclass MyNameGenerator(ThreadNameGenerator):\n    async def generate_name(self, messages: list[str]) -&gt; str:\n        \"\"\"Generate thread names using AI.\"\"\"\n        if not messages:\n            return \"new-conversation\"\n\n        response = await acompletion(\n            model=\"gemini/gemini-2.0-flash-exp\",\n            messages=[{\n                \"role\": \"user\",\n                \"content\": f\"\"\"Generate a thread name for: {chr(10).join(messages[:2])}\"\"\"\n            }],\n            max_tokens=20\n        )\n\n        return response.choices[0].message.content.strip()\n</code></pre></p>"},{"location":"cli/thread-name-generator/#best-practices","title":"Best Practices","text":"<ol> <li>Handle empty messages - Return a default name when no messages are provided</li> <li>Include error handling - Add try-except blocks for external API calls</li> <li>Keep names reasonable - Use 2-4 words, hyphen-separated for consistency</li> <li>Be asynchronous - Use <code>async</code> functions to avoid blocking</li> <li>Return strings - Always return a valid string from <code>generate_name()</code></li> </ol>"},{"location":"cli/thread-name-generator/#additional-resources","title":"Additional Resources","text":"<ul> <li>Configuration Guide - Complete configuration reference</li> </ul>"},{"location":"client/","title":"AgentFlow Client - Documentation","text":"<p>Welcome to the AgentFlow Client documentation! This guide will help you integrate the AgentFlow multi-agent API into your applications.</p>"},{"location":"client/#quick-links","title":"\ud83d\ude80 Quick Links","text":"Document Description Getting Started Complete setup guide (15 min) API Reference All methods and types React Integration \u2b50 Hooks, patterns, best practices React Examples \u2b50 Complete component examples Tools Guide Tool registration and execution Troubleshooting Common issues and solutions"},{"location":"client/#what-is-agentflow-react","title":"\ud83d\udcd6 What is AgentFlow React?","text":"<p>AgentFlow React is a TypeScript client library that connects your React applications to the AgentFlow multi-agent system. It provides:</p> <ul> <li>\u2705 Simple API Client - Clean interface to AgentFlow backend</li> <li>\u2705 Streaming Support - Real-time responses for chat interfaces</li> <li>\u2705 Tool Execution - Automatic local tool handling</li> <li>\u2705 State Management - Dynamic schema-based state handling</li> <li>\u2705 React-Ready - Built specifically for React applications</li> <li>\u2705 TypeScript - Full type safety and IntelliSense support</li> </ul>"},{"location":"client/#critical-remote-tools-vs-backend-tools","title":"\ud83d\udea8 CRITICAL: Remote Tools vs Backend Tools","text":"<p>Before you start: Understanding tool types is essential for proper AgentFlow usage.</p>"},{"location":"client/#remote-tools-client-side-limited-use","title":"\ud83d\udd34 Remote Tools (Client-Side - LIMITED USE)","text":"<ul> <li>WHEN TO USE: Only for browser-level APIs</li> <li><code>navigator.geolocation</code> (GPS/location)</li> <li><code>localStorage</code>/<code>sessionStorage</code> (client-side storage)</li> <li>DOM manipulation and access</li> <li>WebRTC, camera/microphone access</li> <li>File uploads from user's device</li> <li>WHEN NOT TO USE: Database queries, external APIs, calculations, file operations</li> <li>WHY LIMITED: Runs in browser, less secure, no server access</li> </ul>"},{"location":"client/#backend-tools-server-side-preferred","title":"\u2705 Backend Tools (Server-Side - PREFERRED)","text":"<ul> <li>WHEN TO USE: For most operations</li> <li>Database queries and operations</li> <li>External API calls (weather, payments, etc.)</li> <li>Mathematical calculations</li> <li>File system operations</li> <li>Business logic and data processing</li> <li>WHY PREFERRED: More secure, efficient, scalable, full server access</li> </ul> <p>\ud83d\udca1 Rule of Thumb: If your tool needs server-side resources or external APIs, define it as a backend tool in your Python AgentFlow library instead of using remote tools.</p>"},{"location":"client/#learning-path","title":"\ud83c\udf93 Learning Path","text":""},{"location":"client/#beginner-start-here","title":"\ud83d\udc76 Beginner (Start Here)","text":"<ol> <li>Getting Started - Install and make your first API call</li> <li>API Reference - Learn core methods: <code>ping()</code>, <code>invoke()</code>, <code>stream()</code></li> <li>React Examples - See simple chat component example</li> </ol>"},{"location":"client/#intermediate","title":"\ud83e\uddd1\u200d\ud83d\udcbb Intermediate","text":"<ol> <li>Invoke API Guide - Deep dive into request/response pattern</li> <li>Stream API Guide - Learn real-time streaming</li> <li>Tools Guide - Register and execute custom tools</li> <li>React Integration - Custom hooks and patterns</li> </ol>"},{"location":"client/#advanced","title":"\ud83d\ude80 Advanced","text":"<ol> <li>State Schema Guide - Dynamic forms and validation</li> <li>TypeScript Types - Advanced type usage</li> <li>React Examples - Complex workflows and multi-step UIs</li> </ol>"},{"location":"client/#core-documentation","title":"\ud83d\udcda Core Documentation","text":""},{"location":"client/#essential-guides","title":"Essential Guides","text":""},{"location":"client/#getting-started","title":"Getting Started","text":"<p>Complete setup guide to get you up and running in 15 minutes. Covers: - Installation - Basic configuration - First API call - Simple examples</p>"},{"location":"client/#api-reference","title":"API Reference","text":"<p>Comprehensive reference for all client methods: - <code>AgentFlowClient</code> configuration - <code>invoke()</code> - Batch processing with tools - <code>stream()</code> - Real-time streaming - <code>graphStateSchema()</code> - Get state schema - <code>threadState()</code>, <code>updateThreadState()</code>, <code>clearThreadState()</code> - Tool registration API - Message helpers</p>"},{"location":"client/#react-integration","title":"React Integration \u2b50","text":"<p>Essential for React developers! Learn how to: - Set up AgentFlowClient in React - Use context providers - Create custom hooks (<code>useInvoke</code>, <code>useStream</code>, <code>useStateSchema</code>) - Manage loading and error states - Best practices for React apps</p>"},{"location":"client/#react-examples","title":"React Examples \u2b50","text":"<p>Complete working examples including: - Simple chat component - Streaming chat with real-time updates - Dynamic form builder from schema - Agent with custom tools - Multi-step workflows - Thread management UI</p>"},{"location":"client/#api-deep-dives","title":"API Deep Dives","text":""},{"location":"client/#invoke-api-comprehensive-guide","title":"Invoke API - Comprehensive Guide","text":"<p>Detailed documentation for the <code>invoke()</code> method: - Request/response patterns - Tool execution loop - Recursion handling - Response granularity - Error handling - Complete examples</p> <p>Quick Reference: Invoke Quick Start</p>"},{"location":"client/#stream-api-comprehensive-guide","title":"Stream API - Comprehensive Guide","text":"<p>Everything about real-time streaming: - Streaming architecture - Event types and handling - React integration patterns - Memory efficiency - Error handling - Performance tips</p> <p>Quick Reference: Stream Quick Reference</p>"},{"location":"client/#state-schema-api-guide","title":"State Schema API - Guide","text":"<p>Working with dynamic agent state: - Schema structure - Building dynamic forms - Data validation - Type generation - Dynamic fields</p> <p>Quick Reference: State Schema Quick Reference</p>"},{"location":"client/#advanced-topics","title":"Advanced Topics","text":""},{"location":"client/#tools-guide","title":"Tools Guide","text":"<p>Master tool registration and execution: - What are tools? - \ud83d\udd34 REMOTE TOOLS vs BACKEND TOOLS \u26a0\ufe0f CRITICAL DISTINCTION - Tool registration patterns - Handler implementation - OpenAI-style parameters - Error handling - Testing tools - Common patterns (weather, calculator, API calls)</p> <p>\ud83d\udea8 REMOTE TOOLS (Client-Side): - \u2705 USE ONLY FOR: Browser APIs (<code>localStorage</code>, <code>navigator.geolocation</code>, DOM manipulation, WebRTC) - \u274c DO NOT USE FOR: Database queries, external API calls, calculations, file operations - INSTEAD: Define these as backend tools in your Python AgentFlow library</p> <p>\u2705 BACKEND TOOLS (Server-Side - PREFERRED): - Database operations, API calls, calculations, file system access - More secure, efficient, and scalable - Full access to your server infrastructure</p>"},{"location":"client/#typescript-types","title":"TypeScript Types","text":"<p>Advanced TypeScript usage: - Type imports - Core interfaces - Type guards - Custom extensions - Type-safe tool handlers - Schema-based type inference</p>"},{"location":"client/#troubleshooting","title":"Troubleshooting","text":"<p>Solutions to common issues: - Installation problems - Connection errors - Timeout issues - Authentication failures - Stream disconnections - TypeScript errors - React integration issues</p>"},{"location":"client/#find-what-you-need","title":"\ud83d\udd0d Find What You Need","text":""},{"location":"client/#i-want-to","title":"I want to...","text":"<p>...get started quickly \u2192 Getting Started Guide</p> <p>...build a chat interface \u2192 React Examples - Chat Component</p> <p>...use streaming responses \u2192 Stream API Guide or Stream Quick Reference</p> <p>...register custom tools \u2192 Tools Guide \ud83d\udea8 REMOTE TOOLS: Only for browser APIs (geolocation, localStorage, DOM) \u274c BACKEND TOOLS: Preferred for everything else (APIs, databases, calculations)</p> <p>...build dynamic forms \u2192 State Schema Guide or React Examples - Form Builder</p> <p>...integrate with React \u2192 React Integration Guide</p> <p>...understand all available methods \u2192 API Reference</p> <p>...solve an issue \u2192 Troubleshooting Guide</p> <p>...see complete examples \u2192 React Examples or /examples folder</p>"},{"location":"client/#installation","title":"\ufffd Installation","text":"<pre><code>npm install agentflow-react\n</code></pre>"},{"location":"client/#30-second-example","title":"\ud83d\ude80 30-Second Example","text":"<pre><code>import { AgentFlowClient, Message } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'http://localhost:8000'\n});\n\nconst result = await client.invoke([\n  Message.text_message('Hello!', 'user')\n]);\n\nconsole.log(result.messages);\n</code></pre>"},{"location":"client/api-reference/","title":"AgentFlow API Reference","text":"<p>Complete API reference for all endpoints in the agentflow-react library.</p>"},{"location":"client/api-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Client Configuration</li> <li>Health &amp; Metadata</li> <li>ping()</li> <li>graph()</li> <li>stateSchema()</li> <li>Thread Management</li> <li>threads()</li> <li>threadDetails()</li> <li>threadState()</li> <li>updateThreadState()</li> <li>clearThreadState()</li> <li>deleteThread()</li> <li>Message Management</li> <li>threadMessages()</li> <li>threadMessage()</li> <li>addThreadMessages()</li> <li>deleteThreadMessage()</li> <li>Execution</li> <li>invoke()</li> <li>stream()</li> <li>Memory Management</li> <li>storeMemory()</li> <li>searchMemory()</li> <li>getMemory()</li> <li>updateMemory()</li> <li>deleteMemory()</li> <li>listMemories()</li> <li>forgetMemories()</li> </ul>"},{"location":"client/api-reference/#client-configuration","title":"Client Configuration","text":""},{"location":"client/api-reference/#agentflowclient","title":"AgentFlowClient","text":"<p>Initialize the AgentFlow client with configuration.</p> <pre><code>import { AgentFlowClient } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: string,      // Required: API base URL\n  authToken?: string,   // Optional: Authentication token\n  timeout?: number,     // Optional: Request timeout in ms (default: 300000 = 5min)\n  debug?: boolean       // Optional: Enable debug logging (default: false)\n});\n</code></pre> <p>Parameters:</p> Parameter Type Required Default Description baseUrl string Yes - Base URL of the AgentFlow API authToken string No null Bearer token for authentication timeout number No 300000 Request timeout in milliseconds debug boolean No false Enable debug logging to console <p>Example:</p> <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.agentflow.example.com',\n  authToken: 'your-secret-token',\n  timeout: 60000,  // 1 minute\n  debug: true\n});\n</code></pre>"},{"location":"client/api-reference/#health-metadata","title":"Health &amp; Metadata","text":""},{"location":"client/api-reference/#ping","title":"ping()","text":"<p>Health check endpoint to verify API connectivity.</p> <p>Endpoint: <code>GET /v1/ping</code></p> <p>Signature: <pre><code>ping(): Promise&lt;PingResponse&gt;\n</code></pre></p> <p>Returns: <pre><code>interface PingResponse {\n  data: string;  // \"pong\"\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.ping();\nconsole.log(response.data);  // \"pong\"\nconsole.log(response.metadata.request_id);\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid or missing auth token - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#graph","title":"graph()","text":"<p>Get the graph structure and metadata for the agent workflow.</p> <p>Endpoint: <code>GET /v1/graph</code></p> <p>Signature: <pre><code>graph(): Promise&lt;GraphResponse&gt;\n</code></pre></p> <p>Returns: <pre><code>interface GraphResponse {\n  data: {\n    graph: any;  // Graph structure definition\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.graph();\nconsole.log(response.data.graph);\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Graph not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#stateschema","title":"stateSchema()","text":"<p>Retrieve the state schema definition with field types and descriptions.</p> <p>Endpoint: <code>GET /v1/graph/state/schema</code></p> <p>Signature: <pre><code>stateSchema(): Promise&lt;StateSchemaResponse&gt;\n</code></pre></p> <p>Returns: <pre><code>interface StateSchemaResponse {\n  data: {\n    fields: {\n      [fieldName: string]: FieldSchema;\n    };\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface FieldSchema {\n  type: string;           // Field type: \"string\", \"number\", \"boolean\", etc.\n  description?: string;   // Human-readable description\n  default?: any;          // Default value\n  required?: boolean;     // Whether field is required\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.stateSchema();\nconst fields = response.data.fields;\n\n// Display all fields\nfor (const [name, schema] of Object.entries(fields)) {\n  console.log(`${name}: ${schema.type} - ${schema.description}`);\n}\n</code></pre></p> <p>Use Cases: - Build dynamic forms - Validate state data - Generate documentation - Create TypeScript types</p> <p>See Also: - State Schema Guide - State Schema Examples</p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#thread-management","title":"Thread Management","text":""},{"location":"client/api-reference/#threads","title":"threads()","text":"<p>List all threads with optional search and pagination.</p> <p>Endpoint: <code>GET /v1/threads</code></p> <p>Signature: <pre><code>threads(options?: ThreadsRequest): Promise&lt;ThreadsResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ThreadsRequest {\n  search?: string;   // Search query to filter threads\n  offset?: number;   // Pagination offset (default: 0)\n  limit?: number;    // Number of results (default: 20)\n}\n</code></pre></p> <p>Returns: <pre><code>interface ThreadsResponse {\n  data: {\n    threads: ThreadItem[];\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface ThreadItem {\n  thread_id: string;\n  thread_name: string | null;\n  user_id: string | null;\n  metadata: Record&lt;string, any&gt; | null;\n  updated_at: string | null;\n  run_id: string | null;\n}\n</code></pre></p> <p>Example: <pre><code>// Get all threads\nconst response = await client.threads();\n\n// Search and paginate\nconst filtered = await client.threads({\n  search: 'customer support',\n  offset: 0,\n  limit: 10\n});\n\nfor (const thread of filtered.data.threads) {\n  console.log(`${thread.thread_id}: ${thread.thread_name}`);\n}\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>ValidationError</code> (422) - Invalid pagination parameters - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#threaddetails","title":"threadDetails()","text":"<p>Get detailed information about a specific thread.</p> <p>Endpoint: <code>GET /v1/threads/{thread_id}</code></p> <p>Signature: <pre><code>threadDetails(threadId: string): Promise&lt;ThreadDetailsResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ThreadDetailsResponse {\n  data: {\n    thread_id: string;\n    thread_name: string | null;\n    user_id: string | null;\n    metadata: Record&lt;string, any&gt; | null;\n    created_at: string | null;\n    updated_at: string | null;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const details = await client.threadDetails('thread_123');\nconsole.log(details.data.thread_name);\nconsole.log(details.data.created_at);\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#threadstate","title":"threadState()","text":"<p>Get the current state of a thread.</p> <p>Endpoint: <code>GET /v1/threads/{thread_id}/state</code></p> <p>Signature: <pre><code>threadState(threadId: string): Promise&lt;ThreadStateResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const state = await client.threadState('thread_123');\nconsole.log(state.data.state);\n\n// Access specific state fields\nconst userPreferences = state.data.state.preferences;\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#updatethreadstate","title":"updateThreadState()","text":"<p>Update the state of a thread.</p> <p>Endpoint: <code>POST /v1/threads/{thread_id}/state</code></p> <p>Signature: <pre><code>updateThreadState(\n  threadId: string,\n  request: UpdateThreadStateRequest\n): Promise&lt;UpdateThreadStateResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface UpdateThreadStateRequest {\n  config?: Record&lt;string, any&gt;;  // Optional configuration\n  state: Record&lt;string, any&gt;;    // State values to update\n}\n</code></pre></p> <p>Returns: <pre><code>interface UpdateThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.updateThreadState('thread_123', {\n  state: {\n    step: 'completed',\n    progress: 100,\n    result: { success: true }\n  },\n  config: {\n    validate: true\n  }\n});\n\nconsole.log(response.data.state);\n</code></pre></p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid state data - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ValidationError</code> (422) - State validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#clearthreadstate","title":"clearThreadState()","text":"<p>Clear all state data from a thread.</p> <p>Endpoint: <code>DELETE /v1/threads/{thread_id}/state</code></p> <p>Signature: <pre><code>clearThreadState(threadId: string): Promise&lt;ClearThreadStateResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ClearThreadStateResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.clearThreadState('thread_123');\nconsole.log(response.data.success);  // true\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#deletethread","title":"deleteThread()","text":"<p>Permanently delete a thread and all its associated data.</p> <p>Endpoint: <code>DELETE /v1/threads/{thread_id}</code></p> <p>Signature: <pre><code>deleteThread(\n  threadId: string,\n  request?: DeleteThreadRequest\n): Promise&lt;DeleteThreadResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface DeleteThreadRequest {\n  config?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface DeleteThreadResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.deleteThread('thread_123');\nconsole.log(response.data.success);  // true\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>PermissionError</code> (403) - No permission to delete thread - <code>NotFoundError</code> (404) - Thread not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#message-management","title":"Message Management","text":""},{"location":"client/api-reference/#threadmessages","title":"threadMessages()","text":"<p>Get all messages from a thread with pagination.</p> <p>Endpoint: <code>GET /v1/threads/{thread_id}/messages</code></p> <p>Signature: <pre><code>threadMessages(\n  threadId: string,\n  options?: ThreadMessagesRequest\n): Promise&lt;ThreadMessagesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ThreadMessagesRequest {\n  offset?: number;  // Pagination offset (default: 0)\n  limit?: number;   // Number of results (default: 20)\n}\n</code></pre></p> <p>Returns: <pre><code>interface ThreadMessagesResponse {\n  data: {\n    messages: Message[];\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>// Get all messages\nconst response = await client.threadMessages('thread_123');\n\n// Paginate\nconst recent = await client.threadMessages('thread_123', {\n  offset: 0,\n  limit: 10\n});\n\nfor (const message of recent.data.messages) {\n  console.log(message.role, message.content);\n}\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ValidationError</code> (422) - Invalid pagination parameters - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#threadmessage","title":"threadMessage()","text":"<p>Get a specific message from a thread by ID.</p> <p>Endpoint: <code>GET /v1/threads/{thread_id}/messages/{message_id}</code></p> <p>Signature: <pre><code>threadMessage(\n  threadId: string,\n  messageId: string\n): Promise&lt;ThreadMessageResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier messageId string Yes Unique message identifier <p>Returns: <pre><code>interface ThreadMessageResponse {\n  data: {\n    message: Message;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.threadMessage('thread_123', 'msg_456');\nconst message = response.data.message;\nconsole.log(message.role, message.content);\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread or message not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#addthreadmessages","title":"addThreadMessages()","text":"<p>Add new messages to a thread.</p> <p>Endpoint: <code>POST /v1/threads/{thread_id}/messages</code></p> <p>Signature: <pre><code>addThreadMessages(\n  threadId: string,\n  request: AddThreadMessagesRequest\n): Promise&lt;AddThreadMessagesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface AddThreadMessagesRequest {\n  config?: Record&lt;string, any&gt;;\n  messages: Message[];  // Array of messages to add\n}\n</code></pre></p> <p>Returns: <pre><code>interface AddThreadMessagesResponse {\n  data: {\n    messages: Message[];\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { Message } from 'agentflow-react';\n\nconst response = await client.addThreadMessages('thread_123', {\n  messages: [\n    Message.text_message('Hello, I need help', 'user'),\n    Message.text_message('How can I assist you today?', 'assistant')\n  ]\n});\n\nconsole.log(`Added ${response.data.messages.length} messages`);\n</code></pre></p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid message format - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Thread not found - <code>ValidationError</code> (422) - Message validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#deletethreadmessage","title":"deleteThreadMessage()","text":"<p>Delete a specific message from a thread.</p> <p>Endpoint: <code>DELETE /v1/threads/{thread_id}/messages/{message_id}</code></p> <p>Signature: <pre><code>deleteThreadMessage(\n  threadId: string,\n  messageId: string\n): Promise&lt;DeleteThreadMessageResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier messageId string Yes Unique message identifier <p>Returns: <pre><code>interface DeleteThreadMessageResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.deleteThreadMessage('thread_123', 'msg_456');\nconsole.log(response.data.success);  // true\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>PermissionError</code> (403) - No permission to delete message - <code>NotFoundError</code> (404) - Thread or message not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#execution","title":"Execution","text":""},{"location":"client/api-reference/#invoke","title":"invoke()","text":"<p>Execute the agent workflow synchronously with automatic tool execution loop.</p> <p>Endpoint: <code>POST /v1/graph/invoke</code></p> <p>Signature: <pre><code>invoke(request: InvokeRequest): Promise&lt;InvokeResult&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface InvokeRequest {\n  messages: Message[];                    // Input messages\n  config?: Record&lt;string, any&gt;;           // Optional configuration\n  stream?: boolean;                       // Always false for invoke\n  granularity?: 'low' | 'partial' | 'full';  // Response detail level\n  recursion_limit?: number;               // Max tool execution iterations (default: 25)\n  on_progress?: InvokeCallback;           // Progress callback\n}\n\ntype InvokeCallback = (result: InvokePartialResult) =&gt; void;\n</code></pre></p> <p>Returns: <pre><code>interface InvokeResult {\n  messages: Message[];              // Final response messages\n  all_messages: Message[];          // All messages including tool calls\n  state?: Record&lt;string, any&gt;;      // Final state (if granularity &gt;= 'partial')\n  context?: any;                    // Context data (if granularity &gt;= 'partial')\n  summary?: string;                 // Summary (if granularity == 'full')\n  iterations: number;               // Number of iterations performed\n  recursion_limit_reached: boolean; // Whether limit was hit\n  metadata: ResponseMetadata;       // Response metadata\n}\n</code></pre></p> <p>Tool Execution Loop:</p> <p>The invoke endpoint automatically: 1. Sends messages to the API 2. Checks response for <code>remote_tool_call</code> blocks 3. Executes tools locally using registered handlers 4. Sends tool results back to API 5. Repeats until no more tool calls or recursion limit reached</p> <p>Example: <pre><code>import { Message } from 'agentflow-react';\n\n// Register tools first\n// \u26a0\ufe0f IMPORTANT: Only use remote tools for browser-level APIs\n// For most operations, define tools in your Python backend instead\n// See: docs/tools-guide.md#remote-tools-vs-backend-tools\nclient.registerTool({\n  node: 'weather_node',\n  name: 'get_weather',\n  description: 'Get weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: { type: 'string' }\n    },\n    required: ['location']\n  },\n  handler: async (args) =&gt; {\n    return { temp: 72, condition: 'sunny' };\n  }\n});\n\n// Invoke with automatic tool execution\nconst result = await client.invoke({\n  messages: [\n    Message.text_message(\"What's the weather in San Francisco?\", 'user')\n  ],\n  granularity: 'full',\n  recursion_limit: 10,\n  on_progress: (partial) =&gt; {\n    console.log(`Iteration ${partial.iterations}`);\n  }\n});\n\nconsole.log(result.messages);        // Final response\nconsole.log(result.all_messages);    // All messages including tool calls\nconsole.log(result.iterations);      // Number of iterations\n</code></pre></p> <p>Granularity Levels:</p> Level Returns <code>low</code> messages, metadata only <code>partial</code> + state, context <code>full</code> + summary <p>See Also: - Invoke Usage Guide - Invoke Example</p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid request data - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Graph not found - <code>ValidationError</code> (422) - Message validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#stream","title":"stream()","text":"<p>Execute the agent workflow with streaming responses.</p> <p>Endpoint: <code>POST /v1/graph/stream</code> (SSE)</p> <p>Signature: <pre><code>stream(request: StreamRequest): AsyncIterableIterator&lt;StreamChunk&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface StreamRequest {\n  messages: Message[];                    // Input messages\n  config?: Record&lt;string, any&gt;;           // Optional configuration\n  stream?: boolean;                       // Always true for stream\n  granularity?: 'low' | 'partial' | 'full';  // Response detail level\n}\n</code></pre></p> <p>Returns: AsyncIterableIterator yielding: <pre><code>interface StreamChunk {\n  event: StreamEventType;\n  data: any;\n}\n\ntype StreamEventType = \n  | 'metadata'           // Response metadata\n  | 'on_chain_start'     // Chain execution started\n  | 'on_chain_stream'    // Chain streaming data\n  | 'on_chain_end'       // Chain execution ended\n  | 'messages_chunk'     // Message chunk received\n  | 'state_chunk'        // State update chunk\n  | 'context_chunk'      // Context update chunk\n  | 'summary_chunk'      // Summary chunk (full granularity only)\n  | 'error';             // Error occurred\n</code></pre></p> <p>Example: <pre><code>import { Message } from 'agentflow-react';\n\ntry {\n  for await (const chunk of client.stream({\n    messages: [\n      Message.text_message(\"Tell me a story\", 'user')\n    ],\n    granularity: 'full'\n  })) {\n    switch (chunk.event) {\n      case 'metadata':\n        console.log('Request ID:', chunk.data.request_id);\n        break;\n\n      case 'on_chain_start':\n        console.log('Chain started');\n        break;\n\n      case 'messages_chunk':\n        // Incremental message content\n        process.stdout.write(chunk.data);\n        break;\n\n      case 'state_chunk':\n        // State updates\n        console.log('State:', chunk.data);\n        break;\n\n      case 'on_chain_end':\n        console.log('Chain completed');\n        break;\n\n      case 'error':\n        console.error('Error:', chunk.data);\n        break;\n    }\n  }\n} catch (error) {\n  console.error('Stream failed:', error);\n}\n</code></pre></p> <p>Progressive Content:</p> <p>Stream provides progressive updates as the agent processes: - Real-time message generation - State updates during execution - Context changes - Summary generation (full granularity)</p> <p>See Also: - Stream Usage Guide - Stream Example - Stream Quick Reference</p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid request data - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Graph not found - <code>ValidationError</code> (422) - Message validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#memory-management","title":"Memory Management","text":""},{"location":"client/api-reference/#storememory","title":"storeMemory()","text":"<p>Store a new memory in the agent's memory system.</p> <p>Endpoint: <code>POST /v1/store/memories</code></p> <p>Signature: <pre><code>storeMemory(request: StoreMemoryRequest): Promise&lt;StoreMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface StoreMemoryRequest {\n  config?: Record&lt;string, any&gt;;      // Optional configuration\n  options?: Record&lt;string, any&gt;;     // Optional storage options\n  content: string;                   // Memory content\n  memory_type: MemoryType;           // Type of memory\n  category: string;                  // Memory category\n  metadata?: Record&lt;string, any&gt;;    // Additional metadata\n}\n\nenum MemoryType {\n  EPISODIC = \"episodic\",          // Conversation memories\n  SEMANTIC = \"semantic\",           // Facts and knowledge\n  PROCEDURAL = \"procedural\",       // How-to knowledge\n  ENTITY = \"entity\",               // Entity-based memories\n  RELATIONSHIP = \"relationship\",   // Entity relationships\n  CUSTOM = \"custom\",               // Custom memory types\n  DECLARATIVE = \"declarative\"      // Explicit facts and events\n}\n</code></pre></p> <p>Returns: <pre><code>interface StoreMemoryResponse {\n  data: {\n    memory_id: string;  // Unique ID of stored memory\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\nconst response = await client.storeMemory({\n  content: 'User prefers dark mode',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  metadata: {\n    user_id: 'user_123',\n    timestamp: new Date().toISOString()\n  }\n});\n\nconsole.log('Stored memory:', response.data.memory_id);\n</code></pre></p> <p>Memory Types:</p> Type Use Case <code>EPISODIC</code> Conversation history, events <code>SEMANTIC</code> Facts, knowledge, preferences <code>PROCEDURAL</code> How-to information, procedures <code>ENTITY</code> Information about entities <code>RELATIONSHIP</code> Relationships between entities <code>DECLARATIVE</code> Explicit facts and events <code>CUSTOM</code> Custom memory types <p>Throws: - <code>BadRequestError</code> (400) - Invalid memory data - <code>AuthenticationError</code> (401) - Invalid authentication - <code>ValidationError</code> (422) - Memory validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#searchmemory","title":"searchMemory()","text":"<p>Search for memories using vector similarity or other retrieval strategies.</p> <p>Endpoint: <code>POST /v1/store/search</code></p> <p>Signature: <pre><code>searchMemory(request: SearchMemoryRequest): Promise&lt;SearchMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface SearchMemoryRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  query: string;                              // Search query\n  memory_type?: MemoryType;                   // Filter by memory type\n  category?: string;                          // Filter by category\n  limit?: number;                             // Max results (default: 10)\n  score_threshold?: number;                   // Min similarity score (default: 0)\n  filters?: Record&lt;string, any&gt;;              // Additional filters\n  retrieval_strategy?: RetrievalStrategy;     // Search strategy\n  distance_metric?: DistanceMetric;           // Similarity metric\n  max_tokens?: number;                        // Max tokens to return (default: 4000)\n}\n\nenum RetrievalStrategy {\n  SIMILARITY = \"similarity\",           // Vector similarity search\n  TEMPORAL = \"temporal\",               // Time-based retrieval\n  RELEVANCE = \"relevance\",             // Relevance scoring\n  HYBRID = \"hybrid\",                   // Combined approaches\n  GRAPH_TRAVERSAL = \"graph_traversal\"  // Knowledge graph navigation\n}\n\nenum DistanceMetric {\n  COSINE = \"cosine\",\n  EUCLIDEAN = \"euclidean\",\n  DOT_PRODUCT = \"dot_product\",\n  MANHATTAN = \"manhattan\"\n}\n</code></pre></p> <p>Returns: <pre><code>interface SearchMemoryResponse {\n  data: {\n    results: MemoryResult[];\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface MemoryResult {\n  id: string;\n  content: string;\n  score: number;                      // Similarity score (0-1)\n  memory_type: string;\n  metadata: Record&lt;string, any&gt;;\n  vector: number[];                   // Embedding vector\n  user_id: string;\n  thread_id: string;\n  timestamp: string;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType, RetrievalStrategy, DistanceMetric } from 'agentflow-react';\n\nconst response = await client.searchMemory({\n  query: 'user interface preferences',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  limit: 5,\n  score_threshold: 0.7,\n  retrieval_strategy: RetrievalStrategy.SIMILARITY,\n  distance_metric: DistanceMetric.COSINE\n});\n\nfor (const result of response.data.results) {\n  console.log(`[${result.score.toFixed(2)}] ${result.content}`);\n}\n</code></pre></p> <p>Retrieval Strategies:</p> Strategy Description <code>SIMILARITY</code> Vector similarity search (default) <code>TEMPORAL</code> Time-based retrieval (recent first) <code>RELEVANCE</code> Relevance scoring <code>HYBRID</code> Combines multiple approaches <code>GRAPH_TRAVERSAL</code> Navigate knowledge graph <p>Distance Metrics:</p> Metric Description <code>COSINE</code> Cosine similarity (default) <code>EUCLIDEAN</code> Euclidean distance <code>DOT_PRODUCT</code> Dot product <code>MANHATTAN</code> Manhattan distance <p>Throws: - <code>BadRequestError</code> (400) - Invalid search parameters - <code>AuthenticationError</code> (401) - Invalid authentication - <code>ValidationError</code> (422) - Validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#getmemory","title":"getMemory()","text":"<p>Retrieve a specific memory by ID.</p> <p>Endpoint: <code>GET /v1/store/memories/{memory_id}</code></p> <p>Signature: <pre><code>getMemory(memoryId: string): Promise&lt;GetMemoryResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description memoryId string Yes Unique memory identifier <p>Returns: <pre><code>interface GetMemoryResponse {\n  data: {\n    memory: MemoryResult;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.getMemory('mem_123');\nconst memory = response.data.memory;\n\nconsole.log(memory.content);\nconsole.log(memory.memory_type);\nconsole.log(memory.metadata);\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Memory not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#updatememory","title":"updateMemory()","text":"<p>Update an existing memory's content or metadata.</p> <p>Endpoint: <code>PUT /v1/store/memories/{memory_id}</code></p> <p>Signature: <pre><code>updateMemory(\n  memoryId: string,\n  request: UpdateMemoryRequest\n): Promise&lt;UpdateMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface UpdateMemoryRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  content?: string;                    // Updated content\n  memory_type?: MemoryType;            // Updated type\n  category?: string;                   // Updated category\n  metadata?: Record&lt;string, any&gt;;      // Updated metadata\n}\n</code></pre></p> <p>Returns: <pre><code>interface UpdateMemoryResponse {\n  data: {\n    memory: MemoryResult;  // Updated memory\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.updateMemory('mem_123', {\n  content: 'Updated user preference: prefers light mode',\n  metadata: {\n    updated_at: new Date().toISOString(),\n    confidence: 0.95\n  }\n});\n\nconsole.log('Updated:', response.data.memory.content);\n</code></pre></p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid update data - <code>AuthenticationError</code> (401) - Invalid authentication - <code>NotFoundError</code> (404) - Memory not found - <code>ValidationError</code> (422) - Validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#deletememory","title":"deleteMemory()","text":"<p>Delete a specific memory by ID.</p> <p>Endpoint: <code>DELETE /v1/store/memories/{memory_id}</code></p> <p>Signature: <pre><code>deleteMemory(memoryId: string): Promise&lt;DeleteMemoryResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description memoryId string Yes Unique memory identifier <p>Returns: <pre><code>interface DeleteMemoryResponse {\n  data: {\n    success: boolean;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.deleteMemory('mem_123');\nconsole.log(response.data.success);  // true\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>PermissionError</code> (403) - No permission to delete - <code>NotFoundError</code> (404) - Memory not found - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#listmemories","title":"listMemories()","text":"<p>List all memories with optional filtering and pagination.</p> <p>Endpoint: <code>GET /v1/store/memories</code></p> <p>Signature: <pre><code>listMemories(request?: ListMemoriesRequest): Promise&lt;ListMemoriesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ListMemoriesRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  memory_type?: MemoryType;    // Filter by type\n  category?: string;            // Filter by category\n  offset?: number;              // Pagination offset (default: 0)\n  limit?: number;               // Number of results (default: 20)\n  filters?: Record&lt;string, any&gt;; // Additional filters\n}\n</code></pre></p> <p>Returns: <pre><code>interface ListMemoriesResponse {\n  data: {\n    memories: MemoryResult[];\n    total?: number;  // Total count (if available)\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\n// List all semantic memories\nconst response = await client.listMemories({\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  offset: 0,\n  limit: 10\n});\n\nconsole.log(`Found ${response.data.memories.length} memories`);\nfor (const memory of response.data.memories) {\n  console.log(`- ${memory.content}`);\n}\n</code></pre></p> <p>Throws: - <code>AuthenticationError</code> (401) - Invalid authentication - <code>ValidationError</code> (422) - Invalid parameters - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#forgetmemories","title":"forgetMemories()","text":"<p>Delete multiple memories matching specified criteria.</p> <p>Endpoint: <code>POST /v1/store/memories/forget</code></p> <p>Signature: <pre><code>forgetMemories(request: ForgetMemoriesRequest): Promise&lt;ForgetMemoriesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ForgetMemoriesRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  memory_ids?: string[];               // Specific memory IDs to delete\n  memory_type?: MemoryType;            // Delete by type\n  category?: string;                   // Delete by category\n  filters?: Record&lt;string, any&gt;;       // Additional filters\n  before_date?: string;                // Delete memories before date\n  score_threshold?: number;            // Delete below similarity score\n}\n</code></pre></p> <p>Returns: <pre><code>interface ForgetMemoriesResponse {\n  data: {\n    deleted_count: number;  // Number of memories deleted\n    memory_ids: string[];   // IDs of deleted memories\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\n// Delete specific memories\nconst response1 = await client.forgetMemories({\n  memory_ids: ['mem_123', 'mem_456']\n});\n\n// Delete by category and type\nconst response2 = await client.forgetMemories({\n  memory_type: MemoryType.EPISODIC,\n  category: 'old_conversations',\n  before_date: '2024-01-01T00:00:00Z'\n});\n\nconsole.log(`Deleted ${response2.data.deleted_count} memories`);\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p> <p>Throws: - <code>BadRequestError</code> (400) - Invalid criteria - <code>AuthenticationError</code> (401) - Invalid authentication - <code>PermissionError</code> (403) - No permission to delete - <code>ValidationError</code> (422) - Validation failed - <code>ServerError</code> (500+) - Server issues</p>"},{"location":"client/api-reference/#error-handling","title":"Error Handling","text":"<p>All endpoints may throw the following errors. See Error Handling Guide for details.</p> Error Class Status Code Description <code>BadRequestError</code> 400 Invalid request data <code>AuthenticationError</code> 401 Authentication failed <code>PermissionError</code> 403 Permission denied <code>NotFoundError</code> 404 Resource not found <code>ValidationError</code> 422 Validation failed <code>ServerError</code> 500+ Server-side errors <p>See Also: - Error Handling Guide - Examples Directory</p>"},{"location":"client/api-reference/#response-metadata","title":"Response Metadata","text":"<p>All responses include metadata with request tracking information:</p> <pre><code>interface ResponseMetadata {\n  message: string;        // Status message\n  request_id: string;     // Unique request identifier (for debugging)\n  timestamp: string;      // ISO 8601 timestamp\n}\n</code></pre> <p>Using Request IDs:</p> <p>Request IDs are useful for: - Debugging issues - Support tickets - Log correlation - Performance tracking</p> <pre><code>try {\n  const response = await client.invoke(request);\n  console.log('Success! Request ID:', response.metadata.request_id);\n} catch (error) {\n  if (error instanceof AgentFlowError) {\n    console.error('Failed! Request ID:', error.requestId);\n    // Include this ID in support tickets\n  }\n}\n</code></pre>"},{"location":"client/error-handling/","title":"Error Handling Guide","text":"<p>Complete guide to handling errors in agentflow-react.</p>"},{"location":"client/error-handling/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Error Classes</li> <li>Error Response Structure</li> <li>Catching Errors</li> <li>Error Properties</li> <li>Handling Specific Errors</li> <li>Validation Errors</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"client/error-handling/#overview","title":"Overview","text":"<p>The agentflow-react library provides structured error handling with specific error classes for different HTTP status codes. All errors extend the base <code>AgentFlowError</code> class and include rich information like request IDs, timestamps, and detailed error messages.</p>"},{"location":"client/error-handling/#benefits","title":"Benefits","text":"<ul> <li>Type-Safe: Use TypeScript <code>instanceof</code> checks</li> <li>Rich Information: Request IDs, timestamps, error codes</li> <li>Easy Debugging: Include request IDs in support tickets</li> <li>Validation Details: Field-level validation errors for 422 responses</li> <li>Consistent: Same error structure across all endpoints</li> </ul>"},{"location":"client/error-handling/#error-classes","title":"Error Classes","text":"<p>All error classes are exported from <code>agentflow-react</code> and can be imported directly:</p> <pre><code>import { \n  AgentFlowError,\n  BadRequestError,\n  AuthenticationError,\n  PermissionError,\n  NotFoundError,\n  ValidationError,\n  ServerError\n} from 'agentflow-react';\n</code></pre>"},{"location":"client/error-handling/#error-class-hierarchy","title":"Error Class Hierarchy","text":"<pre><code>AgentFlowError (Base)\n\u251c\u2500\u2500 BadRequestError (400)\n\u251c\u2500\u2500 AuthenticationError (401)\n\u251c\u2500\u2500 PermissionError (403)\n\u251c\u2500\u2500 NotFoundError (404)\n\u251c\u2500\u2500 ValidationError (422)\n\u2514\u2500\u2500 ServerError (500, 502, 503, 504)\n</code></pre>"},{"location":"client/error-handling/#error-class-details","title":"Error Class Details","text":"Class Status Code Error Code When It Occurs <code>BadRequestError</code> 400 <code>BAD_REQUEST</code> Invalid request data, malformed JSON <code>AuthenticationError</code> 401 <code>AUTHENTICATION_FAILED</code> Missing or invalid auth token <code>PermissionError</code> 403 <code>PERMISSION_ERROR</code> No permission to access resource <code>NotFoundError</code> 404 <code>RESOURCE_NOT_FOUND</code> Thread, message, or memory not found <code>ValidationError</code> 422 <code>VALIDATION_ERROR</code> Field validation failed <code>ServerError</code> 500+ <code>INTERNAL_SERVER_ERROR</code> Server-side errors"},{"location":"client/error-handling/#error-response-structure","title":"Error Response Structure","text":"<p>All errors from the API follow this structure:</p> <pre><code>{\n  \"metadata\": {\n    \"message\": \"Failed\",\n    \"request_id\": \"9843ae2e8f054fc7b6fcadf743483a08\",\n    \"timestamp\": \"2025-10-26T12:05:32.987017\"\n  },\n  \"error\": {\n    \"code\": \"BAD_REQUEST\",\n    \"message\": \"Invalid input, please check the input data for any errors\",\n    \"details\": []\n  }\n}\n</code></pre> <p>The library automatically parses this and creates the appropriate error class.</p>"},{"location":"client/error-handling/#catching-errors","title":"Catching Errors","text":""},{"location":"client/error-handling/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>import { AgentFlowClient, AgentFlowError } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token'\n});\n\ntry {\n  const response = await client.ping();\n  console.log('Success:', response.data);\n} catch (error) {\n  if (error instanceof AgentFlowError) {\n    // All AgentFlow errors\n    console.error('AgentFlow Error:', error.message);\n    console.error('Request ID:', error.requestId);\n    console.error('Error Code:', error.errorCode);\n  } else {\n    // Network errors, timeouts, etc.\n    console.error('Unexpected error:', error);\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#catching-specific-errors","title":"Catching Specific Errors","text":"<pre><code>import {\n  NotFoundError,\n  AuthenticationError,\n  ValidationError,\n  ServerError\n} from 'agentflow-react';\n\ntry {\n  const thread = await client.threadDetails('thread_123');\n} catch (error) {\n  if (error instanceof AuthenticationError) {\n    // Handle authentication failure\n    console.log('Please log in again');\n    redirectToLogin();\n  } else if (error instanceof NotFoundError) {\n    // Handle not found\n    console.log('Thread not found');\n    showNotFoundPage();\n  } else if (error instanceof ValidationError) {\n    // Handle validation errors\n    console.log('Validation failed');\n    displayValidationErrors(error.details);\n  } else if (error instanceof ServerError) {\n    // Handle server errors\n    console.log('Server error, please try again');\n    showRetryOption();\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#error-properties","title":"Error Properties","text":"<p>All error classes extend <code>AgentFlowError</code> and include these properties:</p> <pre><code>class AgentFlowError extends Error {\n  statusCode: number;           // HTTP status code (400, 401, 404, etc.)\n  errorCode: string;            // API error code ('BAD_REQUEST', etc.)\n  requestId?: string;           // Request ID from API (for debugging)\n  timestamp?: string;           // Error timestamp\n  details?: ErrorDetail[];      // Detailed error information (especially for ValidationError)\n}\n</code></pre>"},{"location":"client/error-handling/#errordetail-structure","title":"ErrorDetail Structure","text":"<pre><code>interface ErrorDetail {\n  loc?: (string | number)[];    // Field location (e.g., [\"body\", \"name\"])\n  msg: string;                  // Error message\n  type: string;                 // Error type (e.g., \"value_error.missing\")\n}\n</code></pre>"},{"location":"client/error-handling/#handling-specific-errors","title":"Handling Specific Errors","text":""},{"location":"client/error-handling/#400-bad-request","title":"400 Bad Request","text":"<p>Occurs when the request data is malformed or invalid.</p> <pre><code>import { BadRequestError } from 'agentflow-react';\n\ntry {\n  await client.updateThreadState('thread_123', {\n    state: invalidData  // Malformed data\n  });\n} catch (error) {\n  if (error instanceof BadRequestError) {\n    console.error('Bad request:', error.message);\n    console.error('Request ID:', error.requestId);\n\n    // Fix the data and retry\n    const fixedData = fixData(invalidData);\n    await client.updateThreadState('thread_123', { state: fixedData });\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#401-authentication-error","title":"401 Authentication Error","text":"<p>Occurs when the auth token is missing, invalid, or expired.</p> <pre><code>import { AuthenticationError } from 'agentflow-react';\n\ntry {\n  await client.threads();\n} catch (error) {\n  if (error instanceof AuthenticationError) {\n    console.error('Authentication failed');\n    console.error('Request ID:', error.requestId);\n\n    // Redirect to login or refresh token\n    await refreshAuthToken();\n    // Or redirect to login page\n    window.location.href = '/login';\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#403-permission-error","title":"403 Permission Error","text":"<p>Occurs when the user doesn't have permission to perform the action.</p> <pre><code>import { PermissionError } from 'agentflow-react';\n\ntry {\n  await client.deleteThread('thread_123');\n} catch (error) {\n  if (error instanceof PermissionError) {\n    console.error('Permission denied');\n    console.error('Request ID:', error.requestId);\n\n    // Show error message to user\n    showAlert('You do not have permission to delete this thread');\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#404-not-found","title":"404 Not Found","text":"<p>Occurs when the requested resource doesn't exist.</p> <pre><code>import { NotFoundError } from 'agentflow-react';\n\ntry {\n  const message = await client.threadMessage('thread_123', 'msg_999');\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    console.error('Resource not found');\n    console.error('Request ID:', error.requestId);\n\n    // Show appropriate UI\n    showNotFoundPage();\n    // Or redirect\n    router.push('/threads');\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#422-validation-error","title":"422 Validation Error","text":"<p>Occurs when field validation fails. Most detailed error type with field-level information.</p> <pre><code>import { ValidationError } from 'agentflow-react';\n\ntry {\n  await client.updateThreadState('thread_123', {\n    state: {\n      step: 123,  // Should be string\n      // Missing required field 'status'\n    }\n  });\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.error('Validation failed:', error.message);\n    console.error('Request ID:', error.requestId);\n\n    // Access detailed validation errors\n    if (error.details) {\n      for (const detail of error.details) {\n        const fieldPath = detail.loc?.join('.') || 'unknown';\n        console.error(`Field ${fieldPath}: ${detail.msg}`);\n      }\n    }\n\n    // Example output:\n    // Field body.state.step: value is not a valid string\n    // Field body.state.status: field required\n\n    // Show errors in UI\n    displayFieldErrors(error.details);\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#500-server-errors","title":"500+ Server Errors","text":"<p>Occurs when there's a server-side issue.</p> <pre><code>import { ServerError } from 'agentflow-react';\n\ntry {\n  await client.invoke(request);\n} catch (error) {\n  if (error instanceof ServerError) {\n    console.error('Server error:', error.message);\n    console.error('Status code:', error.statusCode);  // 500, 502, 503, or 504\n    console.error('Request ID:', error.requestId);     // Important for support!\n\n    // Show retry option\n    const retry = await showRetryDialog(\n      'Server error occurred. Please try again.',\n      error.requestId  // Show this to user for support\n    );\n\n    if (retry) {\n      await client.invoke(request);\n    }\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#validation-errors","title":"Validation Errors","text":"<p>Validation errors (422) include detailed field-level error information.</p>"},{"location":"client/error-handling/#example-validation-error-response","title":"Example Validation Error Response","text":"<pre><code>{\n  \"metadata\": {\n    \"message\": \"Failed\",\n    \"request_id\": \"6b08dd969bc44f4c8e9735ee14d9de0e\",\n    \"timestamp\": \"2025-10-26T12:05:32.989646\"\n  },\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid input\",\n    \"details\": [\n      {\n        \"loc\": [\"body\", \"state\", \"name\"],\n        \"msg\": \"field required\",\n        \"type\": \"value_error.missing\"\n      },\n      {\n        \"loc\": [\"body\", \"state\", \"age\"],\n        \"msg\": \"value is not a valid integer\",\n        \"type\": \"type_error.integer\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#handling-validation-errors-in-forms","title":"Handling Validation Errors in Forms","text":"<pre><code>import { ValidationError } from 'agentflow-react';\n\nasync function submitForm(formData: any) {\n  try {\n    await client.updateThreadState('thread_123', {\n      state: formData\n    });\n\n    showSuccess('Saved successfully');\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      // Create field error map\n      const fieldErrors: Record&lt;string, string&gt; = {};\n\n      if (error.details) {\n        for (const detail of error.details) {\n          // Extract field name from location\n          // [\"body\", \"state\", \"name\"] -&gt; \"name\"\n          const fieldName = detail.loc?.[detail.loc.length - 1] || 'unknown';\n          fieldErrors[fieldName] = detail.msg;\n        }\n      }\n\n      // Display errors in form\n      displayFormErrors(fieldErrors);\n\n      // Example:\n      // { name: \"field required\", age: \"value is not a valid integer\" }\n    } else {\n      showError('An error occurred. Please try again.');\n    }\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#react-form-example","title":"React Form Example","text":"<pre><code>import { useState } from 'react';\nimport { ValidationError } from 'agentflow-react';\n\nfunction MyForm() {\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n\n  async function handleSubmit(data: any) {\n    try {\n      await client.updateThreadState('thread_123', { state: data });\n      setErrors({});  // Clear errors on success\n    } catch (error) {\n      if (error instanceof ValidationError &amp;&amp; error.details) {\n        const newErrors: Record&lt;string, string&gt; = {};\n        for (const detail of error.details) {\n          const field = detail.loc?.[detail.loc.length - 1] as string;\n          newErrors[field] = detail.msg;\n        }\n        setErrors(newErrors);\n      }\n    }\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input name=\"name\" /&gt;\n      {errors.name &amp;&amp; &lt;span className=\"error\"&gt;{errors.name}&lt;/span&gt;}\n\n      &lt;input name=\"age\" type=\"number\" /&gt;\n      {errors.age &amp;&amp; &lt;span className=\"error\"&gt;{errors.age}&lt;/span&gt;}\n    &lt;/form&gt;\n  );\n}\n</code></pre>"},{"location":"client/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"client/error-handling/#1-always-include-request-ids-in-support-tickets","title":"1. Always Include Request IDs in Support Tickets","text":"<pre><code>try {\n  await client.invoke(request);\n} catch (error) {\n  if (error instanceof AgentFlowError) {\n    // Log with request ID\n    logger.error('Invoke failed', {\n      message: error.message,\n      requestId: error.requestId,  // \u2b50 Include this!\n      errorCode: error.errorCode,\n      timestamp: error.timestamp\n    });\n\n    // Show to user for support\n    showErrorDialog(\n      `Error occurred. If this persists, contact support with Request ID: ${error.requestId}`\n    );\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#2-handle-authentication-errors-globally","title":"2. Handle Authentication Errors Globally","text":"<pre><code>// Create a wrapper function\nasync function apiCall&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n  try {\n    return await fn();\n  } catch (error) {\n    if (error instanceof AuthenticationError) {\n      // Global auth error handling\n      await refreshToken();\n      // Retry once\n      return await fn();\n    }\n    throw error;  // Re-throw other errors\n  }\n}\n\n// Usage\nconst threads = await apiCall(() =&gt; client.threads());\n</code></pre>"},{"location":"client/error-handling/#3-show-user-friendly-messages","title":"3. Show User-Friendly Messages","text":"<pre><code>function getErrorMessage(error: unknown): string {\n  if (error instanceof AuthenticationError) {\n    return 'Please log in again to continue.';\n  }\n  if (error instanceof NotFoundError) {\n    return 'The requested resource was not found.';\n  }\n  if (error instanceof ValidationError) {\n    return 'Please check your input and try again.';\n  }\n  if (error instanceof ServerError) {\n    return 'Server error. Please try again later.';\n  }\n  if (error instanceof AgentFlowError) {\n    return error.message;\n  }\n  return 'An unexpected error occurred.';\n}\n\n// Usage\ntry {\n  await client.deleteThread('thread_123');\n} catch (error) {\n  const message = getErrorMessage(error);\n  showNotification(message);\n}\n</code></pre>"},{"location":"client/error-handling/#4-implement-retry-logic-for-server-errors","title":"4. Implement Retry Logic for Server Errors","text":"<pre><code>async function withRetry&lt;T&gt;(\n  fn: () =&gt; Promise&lt;T&gt;,\n  maxRetries: number = 3\n): Promise&lt;T&gt; {\n  for (let i = 0; i &lt; maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (error instanceof ServerError &amp;&amp; i &lt; maxRetries - 1) {\n        // Wait before retry (exponential backoff)\n        await new Promise(resolve =&gt; \n          setTimeout(resolve, Math.pow(2, i) * 1000)\n        );\n        continue;\n      }\n      throw error;\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n\n// Usage\nconst result = await withRetry(() =&gt; \n  client.invoke({ messages: [...] })\n);\n</code></pre>"},{"location":"client/error-handling/#5-log-errors-properly","title":"5. Log Errors Properly","text":"<pre><code>interface ErrorLog {\n  message: string;\n  statusCode: number;\n  errorCode: string;\n  requestId?: string;\n  timestamp?: string;\n  endpoint: string;\n}\n\nfunction logError(error: unknown, endpoint: string): void {\n  if (error instanceof AgentFlowError) {\n    const log: ErrorLog = {\n      message: error.message,\n      statusCode: error.statusCode,\n      errorCode: error.errorCode,\n      requestId: error.requestId,\n      timestamp: error.timestamp,\n      endpoint\n    };\n\n    // Send to your logging service\n    logger.error('AgentFlow API Error', log);\n  } else {\n    logger.error('Unexpected Error', { error, endpoint });\n  }\n}\n\n// Usage\ntry {\n  await client.threads();\n} catch (error) {\n  logError(error, 'threads');\n  throw error;\n}\n</code></pre>"},{"location":"client/error-handling/#examples","title":"Examples","text":""},{"location":"client/error-handling/#complete-error-handling-example","title":"Complete Error Handling Example","text":"<pre><code>import {\n  AgentFlowClient,\n  AgentFlowError,\n  AuthenticationError,\n  NotFoundError,\n  ValidationError,\n  ServerError,\n  Message\n} from 'agentflow-react';\n\nclass AgentFlowService {\n  private client: AgentFlowClient;\n\n  constructor(baseUrl: string, authToken: string) {\n    this.client = new AgentFlowClient({ baseUrl, authToken });\n  }\n\n  async invokeAgent(messages: Message[]): Promise&lt;any&gt; {\n    try {\n      const result = await this.client.invoke({\n        messages,\n        granularity: 'full',\n        recursion_limit: 10\n      });\n\n      return {\n        success: true,\n        data: result,\n        error: null\n      };\n\n    } catch (error) {\n      // Handle specific errors\n      if (error instanceof AuthenticationError) {\n        console.error('Authentication failed:', error.requestId);\n        return {\n          success: false,\n          error: 'Please log in again',\n          shouldRetry: false,\n          shouldReauth: true\n        };\n      }\n\n      if (error instanceof ValidationError) {\n        console.error('Validation failed:', error.details);\n        return {\n          success: false,\n          error: 'Invalid input data',\n          validationErrors: error.details,\n          shouldRetry: false\n        };\n      }\n\n      if (error instanceof ServerError) {\n        console.error('Server error:', error.requestId);\n        return {\n          success: false,\n          error: 'Server error occurred',\n          requestId: error.requestId,\n          shouldRetry: true\n        };\n      }\n\n      if (error instanceof AgentFlowError) {\n        console.error('AgentFlow error:', error.message);\n        return {\n          success: false,\n          error: error.message,\n          requestId: error.requestId,\n          shouldRetry: false\n        };\n      }\n\n      // Unknown error\n      console.error('Unexpected error:', error);\n      return {\n        success: false,\n        error: 'An unexpected error occurred',\n        shouldRetry: true\n      };\n    }\n  }\n}\n</code></pre>"},{"location":"client/error-handling/#react-hook-example","title":"React Hook Example","text":"<pre><code>import { useState, useCallback } from 'react';\nimport { AgentFlowClient, AgentFlowError, ValidationError } from 'agentflow-react';\n\nfunction useAgentFlow(client: AgentFlowClient) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n  const [validationErrors, setValidationErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n\n  const invoke = useCallback(async (messages: Message[]) =&gt; {\n    setLoading(true);\n    setError(null);\n    setValidationErrors({});\n\n    try {\n      const result = await client.invoke({ messages });\n      return result;\n\n    } catch (err) {\n      if (err instanceof ValidationError) {\n        setError('Validation failed');\n\n        const errors: Record&lt;string, string&gt; = {};\n        if (err.details) {\n          for (const detail of err.details) {\n            const field = detail.loc?.[detail.loc.length - 1] as string;\n            errors[field] = detail.msg;\n          }\n        }\n        setValidationErrors(errors);\n\n      } else if (err instanceof AgentFlowError) {\n        setError(err.message);\n      } else {\n        setError('An unexpected error occurred');\n      }\n\n      throw err;\n\n    } finally {\n      setLoading(false);\n    }\n  }, [client]);\n\n  return { invoke, loading, error, validationErrors };\n}\n</code></pre>"},{"location":"client/error-handling/#summary","title":"Summary","text":"<ul> <li>Import error classes from <code>agentflow-react</code></li> <li>Use <code>instanceof</code> checks for type-safe error handling</li> <li>Access <code>error.requestId</code> for debugging and support tickets</li> <li>Handle validation errors with field-level detail</li> <li>Implement retry logic for server errors</li> <li>Show user-friendly messages in your UI</li> <li>Log errors properly with request IDs and context</li> </ul> <p>For complete API reference, see API Reference.</p>"},{"location":"client/invoke-usage/","title":"Invoke API with Tool Execution","text":"<p>This document explains how to use the <code>invoke</code> method with automatic tool execution loop.</p>"},{"location":"client/invoke-usage/#overview","title":"Overview","text":"<p>The <code>invoke</code> method allows you to interact with the AgentFlow API and automatically execute remote tools in a loop until completion or the recursion limit is reached.</p>"},{"location":"client/invoke-usage/#remote-tools-vs-backend-tools","title":"Remote Tools vs Backend Tools","text":"<p>IMPORTANT: Before using remote tools, understand the difference:</p> <ul> <li>Backend Tools (Python AgentFlow library): \u2705 PREFERRED - Run on the server, more secure and efficient</li> <li>Remote Tools (This client library): \u26a0\ufe0f ONLY for browser-level APIs - Run on the client (e.g., <code>localStorage</code>, <code>navigator.geolocation</code>)</li> </ul> <p>Use remote tools ONLY when you need access to browser-specific APIs. For database queries, external API calls, calculations, and most other operations, define your tools in the Python backend instead.</p> <p>See: Tools Guide - When to Use Remote Tools for detailed guidance.</p>"},{"location":"client/invoke-usage/#architecture","title":"Architecture","text":""},{"location":"client/invoke-usage/#flow-diagram","title":"Flow Diagram","text":"<pre><code>Client.invoke()\n    \u2193\nEndpoint.invoke() [Loop starts here]\n    \u2193\n1. POST /v1/graph/invoke\n    \u2193\n2. Receive response\n    \u2193\n3. Check for remote_tool_call blocks\n    \u2193\n4. If found:\n    - Execute tools locally via ToolExecutor\n    - Create tool_message with results\n    - Add to messages\n    - Go to step 1 (next iteration)\n    \u2193\n5. If not found or limit reached:\n    - Return final result\n</code></pre>"},{"location":"client/invoke-usage/#key-components","title":"Key Components","text":"<ol> <li>Client (<code>src/client.ts</code>): </li> <li>User-facing API</li> <li>Handles tool registration</li> <li> <p>Delegates invoke to endpoint</p> </li> <li> <p>Invoke Endpoint (<code>src/endpoints/invoke.ts</code>):</p> </li> <li>Contains the recursion loop logic</li> <li>Makes API calls to <code>/v1/graph/invoke</code></li> <li>Checks for remote tool calls</li> <li>Executes tools via ToolExecutor</li> <li> <p>Tracks all intermediate results</p> </li> <li> <p>ToolExecutor (<code>src/tools.ts</code>):</p> </li> <li>Executes registered tools</li> <li>Manages tool registry by node</li> <li>Converts tool results to messages</li> </ol>"},{"location":"client/invoke-usage/#usage","title":"Usage","text":""},{"location":"client/invoke-usage/#1-create-client-and-register-tools","title":"1. Create Client and Register Tools","text":"<pre><code>import { AgentFlowClient, Message, ToolRegistration } from 'agentflow-react';\n\n// Create client\nconst client = new AgentFlowClient({\n    baseUrl: 'http://127.0.0.1:8000',\n    authToken: null,\n    debug: true\n});\n\n// Define a tool\nconst weatherTool: ToolRegistration = {\n    node: 'weather_node',\n    name: 'get_weather',\n    description: 'Get current weather',\n    parameters: {\n        type: 'object',\n        properties: {\n            location: { type: 'string' }\n        },\n        required: ['location']\n    },\n    handler: async (args) =&gt; {\n        // Your tool logic here\n        return { temperature: 72, conditions: 'sunny' };\n    }\n};\n\n// Register tool\nclient.registerTool(weatherTool);\n</code></pre>"},{"location":"client/invoke-usage/#2-setup-tools-optional","title":"2. Setup Tools (Optional)","text":"<pre><code>// Setup tools on server (dummy implementation for now)\nawait client.setup();\n</code></pre>"},{"location":"client/invoke-usage/#3-invoke-the-graph","title":"3. Invoke the Graph","text":"<pre><code>const messages = [\n    Message.text_message('What is the weather?', 'user')\n];\n\nconst result = await client.invoke(\n    messages,\n    {}, // initial_state\n    {}, // config\n    25, // recursion_limit (default: 25)\n    'full' // response_granularity (default: 'full')\n);\n\nconsole.log('Iterations:', result.iterations);\nconsole.log('Messages:', result.messages);\nconsole.log('All messages:', result.all_messages);\n</code></pre>"},{"location":"client/invoke-usage/#request-format","title":"Request Format","text":"<pre><code>{\n  messages: [\n    {\n      message_id: null,\n      role: \"user\",\n      content: [{ type: \"text\", text: \"HI\" }]\n    }\n  ],\n  initial_state: {},\n  config: {},\n  recursion_limit: 25,\n  response_granularity: \"full\" // or \"partial\" or \"low\"\n}\n</code></pre>"},{"location":"client/invoke-usage/#response-format","title":"Response Format","text":""},{"location":"client/invoke-usage/#invokeresult","title":"InvokeResult","text":"<pre><code>interface InvokeResult {\n    messages: Message[];              // Final messages from last iteration\n    state?: AgentState;               // Final state\n    context?: Message[];              // Context messages\n    summary?: string | null;          // Summary\n    meta: InvokeMetadata;            // Metadata (thread_id, etc.)\n    all_messages: Message[];         // ALL messages including intermediate\n    iterations: number;              // Number of iterations performed\n    recursion_limit_reached: boolean; // Whether limit was hit\n}\n</code></pre>"},{"location":"client/invoke-usage/#response-granularity","title":"Response Granularity","text":"<ul> <li><code>full</code>: Complete response with all details (messages, context, summary, state, meta)</li> <li><code>partial</code>: Key information with some details omitted (messages, context, summary, meta)</li> <li><code>low</code>: Minimal response (only messages and meta)</li> </ul>"},{"location":"client/invoke-usage/#tool-execution-loop","title":"Tool Execution Loop","text":"<p>The invoke endpoint automatically handles the tool execution loop:</p> <ol> <li>Iteration 1: Send initial messages \u2192 Receive response</li> <li>Check: Does response contain <code>remote_tool_call</code> blocks?</li> <li>If YES: </li> <li>Execute tools locally using ToolExecutor</li> <li>Create <code>tool_message</code> with results</li> <li>Add to message history</li> <li>Go to next iteration</li> <li>If NO: Return final result</li> <li>Stop: When no tool calls or recursion_limit reached</li> </ol>"},{"location":"client/invoke-usage/#example-flow","title":"Example Flow","text":"<pre><code>User: \"What is 5 + 3?\"\n\nIteration 1:\n  Request: [user message: \"What is 5 + 3?\"]\n  Response: [assistant message with remote_tool_call: calculate(5 + 3)]\n\nIteration 2:\n  Execute: calculate(5 + 3) \u2192 {result: 8}\n  Request: [tool_message: {result: 8}]\n  Response: [assistant message: \"The answer is 8\"]\n\nNo more tool calls \u2192 Return result\n</code></pre>"},{"location":"client/invoke-usage/#tool-registration","title":"Tool Registration","text":"<p>\u26a0\ufe0f Important: Remote tool registration should only be used for browser-level APIs. For most use cases, define your tools in the Python backend instead. See When to Use Remote Tools.</p>"},{"location":"client/invoke-usage/#toolregistration-interface","title":"ToolRegistration Interface","text":"<pre><code>interface ToolRegistration {\n    node: string;              // Node name where tool is used\n    name: string;              // Tool name\n    description?: string;      // Tool description\n    parameters?: ToolParameter; // OpenAI-style parameters schema\n    handler: ToolHandler;      // Async function to execute\n}\n</code></pre>"},{"location":"client/invoke-usage/#tool-handler","title":"Tool Handler","text":"<pre><code>type ToolHandler = (args: any) =&gt; Promise&lt;any&gt;;\n</code></pre> <p>The handler receives the arguments from the <code>remote_tool_call</code> and should return the result.</p>"},{"location":"client/invoke-usage/#error-handling","title":"Error Handling","text":"<ul> <li>Tools that throw errors will have <code>is_error: true</code> and <code>status: 'failed'</code> in the result</li> <li>The loop continues even if a tool fails</li> <li>Check <code>result.recursion_limit_reached</code> to see if limit was hit</li> </ul>"},{"location":"client/invoke-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Set reasonable recursion limits: Default is 25, adjust based on your use case</li> <li>Handle tool errors gracefully: Wrap tool logic in try-catch</li> <li>Use debug mode: Enable <code>debug: true</code> to see detailed logs</li> <li>Track intermediate results: Use <code>result.all_messages</code> to see the full conversation</li> <li>Validate tool parameters: Use the <code>parameters</code> schema to define expected inputs</li> </ol>"},{"location":"client/invoke-usage/#example","title":"Example","text":"<p>See <code>examples/invoke-example.ts</code> for a complete working example.</p>"},{"location":"client/invoke-usage/#api-reference","title":"API Reference","text":""},{"location":"client/invoke-usage/#agentflowclientinvoke","title":"AgentFlowClient.invoke()","text":"<pre><code>async invoke(\n    messages: Message[],\n    initial_state?: Record&lt;string, any&gt;,\n    config?: Record&lt;string, any&gt;,\n    recursion_limit: number = 25,\n    response_granularity: 'full' | 'partial' | 'low' = 'full'\n): Promise&lt;InvokeResult&gt;\n</code></pre>"},{"location":"client/invoke-usage/#agentflowclientregistertool","title":"AgentFlowClient.registerTool()","text":"<pre><code>registerTool(registration: ToolRegistration): void\n</code></pre>"},{"location":"client/invoke-usage/#agentflowclientsetup","title":"AgentFlowClient.setup()","text":"<pre><code>async setup(): Promise&lt;void&gt;\n</code></pre> <p>Note: <code>setup()</code> is currently a dummy implementation. Future versions will send tool definitions to the server.</p>"},{"location":"client/invoke-usage/#see-also","title":"See Also","text":"<ul> <li>Tools Guide - Comprehensive guide to tool registration and execution</li> <li>React Integration - Using invoke in React applications</li> <li>React Examples - Complete React component examples with invoke</li> <li>API Reference - Complete invoke API documentation</li> <li>Stream Usage Guide - Alternative streaming API</li> <li>TypeScript Types - Type definitions for invoke</li> <li>Troubleshooting - Common invoke issues and solutions</li> </ul>"},{"location":"client/memory-api/","title":"Memory API Guide","text":"<p>Complete guide to using the AgentFlow Memory API for storing, searching, and managing agent memories.</p>"},{"location":"client/memory-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Memory Types</li> <li>Core Operations</li> <li>Store Memory</li> <li>Search Memory</li> <li>Get Memory</li> <li>Update Memory</li> <li>Delete Memory</li> <li>List Memories</li> <li>Forget Memories</li> <li>Retrieval Strategies</li> <li>Distance Metrics</li> <li>Use Cases</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"client/memory-api/#overview","title":"Overview","text":"<p>The Memory API allows agents to store and retrieve information across conversations, building context and knowledge over time. Memories are vector-embedded for semantic search and can be organized by type, category, and custom metadata.</p>"},{"location":"client/memory-api/#key-features","title":"Key Features","text":"<ul> <li>Vector Embeddings: Automatic embedding for semantic search</li> <li>Multiple Memory Types: Episodic, semantic, procedural, and more</li> <li>Flexible Search: Vector similarity, temporal, hybrid strategies</li> <li>Rich Metadata: Store custom metadata with each memory</li> <li>Bulk Operations: Forget multiple memories at once</li> <li>Category Organization: Organize memories by category</li> </ul>"},{"location":"client/memory-api/#memory-types","title":"Memory Types","text":"<pre><code>enum MemoryType {\n  EPISODIC = \"episodic\",        // Conversation memories\n  SEMANTIC = \"semantic\",         // Facts and knowledge\n  PROCEDURAL = \"procedural\",     // How-to knowledge\n  ENTITY = \"entity\",             // Entity-based memories\n  RELATIONSHIP = \"relationship\", // Entity relationships\n  CUSTOM = \"custom\",             // Custom memory types\n  DECLARATIVE = \"declarative\"    // Explicit facts and events\n}\n</code></pre>"},{"location":"client/memory-api/#when-to-use-each-type","title":"When to Use Each Type","text":"Type Use Case Example EPISODIC Conversation history, user events \"User asked about pricing on 2024-10-15\" SEMANTIC Facts, knowledge, preferences \"User prefers dark mode\" PROCEDURAL How-to information, procedures \"To reset password, click 'Forgot Password'\" ENTITY Information about entities \"John Smith: Senior Developer at Acme Corp\" RELATIONSHIP Entity relationships \"John Smith reports to Jane Doe\" DECLARATIVE Explicit facts and events \"Company founded in 2010\" CUSTOM Domain-specific memories Application-specific data"},{"location":"client/memory-api/#core-operations","title":"Core Operations","text":""},{"location":"client/memory-api/#store-memory","title":"Store Memory","text":"<p>Store a new memory in the system.</p> <p>Signature: <pre><code>storeMemory(request: StoreMemoryRequest): Promise&lt;StoreMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface StoreMemoryRequest {\n  content: string;                   // Memory content (required)\n  memory_type: MemoryType;           // Type of memory (required)\n  category: string;                  // Category (required)\n  metadata?: Record&lt;string, any&gt;;    // Additional metadata (optional)\n  config?: Record&lt;string, any&gt;;      // Configuration (optional)\n  options?: Record&lt;string, any&gt;;     // Storage options (optional)\n}\n</code></pre></p> <p>Returns: <pre><code>interface StoreMemoryResponse {\n  data: {\n    memory_id: string;  // Unique ID of stored memory\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store a semantic memory\nconst response = await client.storeMemory({\n  content: 'User prefers email notifications over SMS',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  metadata: {\n    user_id: 'user_123',\n    confidence: 0.95,\n    source: 'explicit_setting',\n    created_at: new Date().toISOString()\n  }\n});\n\nconsole.log('Memory ID:', response.data.memory_id);\n</code></pre></p> <p>Common Categories:</p> <ul> <li><code>user_preferences</code> - User settings and preferences</li> <li><code>conversation</code> - Conversation history</li> <li><code>knowledge</code> - Facts and information</li> <li><code>procedures</code> - How-to knowledge</li> <li><code>entities</code> - Entity information</li> <li><code>relationships</code> - Entity relationships</li> </ul>"},{"location":"client/memory-api/#search-memory","title":"Search Memory","text":"<p>Search for memories using vector similarity or other retrieval strategies.</p> <p>Signature: <pre><code>searchMemory(request: SearchMemoryRequest): Promise&lt;SearchMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface SearchMemoryRequest {\n  query: string;                              // Search query (required)\n  memory_type?: MemoryType;                   // Filter by type\n  category?: string;                          // Filter by category\n  limit?: number;                             // Max results (default: 10)\n  score_threshold?: number;                   // Min similarity (default: 0)\n  filters?: Record&lt;string, any&gt;;              // Additional filters\n  retrieval_strategy?: RetrievalStrategy;     // Search strategy\n  distance_metric?: DistanceMetric;           // Similarity metric\n  max_tokens?: number;                        // Max tokens (default: 4000)\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface SearchMemoryResponse {\n  data: {\n    results: MemoryResult[];\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface MemoryResult {\n  id: string;                      // Memory ID\n  content: string;                 // Memory content\n  score: number;                   // Similarity score (0-1)\n  memory_type: string;             // Memory type\n  metadata: Record&lt;string, any&gt;;   // Custom metadata\n  vector: number[];                // Embedding vector\n  user_id: string;                 // User ID\n  thread_id: string;               // Thread ID\n  timestamp: string;               // Creation timestamp\n}\n</code></pre></p> <p>Example: <pre><code>import { \n  MemoryType, \n  RetrievalStrategy, \n  DistanceMetric \n} from 'agentflow-react';\n\n// Basic search\nconst results = await client.searchMemory({\n  query: 'user notification preferences',\n  memory_type: MemoryType.SEMANTIC,\n  limit: 5\n});\n\n// Advanced search with all options\nconst advanced = await client.searchMemory({\n  query: 'how does the user prefer to be contacted',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  limit: 10,\n  score_threshold: 0.7,              // Only results with 70%+ similarity\n  retrieval_strategy: RetrievalStrategy.HYBRID,\n  distance_metric: DistanceMetric.COSINE,\n  filters: {\n    user_id: 'user_123',\n    source: 'explicit_setting'\n  }\n});\n\n// Display results\nfor (const result of advanced.data.results) {\n  console.log(`[${(result.score * 100).toFixed(0)}%] ${result.content}`);\n}\n</code></pre></p>"},{"location":"client/memory-api/#get-memory","title":"Get Memory","text":"<p>Retrieve a specific memory by ID.</p> <p>Signature: <pre><code>getMemory(memoryId: string): Promise&lt;GetMemoryResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description memoryId string Yes Unique memory identifier <p>Returns: <pre><code>interface GetMemoryResponse {\n  data: {\n    memory: MemoryResult;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.getMemory('mem_abc123');\nconst memory = response.data.memory;\n\nconsole.log('Content:', memory.content);\nconsole.log('Type:', memory.memory_type);\nconsole.log('Created:', memory.timestamp);\nconsole.log('Metadata:', memory.metadata);\n</code></pre></p>"},{"location":"client/memory-api/#update-memory","title":"Update Memory","text":"<p>Update an existing memory's content or metadata.</p> <p>Signature: <pre><code>updateMemory(\n  memoryId: string,\n  request: UpdateMemoryRequest\n): Promise&lt;UpdateMemoryResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface UpdateMemoryRequest {\n  content?: string;                    // Updated content\n  memory_type?: MemoryType;            // Updated type\n  category?: string;                   // Updated category\n  metadata?: Record&lt;string, any&gt;;      // Updated metadata\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface UpdateMemoryResponse {\n  data: {\n    memory: MemoryResult;  // Updated memory\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>// Update content\nconst response = await client.updateMemory('mem_abc123', {\n  content: 'User now prefers SMS notifications (changed from email)'\n});\n\n// Update metadata only\nawait client.updateMemory('mem_abc123', {\n  metadata: {\n    confidence: 0.98,\n    updated_at: new Date().toISOString(),\n    updated_by: 'user_action'\n  }\n});\n\n// Change category\nawait client.updateMemory('mem_abc123', {\n  category: 'user_preferences_v2'\n});\n</code></pre></p>"},{"location":"client/memory-api/#delete-memory","title":"Delete Memory","text":"<p>Delete a specific memory by ID.</p> <p>Signature: <pre><code>deleteMemory(memoryId: string): Promise&lt;DeleteMemoryResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description memoryId string Yes Unique memory identifier <p>Returns: <pre><code>interface DeleteMemoryResponse {\n  data: {\n    success: boolean;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.deleteMemory('mem_abc123');\nconsole.log('Deleted:', response.data.success);\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p>"},{"location":"client/memory-api/#list-memories","title":"List Memories","text":"<p>List all memories with optional filtering and pagination.</p> <p>Signature: <pre><code>listMemories(request?: ListMemoriesRequest): Promise&lt;ListMemoriesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ListMemoriesRequest {\n  memory_type?: MemoryType;            // Filter by type\n  category?: string;                   // Filter by category\n  offset?: number;                     // Pagination offset (default: 0)\n  limit?: number;                      // Number of results (default: 20)\n  filters?: Record&lt;string, any&gt;;       // Additional filters\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface ListMemoriesResponse {\n  data: {\n    memories: MemoryResult[];\n    total?: number;  // Total count (if available)\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\n// List all memories\nconst all = await client.listMemories();\nconsole.log(`Total: ${all.data.memories.length} memories`);\n\n// Filter by type\nconst semantic = await client.listMemories({\n  memory_type: MemoryType.SEMANTIC,\n  limit: 10\n});\n\n// Filter by category with pagination\nconst preferences = await client.listMemories({\n  category: 'user_preferences',\n  offset: 0,\n  limit: 20,\n  filters: {\n    user_id: 'user_123'\n  }\n});\n\n// Display results\nfor (const memory of preferences.data.memories) {\n  console.log(`- [${memory.memory_type}] ${memory.content}`);\n}\n</code></pre></p>"},{"location":"client/memory-api/#forget-memories","title":"Forget Memories","text":"<p>Delete multiple memories matching specified criteria.</p> <p>Signature: <pre><code>forgetMemories(request: ForgetMemoriesRequest): Promise&lt;ForgetMemoriesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ForgetMemoriesRequest {\n  memory_ids?: string[];               // Specific IDs to delete\n  memory_type?: MemoryType;            // Delete by type\n  category?: string;                   // Delete by category\n  filters?: Record&lt;string, any&gt;;       // Additional filters\n  before_date?: string;                // Delete before date\n  score_threshold?: number;            // Delete below score\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface ForgetMemoriesResponse {\n  data: {\n    deleted_count: number;    // Number of memories deleted\n    memory_ids: string[];     // IDs of deleted memories\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { MemoryType } from 'agentflow-react';\n\n// Delete specific memories\nconst result1 = await client.forgetMemories({\n  memory_ids: ['mem_1', 'mem_2', 'mem_3']\n});\nconsole.log(`Deleted ${result1.data.deleted_count} memories`);\n\n// Delete by category and type\nconst result2 = await client.forgetMemories({\n  memory_type: MemoryType.EPISODIC,\n  category: 'old_conversations'\n});\n\n// Delete old memories\nconst result3 = await client.forgetMemories({\n  before_date: '2024-01-01T00:00:00Z',\n  filters: {\n    user_id: 'user_123'\n  }\n});\nconsole.log(`Deleted ${result3.data.deleted_count} old memories`);\n\n// Delete low-confidence memories\nconst result4 = await client.forgetMemories({\n  memory_type: MemoryType.SEMANTIC,\n  filters: {\n    'metadata.confidence': { $lt: 0.5 }\n  }\n});\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p>"},{"location":"client/memory-api/#retrieval-strategies","title":"Retrieval Strategies","text":"<pre><code>enum RetrievalStrategy {\n  SIMILARITY = \"similarity\",           // Vector similarity search\n  TEMPORAL = \"temporal\",               // Time-based retrieval\n  RELEVANCE = \"relevance\",             // Relevance scoring\n  HYBRID = \"hybrid\",                   // Combined approaches\n  GRAPH_TRAVERSAL = \"graph_traversal\"  // Knowledge graph navigation\n}\n</code></pre>"},{"location":"client/memory-api/#strategy-comparison","title":"Strategy Comparison","text":"Strategy Best For How It Works SIMILARITY Semantic search Uses vector embeddings to find similar content TEMPORAL Recent memories Returns memories sorted by timestamp (newest first) RELEVANCE Context-aware search Combines similarity with context and metadata HYBRID Comprehensive search Combines multiple strategies for best results GRAPH_TRAVERSAL Related entities Navigates knowledge graph to find related memories <p>Example: <pre><code>// Similarity: Find semantically similar memories\nconst similar = await client.searchMemory({\n  query: 'notification settings',\n  retrieval_strategy: RetrievalStrategy.SIMILARITY\n});\n\n// Temporal: Get recent conversation history\nconst recent = await client.searchMemory({\n  query: 'recent discussions',\n  retrieval_strategy: RetrievalStrategy.TEMPORAL,\n  memory_type: MemoryType.EPISODIC\n});\n\n// Hybrid: Best of all strategies\nconst comprehensive = await client.searchMemory({\n  query: 'user communication preferences',\n  retrieval_strategy: RetrievalStrategy.HYBRID\n});\n</code></pre></p>"},{"location":"client/memory-api/#distance-metrics","title":"Distance Metrics","text":"<pre><code>enum DistanceMetric {\n  COSINE = \"cosine\",\n  EUCLIDEAN = \"euclidean\",\n  DOT_PRODUCT = \"dot_product\",\n  MANHATTAN = \"manhattan\"\n}\n</code></pre>"},{"location":"client/memory-api/#metric-comparison","title":"Metric Comparison","text":"Metric Best For Range Calculation COSINE Text similarity 0 to 1 Angle between vectors EUCLIDEAN Spatial distance 0 to \u221e Straight-line distance DOT_PRODUCT Magnitude + direction -\u221e to \u221e Vector dot product MANHATTAN Grid-like spaces 0 to \u221e Sum of absolute differences <p>Recommended: Use <code>COSINE</code> for most text-based semantic search tasks.</p> <p>Example: <pre><code>// Cosine similarity (most common for text)\nconst cosine = await client.searchMemory({\n  query: 'user preferences',\n  distance_metric: DistanceMetric.COSINE\n});\n\n// Euclidean distance\nconst euclidean = await client.searchMemory({\n  query: 'user preferences',\n  distance_metric: DistanceMetric.EUCLIDEAN\n});\n</code></pre></p>"},{"location":"client/memory-api/#use-cases","title":"Use Cases","text":""},{"location":"client/memory-api/#1-user-preferences-management","title":"1. User Preferences Management","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store preference\nawait client.storeMemory({\n  content: 'User prefers dark mode with compact layout',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  metadata: {\n    user_id: 'user_123',\n    preference_type: 'ui',\n    confidence: 1.0,\n    source: 'explicit_setting'\n  }\n});\n\n// Retrieve preferences\nconst prefs = await client.searchMemory({\n  query: 'user interface preferences',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  filters: { user_id: 'user_123' }\n});\n</code></pre>"},{"location":"client/memory-api/#2-conversation-history","title":"2. Conversation History","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store conversation turn\nawait client.storeMemory({\n  content: 'User asked about pricing plans for enterprise tier',\n  memory_type: MemoryType.EPISODIC,\n  category: 'conversation',\n  metadata: {\n    user_id: 'user_123',\n    thread_id: 'thread_456',\n    topic: 'pricing',\n    timestamp: new Date().toISOString()\n  }\n});\n\n// Retrieve conversation context\nconst context = await client.searchMemory({\n  query: 'previous pricing discussions',\n  memory_type: MemoryType.EPISODIC,\n  category: 'conversation',\n  limit: 10,\n  retrieval_strategy: RetrievalStrategy.TEMPORAL\n});\n</code></pre>"},{"location":"client/memory-api/#3-knowledge-base","title":"3. Knowledge Base","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store knowledge\nawait client.storeMemory({\n  content: 'Company policy: Remote work allowed up to 3 days per week',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'company_policies',\n  metadata: {\n    policy_id: 'POL-001',\n    effective_date: '2024-01-01',\n    department: 'HR'\n  }\n});\n\n// Search knowledge base\nconst policies = await client.searchMemory({\n  query: 'remote work policy',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'company_policies',\n  score_threshold: 0.8\n});\n</code></pre>"},{"location":"client/memory-api/#4-entity-relationships","title":"4. Entity Relationships","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store entity\nawait client.storeMemory({\n  content: 'John Smith: Senior Developer, email: john@example.com',\n  memory_type: MemoryType.ENTITY,\n  category: 'employees',\n  metadata: {\n    entity_id: 'emp_123',\n    department: 'Engineering',\n    role: 'Senior Developer'\n  }\n});\n\n// Store relationship\nawait client.storeMemory({\n  content: 'John Smith reports to Jane Doe (Engineering Manager)',\n  memory_type: MemoryType.RELATIONSHIP,\n  category: 'org_structure',\n  metadata: {\n    from_entity: 'emp_123',\n    to_entity: 'emp_456',\n    relationship_type: 'reports_to'\n  }\n});\n\n// Find related entities\nconst related = await client.searchMemory({\n  query: 'who does John Smith report to',\n  memory_type: MemoryType.RELATIONSHIP,\n  retrieval_strategy: RetrievalStrategy.GRAPH_TRAVERSAL\n});\n</code></pre>"},{"location":"client/memory-api/#5-procedural-knowledge","title":"5. Procedural Knowledge","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\n// Store procedure\nawait client.storeMemory({\n  content: 'To reset password: 1) Click \"Forgot Password\" 2) Enter email 3) Check inbox for reset link',\n  memory_type: MemoryType.PROCEDURAL,\n  category: 'help_guides',\n  metadata: {\n    topic: 'account_management',\n    difficulty: 'easy',\n    steps: 3\n  }\n});\n\n// Search procedures\nconst howto = await client.searchMemory({\n  query: 'how to reset password',\n  memory_type: MemoryType.PROCEDURAL,\n  category: 'help_guides'\n});\n</code></pre>"},{"location":"client/memory-api/#best-practices","title":"Best Practices","text":""},{"location":"client/memory-api/#1-use-appropriate-memory-types","title":"1. Use Appropriate Memory Types","text":"<p>Choose the right memory type for your data:</p> <pre><code>// \u2705 Good: Semantic for facts\nawait client.storeMemory({\n  content: 'User timezone: America/New_York',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_info'\n});\n\n// \u274c Bad: Episodic for facts\nawait client.storeMemory({\n  content: 'User timezone: America/New_York',\n  memory_type: MemoryType.EPISODIC,  // Wrong type!\n  category: 'user_info'\n});\n</code></pre>"},{"location":"client/memory-api/#2-add-rich-metadata","title":"2. Add Rich Metadata","text":"<p>Include metadata for filtering and context:</p> <pre><code>// \u2705 Good: Rich metadata\nawait client.storeMemory({\n  content: 'User prefers email notifications',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  metadata: {\n    user_id: 'user_123',\n    confidence: 0.95,\n    source: 'explicit_setting',\n    created_at: new Date().toISOString(),\n    created_by: 'preferences_service'\n  }\n});\n\n// \u274c Bad: No metadata\nawait client.storeMemory({\n  content: 'User prefers email notifications',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences'\n  // Missing metadata!\n});\n</code></pre>"},{"location":"client/memory-api/#3-use-categories-consistently","title":"3. Use Categories Consistently","text":"<p>Organize memories with consistent categories:</p> <pre><code>// \u2705 Good: Consistent naming\n'user_preferences'\n'user_info'\n'conversation'\n'company_policies'\n\n// \u274c Bad: Inconsistent naming\n'UserPreferences'\n'user-info'\n'CONVERSATION'\n'company policies'  // Spaces!\n</code></pre>"},{"location":"client/memory-api/#4-set-appropriate-score-thresholds","title":"4. Set Appropriate Score Thresholds","text":"<p>Use score thresholds to filter low-quality results:</p> <pre><code>// High precision (fewer, more relevant results)\nconst precise = await client.searchMemory({\n  query: 'critical information',\n  score_threshold: 0.9  // 90%+ similarity\n});\n\n// High recall (more results, some less relevant)\nconst comprehensive = await client.searchMemory({\n  query: 'general information',\n  score_threshold: 0.6  // 60%+ similarity\n});\n</code></pre>"},{"location":"client/memory-api/#5-clean-up-old-memories","title":"5. Clean Up Old Memories","text":"<p>Periodically remove outdated or low-confidence memories:</p> <pre><code>// Delete old conversation history\nawait client.forgetMemories({\n  memory_type: MemoryType.EPISODIC,\n  before_date: '2024-01-01T00:00:00Z'\n});\n\n// Delete low-confidence memories\nawait client.forgetMemories({\n  filters: {\n    'metadata.confidence': { $lt: 0.5 }\n  }\n});\n</code></pre>"},{"location":"client/memory-api/#6-batch-operations-when-possible","title":"6. Batch Operations When Possible","text":"<p>Use <code>forgetMemories</code> instead of multiple <code>deleteMemory</code> calls:</p> <pre><code>// \u2705 Good: Batch delete\nawait client.forgetMemories({\n  memory_ids: ['mem_1', 'mem_2', 'mem_3', 'mem_4', 'mem_5']\n});\n\n// \u274c Bad: Individual deletes\nfor (const id of ids) {\n  await client.deleteMemory(id);  // Slower!\n}\n</code></pre>"},{"location":"client/memory-api/#examples","title":"Examples","text":""},{"location":"client/memory-api/#complete-memory-management-example","title":"Complete Memory Management Example","text":"<pre><code>import { \n  AgentFlowClient, \n  MemoryType, \n  RetrievalStrategy \n} from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token'\n});\n\nasync function manageUserMemories(userId: string) {\n  // 1. Store user preference\n  const stored = await client.storeMemory({\n    content: 'User prefers concise responses with code examples',\n    memory_type: MemoryType.SEMANTIC,\n    category: 'user_preferences',\n    metadata: {\n      user_id: userId,\n      preference_type: 'communication_style',\n      confidence: 0.95\n    }\n  });\n  console.log('Stored:', stored.data.memory_id);\n\n  // 2. Search for relevant memories\n  const relevant = await client.searchMemory({\n    query: 'how does user prefer to receive information',\n    memory_type: MemoryType.SEMANTIC,\n    category: 'user_preferences',\n    filters: { user_id: userId },\n    limit: 5,\n    score_threshold: 0.7\n  });\n\n  console.log(`Found ${relevant.data.results.length} relevant memories:`);\n  for (const memory of relevant.data.results) {\n    console.log(`- [${(memory.score * 100).toFixed(0)}%] ${memory.content}`);\n  }\n\n  // 3. List all user memories\n  const all = await client.listMemories({\n    filters: { user_id: userId },\n    limit: 10\n  });\n  console.log(`Total memories for user: ${all.data.memories.length}`);\n\n  // 4. Update a memory\n  if (relevant.data.results.length &gt; 0) {\n    const first = relevant.data.results[0];\n    await client.updateMemory(first.id, {\n      metadata: {\n        ...first.metadata,\n        last_accessed: new Date().toISOString()\n      }\n    });\n  }\n\n  // 5. Clean up old memories\n  const deleted = await client.forgetMemories({\n    memory_type: MemoryType.EPISODIC,\n    before_date: '2024-01-01T00:00:00Z',\n    filters: { user_id: userId }\n  });\n  console.log(`Cleaned up ${deleted.data.deleted_count} old memories`);\n}\n</code></pre>"},{"location":"client/memory-api/#error-handling","title":"Error Handling","text":"<p>All memory operations may throw errors. See Error Handling Guide for details.</p> <pre><code>import { AgentFlowError, NotFoundError } from 'agentflow-react';\n\ntry {\n  const memory = await client.getMemory('mem_123');\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    console.log('Memory not found');\n  } else if (error instanceof AgentFlowError) {\n    console.error('Error:', error.message);\n    console.error('Request ID:', error.requestId);\n  }\n}\n</code></pre>"},{"location":"client/memory-api/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Error Handling Guide - Error handling patterns</li> <li>Quick Start Guide - Getting started guide</li> </ul>"},{"location":"client/quick_start/","title":"Quick Start Guide","text":"<p>Get started with agentflow-react in minutes.</p>"},{"location":"client/quick_start/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Basic Setup</li> <li>Common Use Cases</li> <li>Health Check</li> <li>List Threads</li> <li>Get Thread State</li> <li>Update Thread State</li> <li>Simple Invoke</li> <li>Invoke with Tools</li> <li>Streaming Invoke</li> <li>Memory Operations</li> <li>Next Steps</li> </ul>"},{"location":"client/quick_start/#installation","title":"Installation","text":"<pre><code>npm install agentflow-react\n</code></pre> <p>Or with yarn:</p> <pre><code>yarn add agentflow-react\n</code></pre>"},{"location":"client/quick_start/#basic-setup","title":"Basic Setup","text":""},{"location":"client/quick_start/#1-initialize-the-client","title":"1. Initialize the Client","text":"<pre><code>import { AgentFlowClient } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://your-api-url.com',  // Your AgentFlow API URL\n  authToken: 'your-auth-token',          // Your authentication token\n  timeout: 60000,                        // Optional: 60 second timeout\n  debug: true                            // Optional: Enable debug logging\n});\n</code></pre>"},{"location":"client/quick_start/#2-test-the-connection","title":"2. Test the Connection","text":"<pre><code>try {\n  const response = await client.ping();\n  console.log('Connected!', response.data);  // \"pong\"\n} catch (error) {\n  console.error('Connection failed:', error);\n}\n</code></pre>"},{"location":"client/quick_start/#common-use-cases","title":"Common Use Cases","text":""},{"location":"client/quick_start/#1-health-check","title":"1. Health Check","text":"<p>Check if the API is accessible.</p> <pre><code>const response = await client.ping();\nconsole.log(response.data);  // \"pong\"\n</code></pre>"},{"location":"client/quick_start/#2-list-threads","title":"2. List Threads","text":"<p>Get all conversation threads.</p> <pre><code>// Get all threads\nconst threads = await client.threads();\nconsole.log(threads.data.threads);\n\n// Search and paginate\nconst filtered = await client.threads({\n  search: 'customer',\n  limit: 10,\n  offset: 0\n});\n\nfor (const thread of filtered.data.threads) {\n  console.log(`${thread.thread_id}: ${thread.thread_name}`);\n}\n</code></pre>"},{"location":"client/quick_start/#3-get-thread-state","title":"3. Get Thread State","text":"<p>Retrieve the current state of a thread.</p> <pre><code>const state = await client.threadState('thread_123');\nconsole.log('Current state:', state.data.state);\n\n// Access specific state fields\nconst userPreferences = state.data.state.preferences;\nconst progress = state.data.state.progress;\n</code></pre>"},{"location":"client/quick_start/#4-update-thread-state","title":"4. Update Thread State","text":"<p>Modify the state of a thread.</p> <pre><code>const response = await client.updateThreadState('thread_123', {\n  state: {\n    step: 'completed',\n    progress: 100,\n    result: { success: true }\n  }\n});\n\nconsole.log('Updated state:', response.data.state);\n</code></pre>"},{"location":"client/quick_start/#5-simple-invoke","title":"5. Simple Invoke","text":"<p>Execute the agent workflow without tools.</p> <pre><code>import { Message } from 'agentflow-react';\n\nconst result = await client.invoke({\n  messages: [\n    Message.text_message('What is the weather like today?', 'user')\n  ],\n  granularity: 'full'\n});\n\nconsole.log('Response:', result.messages);\nconsole.log('State:', result.state);\nconsole.log('Iterations:', result.iterations);\n</code></pre>"},{"location":"client/quick_start/#6-invoke-with-tools","title":"6. Invoke with Tools","text":"<p>Execute the agent with automatic tool execution.</p> <p>\u26a0\ufe0f Important: Remote tools (registered client-side) should only be used for browser-level APIs like <code>localStorage</code>, <code>navigator.geolocation</code>, etc. For most operations (database queries, external API calls, calculations), define your tools in the Python backend instead. See Tools Guide - When to Use Remote Tools.</p> <pre><code>import { Message } from 'agentflow-react';\n\n// Step 1: Register tools (ONLY for browser APIs)\nclient.registerTool({\n  node: 'weather_node',\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'City name or location'\n      }\n    },\n    required: ['location']\n  },\n  handler: async (args) =&gt; {\n    // Your tool implementation\n    const weather = await fetchWeather(args.location);\n    return {\n      temperature: weather.temp,\n      condition: weather.condition,\n      humidity: weather.humidity\n    };\n  }\n});\n\nclient.registerTool({\n  node: 'calculator_node',\n  name: 'calculate',\n  description: 'Perform mathematical calculations',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: {\n        type: 'string',\n        description: 'Mathematical expression to evaluate'\n      }\n    },\n    required: ['expression']\n  },\n  handler: async (args) =&gt; {\n    // Your calculator implementation\n    const result = eval(args.expression);  // Use a safe eval in production!\n    return { result };\n  }\n});\n\n// Step 2: Invoke with automatic tool execution\nconst result = await client.invoke({\n  messages: [\n    Message.text_message(\"What's the weather in San Francisco and what's 25 + 17?\", 'user')\n  ],\n  granularity: 'full',\n  recursion_limit: 10,\n  on_progress: (partial) =&gt; {\n    console.log(`Progress: Iteration ${partial.iterations}`);\n  }\n});\n\nconsole.log('Final response:', result.messages);\nconsole.log('All messages (including tool calls):', result.all_messages);\nconsole.log('Total iterations:', result.iterations);\n</code></pre> <p>How it Works:</p> <ol> <li>You register tools with handlers</li> <li>Agent decides when to call tools</li> <li>Library automatically executes local tool handlers</li> <li>Results are sent back to the agent</li> <li>Process repeats until complete</li> </ol>"},{"location":"client/quick_start/#7-streaming-invoke","title":"7. Streaming Invoke","text":"<p>Get real-time responses as the agent processes.</p> <pre><code>import { Message } from 'agentflow-react';\n\nconsole.log('Streaming response:');\n\nfor await (const chunk of client.stream({\n  messages: [\n    Message.text_message('Tell me a short story about a robot', 'user')\n  ],\n  granularity: 'full'\n})) {\n  switch (chunk.event) {\n    case 'metadata':\n      console.log('Request ID:', chunk.data.request_id);\n      break;\n\n    case 'on_chain_start':\n      console.log('Started processing...');\n      break;\n\n    case 'messages_chunk':\n      // Print message content as it arrives\n      process.stdout.write(chunk.data);\n      break;\n\n    case 'state_chunk':\n      console.log('\\nState update:', chunk.data);\n      break;\n\n    case 'on_chain_end':\n      console.log('\\nCompleted!');\n      break;\n\n    case 'error':\n      console.error('Error:', chunk.data);\n      break;\n  }\n}\n</code></pre> <p>Stream Events:</p> <ul> <li><code>metadata</code> - Request metadata</li> <li><code>on_chain_start</code> - Processing started</li> <li><code>messages_chunk</code> - Incremental message content</li> <li><code>state_chunk</code> - State updates</li> <li><code>context_chunk</code> - Context updates</li> <li><code>summary_chunk</code> - Summary (full granularity only)</li> <li><code>on_chain_end</code> - Processing completed</li> <li><code>error</code> - Error occurred</li> </ul>"},{"location":"client/quick_start/#8-memory-operations","title":"8. Memory Operations","text":"<p>Store and retrieve agent memories.</p>"},{"location":"client/quick_start/#store-memory","title":"Store Memory","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\nconst response = await client.storeMemory({\n  content: 'User prefers dark mode and compact layout',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  metadata: {\n    user_id: 'user_123',\n    confidence: 0.95\n  }\n});\n\nconsole.log('Stored memory:', response.data.memory_id);\n</code></pre>"},{"location":"client/quick_start/#search-memory","title":"Search Memory","text":"<pre><code>import { MemoryType, RetrievalStrategy } from 'agentflow-react';\n\nconst results = await client.searchMemory({\n  query: 'user interface preferences',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  limit: 5,\n  score_threshold: 0.7,\n  retrieval_strategy: RetrievalStrategy.SIMILARITY\n});\n\nfor (const memory of results.data.results) {\n  console.log(`[${memory.score.toFixed(2)}] ${memory.content}`);\n}\n</code></pre>"},{"location":"client/quick_start/#list-memories","title":"List Memories","text":"<pre><code>import { MemoryType } from 'agentflow-react';\n\nconst memories = await client.listMemories({\n  memory_type: MemoryType.SEMANTIC,\n  category: 'user_preferences',\n  limit: 10\n});\n\nconsole.log(`Found ${memories.data.memories.length} memories`);\n</code></pre>"},{"location":"client/quick_start/#update-memory","title":"Update Memory","text":"<pre><code>const response = await client.updateMemory('mem_123', {\n  content: 'Updated: User now prefers light mode',\n  metadata: {\n    updated_at: new Date().toISOString()\n  }\n});\n\nconsole.log('Updated memory:', response.data.memory);\n</code></pre>"},{"location":"client/quick_start/#delete-memory","title":"Delete Memory","text":"<pre><code>const response = await client.deleteMemory('mem_123');\nconsole.log('Deleted:', response.data.success);\n</code></pre>"},{"location":"client/quick_start/#error-handling","title":"Error Handling","text":""},{"location":"client/quick_start/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>import { AgentFlowError } from 'agentflow-react';\n\ntry {\n  const result = await client.invoke({ messages: [...] });\n} catch (error) {\n  if (error instanceof AgentFlowError) {\n    console.error('API Error:', error.message);\n    console.error('Request ID:', error.requestId);  // For support tickets\n    console.error('Error Code:', error.errorCode);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n</code></pre>"},{"location":"client/quick_start/#handling-specific-errors","title":"Handling Specific Errors","text":"<pre><code>import {\n  AuthenticationError,\n  NotFoundError,\n  ValidationError,\n  ServerError\n} from 'agentflow-react';\n\ntry {\n  await client.threadDetails('thread_123');\n} catch (error) {\n  if (error instanceof AuthenticationError) {\n    console.log('Please log in again');\n  } else if (error instanceof NotFoundError) {\n    console.log('Thread not found');\n  } else if (error instanceof ValidationError) {\n    console.log('Validation failed:', error.details);\n  } else if (error instanceof ServerError) {\n    console.log('Server error, please retry');\n  }\n}\n</code></pre> <p>See Also: Error Handling Guide</p>"},{"location":"client/quick_start/#complete-example","title":"Complete Example","text":"<p>Here's a complete example combining multiple features:</p> <pre><code>import {\n  AgentFlowClient,\n  Message,\n  MemoryType,\n  AuthenticationError,\n  NotFoundError\n} from 'agentflow-react';\n\n// Initialize client\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.agentflow.example.com',\n  authToken: 'your-secret-token',\n  debug: true\n});\n\nasync function main() {\n  try {\n    // 1. Health check\n    await client.ping();\n    console.log('\u2713 Connected to API');\n\n    // 2. Register tools\n    client.registerTool({\n      node: 'search_node',\n      name: 'search_database',\n      description: 'Search the database for information',\n      parameters: {\n        type: 'object',\n        properties: {\n          query: { type: 'string' }\n        },\n        required: ['query']\n      },\n      handler: async (args) =&gt; {\n        const results = await searchDatabase(args.query);\n        return { results };\n      }\n    });\n\n    // 3. Get or create thread\n    let threadId = 'thread_123';\n    try {\n      const thread = await client.threadDetails(threadId);\n      console.log('\u2713 Using existing thread:', thread.data.thread_name);\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        console.log('Thread not found, creating new one...');\n        // Create new thread logic here\n      }\n    }\n\n    // 4. Get thread state\n    const state = await client.threadState(threadId);\n    console.log('Current state:', state.data.state);\n\n    // 5. Search memories for context\n    const memories = await client.searchMemory({\n      query: 'previous conversation topics',\n      memory_type: MemoryType.EPISODIC,\n      limit: 5\n    });\n    console.log(`Found ${memories.data.results.length} relevant memories`);\n\n    // 6. Invoke agent with streaming\n    console.log('\\nAgent response:');\n    for await (const chunk of client.stream({\n      messages: [\n        Message.text_message('Help me find information about our project timeline', 'user')\n      ],\n      granularity: 'full'\n    })) {\n      if (chunk.event === 'messages_chunk') {\n        process.stdout.write(chunk.data);\n      } else if (chunk.event === 'on_chain_end') {\n        console.log('\\n\u2713 Completed');\n      }\n    }\n\n    // 7. Store new memory\n    await client.storeMemory({\n      content: 'User asked about project timeline',\n      memory_type: MemoryType.EPISODIC,\n      category: 'conversation',\n      metadata: {\n        timestamp: new Date().toISOString()\n      }\n    });\n\n    // 8. Update thread state\n    await client.updateThreadState(threadId, {\n      state: {\n        last_topic: 'project_timeline',\n        messages_count: state.data.state.messages_count + 1\n      }\n    });\n\n    console.log('\u2713 All operations completed successfully');\n\n  } catch (error) {\n    if (error instanceof AuthenticationError) {\n      console.error('\u274c Authentication failed. Please check your token.');\n    } else if (error instanceof NotFoundError) {\n      console.error('\u274c Resource not found.');\n    } else {\n      console.error('\u274c Error:', error);\n    }\n  }\n}\n\nmain();\n</code></pre>"},{"location":"client/quick_start/#next-steps","title":"Next Steps","text":""},{"location":"client/quick_start/#learn-more","title":"Learn More","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Error Handling Guide - Comprehensive error handling</li> <li>Invoke Usage Guide - Deep dive into invoke API</li> <li>Stream Usage Guide - Streaming API guide</li> <li>State Schema Guide - Dynamic state schema</li> </ul>"},{"location":"client/quick_start/#examples","title":"Examples","text":"<ul> <li>Invoke Example - Tool execution example</li> <li>Stream Example - Streaming example</li> <li>State Schema Examples - State schema usage</li> </ul>"},{"location":"client/quick_start/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Tool Registration - How to register tools</li> <li>Tool Execution Loop - How the loop works</li> <li>Stream Events - All stream event types</li> <li>State Schema Usage - Dynamic forms and validation</li> </ul>"},{"location":"client/quick_start/#memory-types","title":"Memory Types","text":"Type Use Case <code>EPISODIC</code> Conversation history, events <code>SEMANTIC</code> Facts, knowledge, preferences <code>PROCEDURAL</code> How-to information <code>ENTITY</code> Information about entities <code>RELATIONSHIP</code> Entity relationships <code>DECLARATIVE</code> Explicit facts and events <code>CUSTOM</code> Custom memory types"},{"location":"client/quick_start/#granularity-levels","title":"Granularity Levels","text":"Level Returns <code>low</code> Messages and metadata only <code>partial</code> + State and context <code>full</code> + Summary"},{"location":"client/quick_start/#tips","title":"Tips","text":"<ol> <li>Enable Debug Mode during development to see detailed logs</li> <li>Use Request IDs from errors for debugging and support</li> <li>Register Tools before calling invoke if your agent needs them</li> <li>Handle Authentication Errors globally to refresh tokens</li> <li>Use Streaming for real-time user feedback</li> <li>Store Memories to build context over time</li> <li>Check State Schema to understand available state fields</li> </ol>"},{"location":"client/quick_start/#need-help","title":"Need Help?","text":"<ul> <li>Check the API Reference for detailed documentation</li> <li>Review Examples for working code</li> <li>See Error Handling Guide for error handling patterns</li> </ul> <p>Happy coding! \ud83d\ude80</p>"},{"location":"client/react-examples/","title":"React Component Examples","text":"<p>Complete, copy-paste ready React components demonstrating real-world usage of AgentFlow React.</p>"},{"location":"client/react-examples/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>Simple Chat Component - Basic invoke pattern</li> <li>Streaming Chat Component - Real-time streaming</li> <li>Dynamic Form Builder - State schema forms</li> <li>Agent with Tools - Tool registration and execution</li> <li>Multi-step Workflow UI - Complex workflows</li> <li>Thread Management UI - Thread state management</li> </ol>"},{"location":"client/react-examples/#1-simple-chat-component","title":"1. Simple Chat Component","text":"<p>Basic chat interface using the <code>invoke()</code> method.</p>"},{"location":"client/react-examples/#features","title":"Features","text":"<ul> <li>\u2705 Message history</li> <li>\u2705 Loading states</li> <li>\u2705 Error handling</li> <li>\u2705 Auto-scroll to bottom</li> </ul>"},{"location":"client/react-examples/#code","title":"Code","text":"<pre><code>// components/SimpleChat.tsx\nimport { useState, useRef, useEffect } from 'react';\nimport { AgentFlowClient, Message } from 'agentflow-react';\n\ninterface ChatMessage {\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n}\n\nexport function SimpleChat() {\n  const [messages, setMessages] = useState&lt;ChatMessage[]&gt;([]);\n  const [input, setInput] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);\n\n  // Initialize client (in real app, use Context)\n  const client = useRef(new AgentFlowClient({\n    baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n  })).current;\n\n  // Auto-scroll to bottom\n  useEffect(() =&gt; {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  const sendMessage = async () =&gt; {\n    if (!input.trim() || loading) return;\n\n    const userMessage: ChatMessage = {\n      role: 'user',\n      content: input,\n      timestamp: new Date()\n    };\n\n    setMessages(prev =&gt; [...prev, userMessage]);\n    setInput('');\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Convert to Message format for API\n      const apiMessages = [...messages, userMessage].map(msg =&gt;\n        Message.text_message(msg.content, msg.role)\n      );\n\n      // Send to agent\n      const result = await client.invoke(apiMessages);\n\n      // Extract assistant messages from result\n      const assistantMessages = result.messages\n        .filter(msg =&gt; msg.role === 'assistant')\n        .map(msg =&gt; ({\n          role: 'assistant' as const,\n          content: typeof msg.content === 'string' \n            ? msg.content \n            : JSON.stringify(msg.content),\n          timestamp: new Date()\n        }));\n\n      setMessages(prev =&gt; [...prev, ...assistantMessages]);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to send message');\n      console.error('Error sending message:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) =&gt; {\n    if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {\n      e.preventDefault();\n      sendMessage();\n    }\n  };\n\n  return (\n    &lt;div className=\"chat-container\" style={styles.container}&gt;\n      {/* Header */}\n      &lt;div style={styles.header}&gt;\n        &lt;h2&gt;AgentFlow Chat&lt;/h2&gt;\n      &lt;/div&gt;\n\n      {/* Messages */}\n      &lt;div style={styles.messages}&gt;\n        {messages.length === 0 &amp;&amp; (\n          &lt;div style={styles.emptyState}&gt;\n            \ud83d\udc4b Send a message to start the conversation\n          &lt;/div&gt;\n        )}\n\n        {messages.map((msg, idx) =&gt; (\n          &lt;div\n            key={idx}\n            style={{\n              ...styles.message,\n              ...(msg.role === 'user' ? styles.userMessage : styles.assistantMessage)\n            }}\n          &gt;\n            &lt;div style={styles.messageRole}&gt;\n              {msg.role === 'user' ? '\ud83d\udc64 You' : '\ud83e\udd16 Assistant'}\n            &lt;/div&gt;\n            &lt;div style={styles.messageContent}&gt;{msg.content}&lt;/div&gt;\n            &lt;div style={styles.messageTime}&gt;\n              {msg.timestamp.toLocaleTimeString()}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        ))}\n\n        {loading &amp;&amp; (\n          &lt;div style={{ ...styles.message, ...styles.assistantMessage }}&gt;\n            &lt;div style={styles.messageRole}&gt;\ud83e\udd16 Assistant&lt;/div&gt;\n            &lt;div style={styles.typing}&gt;\n              &lt;span&gt;\u25cf&lt;/span&gt;\n              &lt;span&gt;\u25cf&lt;/span&gt;\n              &lt;span&gt;\u25cf&lt;/span&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        )}\n\n        &lt;div ref={messagesEndRef} /&gt;\n      &lt;/div&gt;\n\n      {/* Error Display */}\n      {error &amp;&amp; (\n        &lt;div style={styles.error}&gt;\n          \u26a0\ufe0f {error}\n        &lt;/div&gt;\n      )}\n\n      {/* Input */}\n      &lt;div style={styles.inputContainer}&gt;\n        &lt;input\n          type=\"text\"\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyPress={handleKeyPress}\n          placeholder=\"Type your message...\"\n          disabled={loading}\n          style={styles.input}\n        /&gt;\n        &lt;button\n          onClick={sendMessage}\n          disabled={loading || !input.trim()}\n          style={styles.button}\n        &gt;\n          {loading ? '\u23f3' : '\ud83d\udce4'} Send\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Styles\nconst styles = {\n  container: {\n    display: 'flex',\n    flexDirection: 'column' as const,\n    height: '600px',\n    maxWidth: '800px',\n    margin: '0 auto',\n    border: '1px solid #ddd',\n    borderRadius: '8px',\n    overflow: 'hidden'\n  },\n  header: {\n    padding: '16px',\n    backgroundColor: '#f5f5f5',\n    borderBottom: '1px solid #ddd'\n  },\n  messages: {\n    flex: 1,\n    padding: '16px',\n    overflowY: 'auto' as const,\n    backgroundColor: '#fff'\n  },\n  emptyState: {\n    textAlign: 'center' as const,\n    color: '#999',\n    padding: '40px',\n    fontSize: '16px'\n  },\n  message: {\n    marginBottom: '16px',\n    padding: '12px',\n    borderRadius: '8px',\n    maxWidth: '70%'\n  },\n  userMessage: {\n    marginLeft: 'auto',\n    backgroundColor: '#007bff',\n    color: 'white'\n  },\n  assistantMessage: {\n    marginRight: 'auto',\n    backgroundColor: '#f0f0f0',\n    color: '#333'\n  },\n  messageRole: {\n    fontSize: '12px',\n    fontWeight: 'bold' as const,\n    marginBottom: '4px',\n    opacity: 0.8\n  },\n  messageContent: {\n    fontSize: '14px',\n    lineHeight: '1.5'\n  },\n  messageTime: {\n    fontSize: '11px',\n    marginTop: '4px',\n    opacity: 0.6\n  },\n  typing: {\n    display: 'flex',\n    gap: '4px'\n  },\n  error: {\n    padding: '12px',\n    backgroundColor: '#fee',\n    color: '#c00',\n    borderTop: '1px solid #fcc'\n  },\n  inputContainer: {\n    display: 'flex',\n    padding: '16px',\n    backgroundColor: '#f5f5f5',\n    borderTop: '1px solid #ddd',\n    gap: '8px'\n  },\n  input: {\n    flex: 1,\n    padding: '12px',\n    border: '1px solid #ddd',\n    borderRadius: '4px',\n    fontSize: '14px'\n  },\n  button: {\n    padding: '12px 24px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '14px'\n  }\n};\n\nexport default SimpleChat;\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Basic message handling with <code>invoke()</code></li> <li>Managing conversation history</li> <li>Loading and error states</li> <li>UI updates on message submission</li> </ul>"},{"location":"client/react-examples/#2-streaming-chat-component","title":"2. Streaming Chat Component","text":"<p>Real-time streaming chat with visual feedback.</p>"},{"location":"client/react-examples/#features_1","title":"Features","text":"<ul> <li>\u2705 Real-time message streaming</li> <li>\u2705 Typing indicators</li> <li>\u2705 Streaming animation</li> <li>\u2705 Token-by-token display</li> </ul>"},{"location":"client/react-examples/#code_1","title":"Code","text":"<pre><code>// components/StreamingChat.tsx\nimport { useState, useRef, useEffect } from 'react';\nimport { AgentFlowClient, Message, StreamChunk } from 'agentflow-react';\n\ninterface ChatMessage {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  isStreaming?: boolean;\n  timestamp: Date;\n}\n\nexport function StreamingChat() {\n  const [messages, setMessages] = useState&lt;ChatMessage[]&gt;([]);\n  const [input, setInput] = useState('');\n  const [streaming, setStreaming] = useState(false);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);\n  const streamingMessageRef = useRef&lt;string&gt;('');\n\n  const client = useRef(new AgentFlowClient({\n    baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n  })).current;\n\n  useEffect(() =&gt; {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  const sendMessage = async () =&gt; {\n    if (!input.trim() || streaming) return;\n\n    const userMessage: ChatMessage = {\n      id: Date.now().toString(),\n      role: 'user',\n      content: input,\n      timestamp: new Date()\n    };\n\n    setMessages(prev =&gt; [...prev, userMessage]);\n    setInput('');\n    setStreaming(true);\n    setError(null);\n    streamingMessageRef.current = '';\n\n    try {\n      // Prepare messages for API\n      const apiMessages = [...messages, userMessage].map(msg =&gt;\n        Message.text_message(msg.content, msg.role)\n      );\n\n      // Start streaming\n      const stream = client.stream(apiMessages, {\n        response_granularity: 'low'\n      });\n\n      // Add placeholder for streaming message\n      const streamingMsgId = `streaming-${Date.now()}`;\n      setMessages(prev =&gt; [...prev, {\n        id: streamingMsgId,\n        role: 'assistant',\n        content: '',\n        isStreaming: true,\n        timestamp: new Date()\n      }]);\n\n      // Process stream chunks\n      for await (const chunk of stream) {\n        if (chunk.event === 'message' &amp;&amp; chunk.message?.role === 'assistant') {\n          const content = typeof chunk.message.content === 'string'\n            ? chunk.message.content\n            : JSON.stringify(chunk.message.content);\n\n          streamingMessageRef.current = content;\n\n          // Update streaming message\n          setMessages(prev =&gt; prev.map(msg =&gt;\n            msg.id === streamingMsgId\n              ? { ...msg, content, isStreaming: true }\n              : msg\n          ));\n        }\n      }\n\n      // Mark as complete\n      setMessages(prev =&gt; prev.map(msg =&gt;\n        msg.id === streamingMsgId\n          ? { ...msg, isStreaming: false }\n          : msg\n      ));\n\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Streaming failed');\n      console.error('Streaming error:', err);\n    } finally {\n      setStreaming(false);\n    }\n  };\n\n  return (\n    &lt;div style={styles.container}&gt;\n      {/* Header */}\n      &lt;div style={styles.header}&gt;\n        &lt;h2&gt;\ud83c\udf0a Streaming Chat&lt;/h2&gt;\n        {streaming &amp;&amp; &lt;span style={styles.streamingBadge}&gt;\u26a1 Streaming...&lt;/span&gt;}\n      &lt;/div&gt;\n\n      {/* Messages */}\n      &lt;div style={styles.messages}&gt;\n        {messages.map((msg) =&gt; (\n          &lt;div\n            key={msg.id}\n            style={{\n              ...styles.message,\n              ...(msg.role === 'user' ? styles.userMessage : styles.assistantMessage)\n            }}\n          &gt;\n            &lt;div style={styles.messageRole}&gt;\n              {msg.role === 'user' ? '\ud83d\udc64 You' : '\ud83e\udd16 Assistant'}\n            &lt;/div&gt;\n            &lt;div style={styles.messageContent}&gt;\n              {msg.content || (msg.isStreaming &amp;&amp; '\u258b')}\n            &lt;/div&gt;\n            {msg.isStreaming &amp;&amp; (\n              &lt;div style={styles.streamingIndicator}&gt;\n                &lt;span className=\"pulse\"&gt;\u25cf&lt;/span&gt; Generating...\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n        ))}\n        &lt;div ref={messagesEndRef} /&gt;\n      &lt;/div&gt;\n\n      {/* Error */}\n      {error &amp;&amp; &lt;div style={styles.error}&gt;\u26a0\ufe0f {error}&lt;/div&gt;}\n\n      {/* Input */}\n      &lt;div style={styles.inputContainer}&gt;\n        &lt;input\n          type=\"text\"\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyPress={(e) =&gt; e.key === 'Enter' &amp;&amp; sendMessage()}\n          placeholder=\"Type your message...\"\n          disabled={streaming}\n          style={styles.input}\n        /&gt;\n        &lt;button\n          onClick={sendMessage}\n          disabled={streaming || !input.trim()}\n          style={styles.button}\n        &gt;\n          {streaming ? '\u23f3' : '\ud83d\ude80'} Send\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n      {/* Add CSS animation */}\n      &lt;style&gt;{`\n        @keyframes pulse {\n          0%, 100% { opacity: 1; }\n          50% { opacity: 0.3; }\n        }\n        .pulse {\n          animation: pulse 1.5s ease-in-out infinite;\n        }\n      `}&lt;/style&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Styles (reuse from SimpleChat with additions)\nconst styles = {\n  // ... (same as SimpleChat)\n  streamingBadge: {\n    marginLeft: '12px',\n    padding: '4px 12px',\n    backgroundColor: '#4CAF50',\n    color: 'white',\n    borderRadius: '12px',\n    fontSize: '12px',\n    fontWeight: 'bold' as const\n  },\n  streamingIndicator: {\n    fontSize: '11px',\n    marginTop: '8px',\n    color: '#4CAF50',\n    fontStyle: 'italic' as const\n  },\n  // ... rest of styles\n  container: { /* same as SimpleChat */ },\n  header: { /* same as SimpleChat */ },\n  messages: { /* same as SimpleChat */ },\n  message: { /* same as SimpleChat */ },\n  userMessage: { /* same as SimpleChat */ },\n  assistantMessage: { /* same as SimpleChat */ },\n  messageRole: { /* same as SimpleChat */ },\n  messageContent: { /* same as SimpleChat */ },\n  error: { /* same as SimpleChat */ },\n  inputContainer: { /* same as SimpleChat */ },\n  input: { /* same as SimpleChat */ },\n  button: { /* same as SimpleChat */ }\n};\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn_1","title":"What You'll Learn","text":"<ul> <li>Real-time streaming with <code>stream()</code></li> <li>Handling stream chunks</li> <li>Visual streaming indicators</li> <li>Updating UI during streaming</li> </ul>"},{"location":"client/react-examples/#3-dynamic-form-builder","title":"3. Dynamic Form Builder","text":"<p>Generate forms dynamically from state schema.</p>"},{"location":"client/react-examples/#features_2","title":"Features","text":"<ul> <li>\u2705 Auto-generate form fields</li> <li>\u2705 Type-aware inputs</li> <li>\u2705 Validation</li> <li>\u2705 Default values</li> </ul>"},{"location":"client/react-examples/#code_2","title":"Code","text":"<pre><code>// components/DynamicFormBuilder.tsx\nimport { useState, useEffect } from 'react';\nimport { AgentFlowClient, AgentStateSchema, FieldSchema } from 'agentflow-react';\n\nexport function DynamicFormBuilder() {\n  const [schema, setSchema] = useState&lt;AgentStateSchema | null&gt;(null);\n  const [formData, setFormData] = useState&lt;Record&lt;string, any&gt;&gt;({});\n  const [loading, setLoading] = useState(true);\n  const [submitting, setSubmitting] = useState(false);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n\n  const client = new AgentFlowClient({\n    baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n  });\n\n  // Fetch schema on mount\n  useEffect(() =&gt; {\n    fetchSchema();\n  }, []);\n\n  const fetchSchema = async () =&gt; {\n    try {\n      const response = await client.graphStateSchema();\n      setSchema(response.data);\n\n      // Initialize form with default values\n      const defaults: Record&lt;string, any&gt; = {};\n      Object.entries(response.data.properties).forEach(([name, field]) =&gt; {\n        if (field.default !== undefined) {\n          defaults[name] = field.default;\n        }\n      });\n      setFormData(defaults);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load schema');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleChange = (fieldName: string, value: any) =&gt; {\n    setFormData(prev =&gt; ({ ...prev, [fieldName]: value }));\n  };\n\n  const handleSubmit = async (e: React.FormEvent) =&gt; {\n    e.preventDefault();\n    setSubmitting(true);\n\n    try {\n      // Validate required fields\n      if (schema?.required) {\n        for (const field of schema.required) {\n          if (!formData[field]) {\n            throw new Error(`${field} is required`);\n          }\n        }\n      }\n\n      // Submit to API (example: updateThreadState)\n      await client.updateThreadState({\n        thread_id: 'example-thread',\n        state: formData\n      });\n\n      alert('Form submitted successfully!');\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Submission failed');\n    } finally {\n      setSubmitting(false);\n    }\n  };\n\n  const renderField = (name: string, field: FieldSchema) =&gt; {\n    const fieldType = Array.isArray(field.type) ? field.type[0] : field.type;\n    const value = formData[name] ?? field.default ?? '';\n    const isRequired = schema?.required?.includes(name);\n\n    switch (fieldType) {\n      case 'string':\n        return (\n          &lt;input\n            type=\"text\"\n            value={value}\n            onChange={(e) =&gt; handleChange(name, e.target.value)}\n            required={isRequired}\n            style={styles.input}\n          /&gt;\n        );\n\n      case 'number':\n      case 'integer':\n        return (\n          &lt;input\n            type=\"number\"\n            value={value}\n            onChange={(e) =&gt; handleChange(name, parseFloat(e.target.value))}\n            required={isRequired}\n            style={styles.input}\n          /&gt;\n        );\n\n      case 'boolean':\n        return (\n          &lt;input\n            type=\"checkbox\"\n            checked={value}\n            onChange={(e) =&gt; handleChange(name, e.target.checked)}\n            style={styles.checkbox}\n          /&gt;\n        );\n\n      case 'array':\n        return (\n          &lt;textarea\n            value={Array.isArray(value) ? JSON.stringify(value, null, 2) : '[]'}\n            onChange={(e) =&gt; {\n              try {\n                handleChange(name, JSON.parse(e.target.value));\n              } catch {}\n            }}\n            rows={4}\n            style={styles.textarea}\n          /&gt;\n        );\n\n      default:\n        return (\n          &lt;input\n            type=\"text\"\n            value={value}\n            onChange={(e) =&gt; handleChange(name, e.target.value)}\n            style={styles.input}\n          /&gt;\n        );\n    }\n  };\n\n  if (loading) {\n    return &lt;div style={styles.loading}&gt;Loading schema...&lt;/div&gt;;\n  }\n\n  if (error) {\n    return &lt;div style={styles.error}&gt;Error: {error}&lt;/div&gt;;\n  }\n\n  if (!schema) {\n    return &lt;div&gt;No schema available&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div style={styles.container}&gt;\n      &lt;h2&gt;\ud83d\udccb Dynamic Form Builder&lt;/h2&gt;\n      &lt;p style={styles.description}&gt;\n        This form is generated automatically from the AgentState schema\n      &lt;/p&gt;\n\n      &lt;form onSubmit={handleSubmit} style={styles.form}&gt;\n        {Object.entries(schema.properties).map(([name, field]) =&gt; (\n          &lt;div key={name} style={styles.formGroup}&gt;\n            &lt;label style={styles.label}&gt;\n              {field.description || name}\n              {schema.required?.includes(name) &amp;&amp; (\n                &lt;span style={styles.required}&gt; *&lt;/span&gt;\n              )}\n            &lt;/label&gt;\n\n            {field.description &amp;&amp; (\n              &lt;div style={styles.hint}&gt;Type: {field.type}&lt;/div&gt;\n            )}\n\n            {renderField(name, field)}\n\n            {field.default !== undefined &amp;&amp; (\n              &lt;div style={styles.defaultValue}&gt;\n                Default: {JSON.stringify(field.default)}\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n        ))}\n\n        &lt;button\n          type=\"submit\"\n          disabled={submitting}\n          style={styles.submitButton}\n        &gt;\n          {submitting ? 'Submitting...' : 'Submit Form'}\n        &lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  );\n}\n\nconst styles = {\n  container: {\n    maxWidth: '600px',\n    margin: '0 auto',\n    padding: '20px'\n  },\n  description: {\n    color: '#666',\n    marginBottom: '24px'\n  },\n  loading: {\n    textAlign: 'center' as const,\n    padding: '40px',\n    fontSize: '16px'\n  },\n  error: {\n    padding: '16px',\n    backgroundColor: '#fee',\n    color: '#c00',\n    borderRadius: '4px'\n  },\n  form: {\n    display: 'flex',\n    flexDirection: 'column' as const,\n    gap: '20px'\n  },\n  formGroup: {\n    display: 'flex',\n    flexDirection: 'column' as const,\n    gap: '8px'\n  },\n  label: {\n    fontWeight: 'bold' as const,\n    fontSize: '14px'\n  },\n  required: {\n    color: '#c00'\n  },\n  hint: {\n    fontSize: '12px',\n    color: '#999'\n  },\n  input: {\n    padding: '10px',\n    border: '1px solid #ddd',\n    borderRadius: '4px',\n    fontSize: '14px'\n  },\n  textarea: {\n    padding: '10px',\n    border: '1px solid #ddd',\n    borderRadius: '4px',\n    fontSize: '14px',\n    fontFamily: 'monospace'\n  },\n  checkbox: {\n    width: '20px',\n    height: '20px'\n  },\n  defaultValue: {\n    fontSize: '12px',\n    color: '#999',\n    fontStyle: 'italic' as const\n  },\n  submitButton: {\n    padding: '12px 24px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    fontSize: '16px',\n    fontWeight: 'bold' as const,\n    cursor: 'pointer'\n  }\n};\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn_2","title":"What You'll Learn","text":"<ul> <li>Fetching state schema</li> <li>Dynamic form generation</li> <li>Type-aware input rendering</li> <li>Form validation</li> </ul>"},{"location":"client/react-examples/#4-agent-with-tools","title":"4. Agent with Tools","text":"<p>Chat interface with tool execution.</p> <p>\u26a0\ufe0f Important Note: The tools shown in this example are for demonstration purposes. In production: - Use backend tools (defined in your Python agent graph) for most operations - Use remote tools (shown here) ONLY for browser-level APIs like <code>localStorage</code>, <code>navigator.geolocation</code>, etc. - See Tools Guide - When to Use Remote Tools for detailed guidance</p>"},{"location":"client/react-examples/#features_3","title":"Features","text":"<ul> <li>\u2705 Tool registration</li> <li>\u2705 Tool execution feedback</li> <li>\u2705 Multiple tools</li> <li>\u2705 Tool result display</li> </ul>"},{"location":"client/react-examples/#code_3","title":"Code","text":"<pre><code>// components/AgentWithTools.tsx\nimport { useState, useRef, useEffect } from 'react';\nimport { AgentFlowClient, Message } from 'agentflow-react';\n\nexport function AgentWithTools() {\n  const [messages, setMessages] = useState&lt;any[]&gt;([]);\n  const [input, setInput] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [toolsExecuted, setToolsExecuted] = useState&lt;string[]&gt;([]);\n\n  const client = useRef&lt;AgentFlowClient | null&gt;(null);\n\n  useEffect(() =&gt; {\n    // Initialize client and register tools\n    client.current = new AgentFlowClient({\n      baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000',\n      debug: true\n    });\n\n    // Register calculator tool\n    client.current.registerTool({\n      node: 'assistant',\n      name: 'calculator',\n      description: 'Perform mathematical calculations',\n      parameters: {\n        type: 'object',\n        properties: {\n          operation: { type: 'string', enum: ['add', 'subtract', 'multiply', 'divide'] },\n          a: { type: 'number' },\n          b: { type: 'number' }\n        },\n        required: ['operation', 'a', 'b']\n      },\n      handler: async ({ operation, a, b }) =&gt; {\n        console.log(`\ud83d\udd27 Executing calculator: ${operation}(${a}, ${b})`);\n        setToolsExecuted(prev =&gt; [...prev, `calculator: ${operation}(${a}, ${b})`]);\n\n        switch (operation) {\n          case 'add': return { result: a + b };\n          case 'subtract': return { result: a - b };\n          case 'multiply': return { result: a * b };\n          case 'divide': return { result: a / b };\n          default: throw new Error('Invalid operation');\n        }\n      }\n    });\n\n    // Register weather tool\n    client.current.registerTool({\n      node: 'assistant',\n      name: 'get_weather',\n      description: 'Get current weather for a location',\n      parameters: {\n        type: 'object',\n        properties: {\n          location: { type: 'string' }\n        },\n        required: ['location']\n      },\n      handler: async ({ location }) =&gt; {\n        console.log(`\ud83d\udd27 Executing get_weather: ${location}`);\n        setToolsExecuted(prev =&gt; [...prev, `get_weather: ${location}`]);\n\n        // Simulate weather API call\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n        return {\n          location,\n          temperature: Math.floor(Math.random() * 30) + 60,\n          conditions: ['sunny', 'cloudy', 'rainy', 'windy'][Math.floor(Math.random() * 4)],\n          humidity: Math.floor(Math.random() * 40) + 40\n        };\n      }\n    });\n  }, []);\n\n  const sendMessage = async () =&gt; {\n    if (!input.trim() || loading || !client.current) return;\n\n    const userMsg = { role: 'user', content: input };\n    setMessages(prev =&gt; [...prev, userMsg]);\n    setInput('');\n    setLoading(true);\n    setToolsExecuted([]);\n\n    try {\n      const apiMessages = [...messages, userMsg].map(msg =&gt;\n        Message.text_message(msg.content, msg.role)\n      );\n\n      const result = await client.current.invoke(apiMessages, {\n        recursion_limit: 10\n      });\n\n      setMessages(result.messages.map(msg =&gt; ({\n        role: msg.role,\n        content: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content)\n      })));\n    } catch (err) {\n      console.error('Error:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    &lt;div style={styles.container}&gt;\n      &lt;div style={styles.header}&gt;\n        &lt;h2&gt;\ud83d\udd27 Agent with Tools&lt;/h2&gt;\n        &lt;div style={styles.toolBadges}&gt;\n          &lt;span style={styles.badge}&gt;\ud83d\udcca Calculator&lt;/span&gt;\n          &lt;span style={styles.badge}&gt;\ud83c\udf24\ufe0f Weather&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Tool Execution Log */}\n      {toolsExecuted.length &gt; 0 &amp;&amp; (\n        &lt;div style={styles.toolLog}&gt;\n          &lt;strong&gt;\ud83d\udd27 Tools Executed:&lt;/strong&gt;\n          {toolsExecuted.map((tool, idx) =&gt; (\n            &lt;div key={idx} style={styles.toolItem}&gt;{tool}&lt;/div&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n\n      {/* Messages */}\n      &lt;div style={styles.messages}&gt;\n        {messages.length === 0 &amp;&amp; (\n          &lt;div style={styles.emptyState}&gt;\n            Try: \"What's 5 + 3?\" or \"What's the weather in NYC?\"\n          &lt;/div&gt;\n        )}\n\n        {messages.map((msg, idx) =&gt; (\n          &lt;div\n            key={idx}\n            style={{\n              ...styles.message,\n              ...(msg.role === 'user' ? styles.userMessage : styles.assistantMessage)\n            }}\n          &gt;\n            &lt;strong&gt;{msg.role}:&lt;/strong&gt; {msg.content}\n          &lt;/div&gt;\n        ))}\n\n        {loading &amp;&amp; &lt;div style={styles.loading}&gt;\u23f3 Processing (may execute tools)...&lt;/div&gt;}\n      &lt;/div&gt;\n\n      {/* Input */}\n      &lt;div style={styles.inputContainer}&gt;\n        &lt;input\n          type=\"text\"\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyPress={(e) =&gt; e.key === 'Enter' &amp;&amp; sendMessage()}\n          placeholder=\"Ask about math or weather...\"\n          disabled={loading}\n          style={styles.input}\n        /&gt;\n        &lt;button onClick={sendMessage} disabled={loading} style={styles.button}&gt;\n          Send\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nconst styles = {\n  container: { maxWidth: '800px', margin: '0 auto', padding: '20px' },\n  header: { marginBottom: '16px' },\n  toolBadges: { display: 'flex', gap: '8px', marginTop: '8px' },\n  badge: {\n    padding: '4px 12px',\n    backgroundColor: '#e0f7fa',\n    borderRadius: '12px',\n    fontSize: '12px'\n  },\n  toolLog: {\n    padding: '12px',\n    backgroundColor: '#fff3cd',\n    border: '1px solid #ffc107',\n    borderRadius: '4px',\n    marginBottom: '16px',\n    fontSize: '13px'\n  },\n  toolItem: {\n    marginLeft: '16px',\n    marginTop: '4px',\n    fontFamily: 'monospace',\n    fontSize: '12px'\n  },\n  messages: {\n    minHeight: '400px',\n    maxHeight: '400px',\n    overflowY: 'auto' as const,\n    border: '1px solid #ddd',\n    borderRadius: '4px',\n    padding: '16px',\n    marginBottom: '16px'\n  },\n  emptyState: { textAlign: 'center' as const, color: '#999', padding: '40px' },\n  message: {\n    padding: '12px',\n    marginBottom: '12px',\n    borderRadius: '4px'\n  },\n  userMessage: { backgroundColor: '#e3f2fd' },\n  assistantMessage: { backgroundColor: '#f5f5f5' },\n  loading: { textAlign: 'center' as const, color: '#666', padding: '16px' },\n  inputContainer: { display: 'flex', gap: '8px' },\n  input: {\n    flex: 1,\n    padding: '12px',\n    border: '1px solid #ddd',\n    borderRadius: '4px'\n  },\n  button: {\n    padding: '12px 24px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer'\n  }\n};\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn_3","title":"What You'll Learn","text":"<ul> <li>Tool registration</li> <li>Multiple tool types</li> <li>Tool execution tracking</li> <li>Debug logging</li> </ul>"},{"location":"client/react-examples/#5-multi-step-workflow-ui","title":"5. Multi-step Workflow UI","text":"<p>Complex workflow with multiple agent interactions.</p> <pre><code>// components/MultiStepWorkflow.tsx\nimport { useState } from 'react';\nimport { AgentFlowClient, Message } from 'agentflow-react';\n\ntype Step = 'input' | 'processing' | 'review' | 'complete';\n\nexport function MultiStepWorkflow() {\n  const [step, setStep] = useState&lt;Step&gt;('input');\n  const [userInput, setUserInput] = useState('');\n  const [processedData, setProcessedData] = useState&lt;any&gt;(null);\n  const [finalResult, setFinalResult] = useState&lt;string&gt;('');\n\n  const client = new AgentFlowClient({\n    baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n  });\n\n  const handleSubmit = async () =&gt; {\n    setStep('processing');\n\n    try {\n      // Step 1: Process input\n      const result1 = await client.invoke([\n        Message.text_message(`Process this: ${userInput}`, 'user')\n      ]);\n\n      setProcessedData(result1.messages);\n      setStep('review');\n    } catch (err) {\n      console.error(err);\n      setStep('input');\n    }\n  };\n\n  const handleConfirm = async () =&gt; {\n    setStep('processing');\n\n    try {\n      // Step 2: Finalize\n      const result2 = await client.invoke([\n        Message.text_message('Finalize the result', 'user')\n      ]);\n\n      setFinalResult(result2.messages[result2.messages.length - 1]?.content || 'Done!');\n      setStep('complete');\n    } catch (err) {\n      console.error(err);\n      setStep('review');\n    }\n  };\n\n  return (\n    &lt;div style={styles.container}&gt;\n      &lt;h2&gt;\ud83d\udccb Multi-Step Workflow&lt;/h2&gt;\n\n      {/* Progress Bar */}\n      &lt;div style={styles.progressBar}&gt;\n        &lt;div style={{ ...styles.progressStep, ...(step === 'input' &amp;&amp; styles.activeStep) }}&gt;\n          1. Input\n        &lt;/div&gt;\n        &lt;div style={{ ...styles.progressStep, ...(step === 'processing' &amp;&amp; styles.activeStep) }}&gt;\n          2. Processing\n        &lt;/div&gt;\n        &lt;div style={{ ...styles.progressStep, ...(step === 'review' &amp;&amp; styles.activeStep) }}&gt;\n          3. Review\n        &lt;/div&gt;\n        &lt;div style={{ ...styles.progressStep, ...(step === 'complete' &amp;&amp; styles.activeStep) }}&gt;\n          4. Complete\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Step Content */}\n      {step === 'input' &amp;&amp; (\n        &lt;div style={styles.stepContent}&gt;\n          &lt;h3&gt;Step 1: Enter Your Input&lt;/h3&gt;\n          &lt;textarea\n            value={userInput}\n            onChange={(e) =&gt; setUserInput(e.target.value)}\n            placeholder=\"Enter your data...\"\n            rows={6}\n            style={styles.textarea}\n          /&gt;\n          &lt;button onClick={handleSubmit} style={styles.button}&gt;\n            Submit\n          &lt;/button&gt;\n        &lt;/div&gt;\n      )}\n\n      {step === 'processing' &amp;&amp; (\n        &lt;div style={styles.stepContent}&gt;\n          &lt;h3&gt;\u23f3 Processing...&lt;/h3&gt;\n          &lt;div style={styles.spinner}&gt;Loading...&lt;/div&gt;\n        &lt;/div&gt;\n      )}\n\n      {step === 'review' &amp;&amp; (\n        &lt;div style={styles.stepContent}&gt;\n          &lt;h3&gt;Step 3: Review Results&lt;/h3&gt;\n          &lt;pre style={styles.preview}&gt;\n            {JSON.stringify(processedData, null, 2)}\n          &lt;/pre&gt;\n          &lt;div style={styles.buttonGroup}&gt;\n            &lt;button onClick={() =&gt; setStep('input')} style={styles.secondaryButton}&gt;\n              Back\n            &lt;/button&gt;\n            &lt;button onClick={handleConfirm} style={styles.button}&gt;\n              Confirm\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n\n      {step === 'complete' &amp;&amp; (\n        &lt;div style={styles.stepContent}&gt;\n          &lt;h3&gt;\u2705 Complete!&lt;/h3&gt;\n          &lt;div style={styles.result}&gt;{finalResult}&lt;/div&gt;\n          &lt;button onClick={() =&gt; {\n            setStep('input');\n            setUserInput('');\n            setProcessedData(null);\n            setFinalResult('');\n          }} style={styles.button}&gt;\n            Start New Workflow\n          &lt;/button&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n\nconst styles = {\n  container: { maxWidth: '800px', margin: '0 auto', padding: '20px' },\n  progressBar: {\n    display: 'flex',\n    gap: '16px',\n    marginBottom: '32px',\n    justifyContent: 'center'\n  },\n  progressStep: {\n    padding: '12px 24px',\n    backgroundColor: '#f5f5f5',\n    borderRadius: '4px',\n    fontSize: '14px'\n  },\n  activeStep: {\n    backgroundColor: '#007bff',\n    color: 'white',\n    fontWeight: 'bold' as const\n  },\n  stepContent: {\n    padding: '24px',\n    border: '1px solid #ddd',\n    borderRadius: '8px'\n  },\n  textarea: {\n    width: '100%',\n    padding: '12px',\n    border: '1px solid #ddd',\n    borderRadius: '4px',\n    fontSize: '14px',\n    marginBottom: '16px'\n  },\n  preview: {\n    padding: '16px',\n    backgroundColor: '#f5f5f5',\n    borderRadius: '4px',\n    overflow: 'auto',\n    maxHeight: '300px',\n    marginBottom: '16px'\n  },\n  spinner: {\n    textAlign: 'center' as const,\n    padding: '40px'\n  },\n  result: {\n    padding: '16px',\n    backgroundColor: '#d4edda',\n    borderRadius: '4px',\n    marginBottom: '16px'\n  },\n  buttonGroup: {\n    display: 'flex',\n    gap: '12px',\n    justifyContent: 'flex-end'\n  },\n  button: {\n    padding: '12px 24px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer'\n  },\n  secondaryButton: {\n    padding: '12px 24px',\n    backgroundColor: '#6c757d',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer'\n  }\n};\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn_4","title":"What You'll Learn","text":"<ul> <li>Multi-step workflows</li> <li>State management across steps</li> <li>Progress indicators</li> <li>Conditional rendering</li> </ul>"},{"location":"client/react-examples/#6-thread-management-ui","title":"6. Thread Management UI","text":"<p>Manage conversation threads.</p> <pre><code>// components/ThreadManagement.tsx\nimport { useState, useEffect } from 'react';\nimport { AgentFlowClient, Message } from 'agentflow-react';\n\ninterface Thread {\n  id: string;\n  name: string;\n  lastMessage: string;\n  timestamp: Date;\n}\n\nexport function ThreadManagement() {\n  const [threads, setThreads] = useState&lt;Thread[]&gt;([]);\n  const [activeThread, setActiveThread] = useState&lt;string | null&gt;(null);\n  const [messages, setMessages] = useState&lt;any[]&gt;([]);\n  const [input, setInput] = useState('');\n\n  const client = new AgentFlowClient({\n    baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n  });\n\n  const createThread = () =&gt; {\n    const newThread: Thread = {\n      id: `thread-${Date.now()}`,\n      name: `Thread ${threads.length + 1}`,\n      lastMessage: '',\n      timestamp: new Date()\n    };\n    setThreads(prev =&gt; [...prev, newThread]);\n    setActiveThread(newThread.id);\n    setMessages([]);\n  };\n\n  const loadThread = async (threadId: string) =&gt; {\n    setActiveThread(threadId);\n\n    try {\n      const state = await client.threadState({ thread_id: threadId });\n      // Load messages from state\n      setMessages(state.data.context || []);\n    } catch (err) {\n      console.error('Failed to load thread:', err);\n      setMessages([]);\n    }\n  };\n\n  const sendMessage = async () =&gt; {\n    if (!input.trim() || !activeThread) return;\n\n    const userMsg = { role: 'user', content: input };\n    const newMessages = [...messages, userMsg];\n    setMessages(newMessages);\n    setInput('');\n\n    try {\n      const result = await client.invoke(\n        newMessages.map(msg =&gt; Message.text_message(msg.content, msg.role))\n      );\n\n      setMessages(result.messages);\n\n      // Update thread\n      setThreads(prev =&gt; prev.map(thread =&gt;\n        thread.id === activeThread\n          ? {\n              ...thread,\n              lastMessage: input,\n              timestamp: new Date()\n            }\n          : thread\n      ));\n    } catch (err) {\n      console.error('Error:', err);\n    }\n  };\n\n  const deleteThread = (threadId: string) =&gt; {\n    setThreads(prev =&gt; prev.filter(t =&gt; t.id !== threadId));\n    if (activeThread === threadId) {\n      setActiveThread(null);\n      setMessages([]);\n    }\n  };\n\n  return (\n    &lt;div style={styles.container}&gt;\n      {/* Sidebar */}\n      &lt;div style={styles.sidebar}&gt;\n        &lt;div style={styles.sidebarHeader}&gt;\n          &lt;h3&gt;\ud83d\udcac Threads&lt;/h3&gt;\n          &lt;button onClick={createThread} style={styles.newButton}&gt;\n            + New\n          &lt;/button&gt;\n        &lt;/div&gt;\n        &lt;div style={styles.threadList}&gt;\n          {threads.map(thread =&gt; (\n            &lt;div\n              key={thread.id}\n              onClick={() =&gt; loadThread(thread.id)}\n              style={{\n                ...styles.threadItem,\n                ...(activeThread === thread.id &amp;&amp; styles.activeThreadItem)\n              }}\n            &gt;\n              &lt;div style={styles.threadName}&gt;{thread.name}&lt;/div&gt;\n              &lt;div style={styles.threadPreview}&gt;{thread.lastMessage || 'No messages'}&lt;/div&gt;\n              &lt;button\n                onClick={(e) =&gt; {\n                  e.stopPropagation();\n                  deleteThread(thread.id);\n                }}\n                style={styles.deleteButton}\n              &gt;\n                \ud83d\uddd1\ufe0f\n              &lt;/button&gt;\n            &lt;/div&gt;\n          ))}\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Chat Area */}\n      &lt;div style={styles.chatArea}&gt;\n        {activeThread ? (\n          &lt;&gt;\n            &lt;div style={styles.messages}&gt;\n              {messages.map((msg, idx) =&gt; (\n                &lt;div key={idx} style={styles.message}&gt;\n                  &lt;strong&gt;{msg.role}:&lt;/strong&gt; {msg.content}\n                &lt;/div&gt;\n              ))}\n            &lt;/div&gt;\n            &lt;div style={styles.inputContainer}&gt;\n              &lt;input\n                type=\"text\"\n                value={input}\n                onChange={(e) =&gt; setInput(e.target.value)}\n                onKeyPress={(e) =&gt; e.key === 'Enter' &amp;&amp; sendMessage()}\n                placeholder=\"Type a message...\"\n                style={styles.input}\n              /&gt;\n              &lt;button onClick={sendMessage} style={styles.sendButton}&gt;\n                Send\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/&gt;\n        ) : (\n          &lt;div style={styles.emptyState}&gt;\n            \ud83d\udc48 Select a thread or create a new one\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n    height: '600px',\n    border: '1px solid #ddd',\n    borderRadius: '8px',\n    overflow: 'hidden'\n  },\n  sidebar: {\n    width: '250px',\n    borderRight: '1px solid #ddd',\n    display: 'flex',\n    flexDirection: 'column' as const\n  },\n  sidebarHeader: {\n    padding: '16px',\n    borderBottom: '1px solid #ddd',\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center'\n  },\n  newButton: {\n    padding: '6px 12px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '12px'\n  },\n  threadList: {\n    flex: 1,\n    overflowY: 'auto' as const\n  },\n  threadItem: {\n    padding: '12px',\n    borderBottom: '1px solid #f0f0f0',\n    cursor: 'pointer',\n    position: 'relative' as const\n  },\n  activeThreadItem: {\n    backgroundColor: '#e3f2fd'\n  },\n  threadName: {\n    fontWeight: 'bold' as const,\n    marginBottom: '4px'\n  },\n  threadPreview: {\n    fontSize: '12px',\n    color: '#666',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap' as const\n  },\n  deleteButton: {\n    position: 'absolute' as const,\n    top: '12px',\n    right: '12px',\n    background: 'none',\n    border: 'none',\n    cursor: 'pointer',\n    fontSize: '14px'\n  },\n  chatArea: {\n    flex: 1,\n    display: 'flex',\n    flexDirection: 'column' as const\n  },\n  messages: {\n    flex: 1,\n    padding: '16px',\n    overflowY: 'auto' as const\n  },\n  message: {\n    marginBottom: '12px',\n    padding: '8px',\n    backgroundColor: '#f5f5f5',\n    borderRadius: '4px'\n  },\n  emptyState: {\n    flex: 1,\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    color: '#999',\n    fontSize: '16px'\n  },\n  inputContainer: {\n    padding: '16px',\n    borderTop: '1px solid #ddd',\n    display: 'flex',\n    gap: '8px'\n  },\n  input: {\n    flex: 1,\n    padding: '12px',\n    border: '1px solid #ddd',\n    borderRadius: '4px'\n  },\n  sendButton: {\n    padding: '12px 24px',\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer'\n  }\n};\n</code></pre>"},{"location":"client/react-examples/#what-youll-learn_5","title":"What You'll Learn","text":"<ul> <li>Thread management</li> <li>Sidebar navigation</li> <li>State persistence</li> <li>Multi-conversation handling</li> </ul>"},{"location":"client/react-examples/#usage","title":"\ud83c\udfaf Usage","text":"<p>Copy any component into your React project and customize as needed. All components are self-contained and production-ready.</p>"},{"location":"client/react-examples/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>React Integration Guide - Hooks and patterns</li> <li>API Reference - Complete API docs</li> <li>Getting Started - Setup guide</li> </ul> <p>Happy coding! \ud83d\ude80</p>"},{"location":"client/react-integration/","title":"React Integration Guide","text":"<p>This guide shows you how to integrate AgentFlow React into your React applications with best practices, custom hooks, and common patterns.</p>"},{"location":"client/react-integration/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>npm install agentflow-react react\n</code></pre>"},{"location":"client/react-integration/#core-concepts","title":"\ud83c\udfaf Core Concepts","text":""},{"location":"client/react-integration/#client-initialization","title":"Client Initialization","text":"<p>The <code>AgentFlowClient</code> should be initialized once and shared across your application.</p> <p>\u274c Don't create new clients in every component: <pre><code>function MyComponent() {\n  // DON'T DO THIS - creates new client on every render\n  const client = new AgentFlowClient({ baseUrl: 'http://localhost:8000' });\n  // ...\n}\n</code></pre></p> <p>\u2705 Do create client once and reuse: <pre><code>// Option 1: Module-level singleton\n// utils/agentflow.ts\nexport const agentFlowClient = new AgentFlowClient({\n  baseUrl: process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'\n});\n\n// MyComponent.tsx\nimport { agentFlowClient } from './utils/agentflow';\n</code></pre></p>"},{"location":"client/react-integration/#context-provider-pattern","title":"\ud83c\udfd7\ufe0f Context Provider Pattern","text":"<p>The recommended approach is to use React Context to provide the client throughout your app.</p>"},{"location":"client/react-integration/#step-1-create-agentflow-context","title":"Step 1: Create AgentFlow Context","text":"<pre><code>// contexts/AgentFlowContext.tsx\nimport React, { createContext, useContext, ReactNode } from 'react';\nimport { AgentFlowClient } from 'agentflow-react';\n\ninterface AgentFlowContextType {\n  client: AgentFlowClient;\n}\n\nconst AgentFlowContext = createContext&lt;AgentFlowContextType | undefined&gt;(undefined);\n\ninterface AgentFlowProviderProps {\n  children: ReactNode;\n  baseUrl: string;\n  authToken?: string;\n  debug?: boolean;\n}\n\nexport function AgentFlowProvider({\n  children,\n  baseUrl,\n  authToken,\n  debug = false\n}: AgentFlowProviderProps) {\n  // Create client once\n  const client = React.useMemo(\n    () =&gt; new AgentFlowClient({ baseUrl, authToken, debug }),\n    [baseUrl, authToken, debug]\n  );\n\n  return (\n    &lt;AgentFlowContext.Provider value={{ client }}&gt;\n      {children}\n    &lt;/AgentFlowContext.Provider&gt;\n  );\n}\n\nexport function useAgentFlow() {\n  const context = useContext(AgentFlowContext);\n  if (!context) {\n    throw new Error('useAgentFlow must be used within AgentFlowProvider');\n  }\n  return context.client;\n}\n</code></pre>"},{"location":"client/react-integration/#step-2-wrap-your-app","title":"Step 2: Wrap Your App","text":"<pre><code>// App.tsx\nimport { AgentFlowProvider } from './contexts/AgentFlowContext';\n\nfunction App() {\n  return (\n    &lt;AgentFlowProvider\n      baseUrl={process.env.REACT_APP_AGENTFLOW_URL || 'http://localhost:8000'}\n      authToken={process.env.REACT_APP_AUTH_TOKEN}\n      debug={process.env.NODE_ENV === 'development'}\n    &gt;\n      &lt;YourApp /&gt;\n    &lt;/AgentFlowProvider&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#step-3-use-in-components","title":"Step 3: Use in Components","text":"<pre><code>// components/Chat.tsx\nimport { useAgentFlow } from '../contexts/AgentFlowContext';\n\nfunction Chat() {\n  const client = useAgentFlow();\n\n  const sendMessage = async (text: string) =&gt; {\n    const result = await client.invoke([/* ... */]);\n    // ...\n  };\n\n  return &lt;div&gt;{/* ... */}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"client/react-integration/#custom-hooks","title":"\ud83e\ude9d Custom Hooks","text":""},{"location":"client/react-integration/#useinvoke-hook","title":"useInvoke Hook","text":"<p>Manage invoke requests with loading and error states:</p> <pre><code>// hooks/useInvoke.ts\nimport { useState } from 'react';\nimport { Message, InvokeResult } from 'agentflow-react';\nimport { useAgentFlow } from '../contexts/AgentFlowContext';\n\ninterface UseInvokeOptions {\n  recursion_limit?: number;\n  response_granularity?: 'full' | 'partial' | 'low';\n}\n\nexport function useInvoke(options: UseInvokeOptions = {}) {\n  const client = useAgentFlow();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState&lt;Error | null&gt;(null);\n  const [result, setResult] = useState&lt;InvokeResult | null&gt;(null);\n\n  const invoke = async (messages: Message[]) =&gt; {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await client.invoke(messages, options);\n      setResult(response);\n      return response;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const reset = () =&gt; {\n    setResult(null);\n    setError(null);\n    setLoading(false);\n  };\n\n  return {\n    invoke,\n    loading,\n    error,\n    result,\n    reset\n  };\n}\n</code></pre> <p>Usage: <pre><code>function ChatComponent() {\n  const { invoke, loading, error, result } = useInvoke({\n    recursion_limit: 10,\n    response_granularity: 'low'\n  });\n\n  const sendMessage = async (text: string) =&gt; {\n    try {\n      await invoke([Message.text_message(text, 'user')]);\n    } catch (err) {\n      console.error('Failed to send message:', err);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}\n      {error &amp;&amp; &lt;div&gt;Error: {error.message}&lt;/div&gt;}\n      {result &amp;&amp; &lt;div&gt;{/* Display messages */}&lt;/div&gt;}\n    &lt;/div&gt;\n  );\n}\n</code></pre></p>"},{"location":"client/react-integration/#usestream-hook","title":"useStream Hook","text":"<p>Handle streaming responses with real-time updates:</p> <pre><code>// hooks/useStream.ts\nimport { useState, useCallback } from 'react';\nimport { Message, StreamChunk } from 'agentflow-react';\nimport { useAgentFlow } from '../contexts/AgentFlowContext';\n\ninterface UseStreamOptions {\n  onChunk?: (chunk: StreamChunk) =&gt; void;\n  onError?: (error: Error) =&gt; void;\n  onComplete?: () =&gt; void;\n}\n\nexport function useStream(options: UseStreamOptions = {}) {\n  const client = useAgentFlow();\n  const [streaming, setStreaming] = useState(false);\n  const [chunks, setChunks] = useState&lt;StreamChunk[]&gt;([]);\n  const [error, setError] = useState&lt;Error | null&gt;(null);\n\n  const startStream = useCallback(async (messages: Message[]) =&gt; {\n    setStreaming(true);\n    setError(null);\n    setChunks([]);\n\n    try {\n      const stream = client.stream(messages, {\n        response_granularity: 'low'\n      });\n\n      for await (const chunk of stream) {\n        setChunks(prev =&gt; [...prev, chunk]);\n        options.onChunk?.(chunk);\n      }\n\n      options.onComplete?.();\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Stream error');\n      setError(error);\n      options.onError?.(error);\n    } finally {\n      setStreaming(false);\n    }\n  }, [client, options]);\n\n  const reset = useCallback(() =&gt; {\n    setChunks([]);\n    setError(null);\n    setStreaming(false);\n  }, []);\n\n  return {\n    startStream,\n    streaming,\n    chunks,\n    error,\n    reset\n  };\n}\n</code></pre> <p>Usage: <pre><code>function StreamingChat() {\n  const { startStream, streaming, chunks, error } = useStream({\n    onChunk: (chunk) =&gt; console.log('New chunk:', chunk),\n    onComplete: () =&gt; console.log('Stream complete')\n  });\n\n  const sendMessage = (text: string) =&gt; {\n    startStream([Message.text_message(text, 'user')]);\n  };\n\n  const messages = chunks\n    .filter(chunk =&gt; chunk.event === 'message')\n    .map(chunk =&gt; chunk.message)\n    .filter(Boolean);\n\n  return (\n    &lt;div&gt;\n      {messages.map((msg, i) =&gt; (\n        &lt;div key={i}&gt;{msg.content}&lt;/div&gt;\n      ))}\n      {streaming &amp;&amp; &lt;div&gt;Streaming...&lt;/div&gt;}\n      {error &amp;&amp; &lt;div&gt;Error: {error.message}&lt;/div&gt;}\n    &lt;/div&gt;\n  );\n}\n</code></pre></p>"},{"location":"client/react-integration/#usestateschema-hook","title":"useStateSchema Hook","text":"<p>Fetch and cache state schema for form generation:</p> <pre><code>// hooks/useStateSchema.ts\nimport { useState, useEffect } from 'react';\nimport { AgentStateSchema } from 'agentflow-react';\nimport { useAgentFlow } from '../contexts/AgentFlowContext';\n\nexport function useStateSchema() {\n  const client = useAgentFlow();\n  const [schema, setSchema] = useState&lt;AgentStateSchema | null&gt;(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState&lt;Error | null&gt;(null);\n\n  useEffect(() =&gt; {\n    let mounted = true;\n\n    const fetchSchema = async () =&gt; {\n      try {\n        const response = await client.graphStateSchema();\n        if (mounted) {\n          setSchema(response.data);\n        }\n      } catch (err) {\n        if (mounted) {\n          setError(err instanceof Error ? err : new Error('Failed to fetch schema'));\n        }\n      } finally {\n        if (mounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchSchema();\n\n    return () =&gt; {\n      mounted = false;\n    };\n  }, [client]);\n\n  return { schema, loading, error };\n}\n</code></pre> <p>Usage: <pre><code>function DynamicForm() {\n  const { schema, loading, error } = useStateSchema();\n\n  if (loading) return &lt;div&gt;Loading schema...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n  if (!schema) return null;\n\n  return (\n    &lt;form&gt;\n      {Object.entries(schema.properties).map(([name, field]) =&gt; (\n        &lt;div key={name}&gt;\n          &lt;label&gt;{field.description || name}&lt;/label&gt;\n          &lt;input\n            type={field.type === 'number' ? 'number' : 'text'}\n            defaultValue={field.default}\n          /&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/form&gt;\n  );\n}\n</code></pre></p>"},{"location":"client/react-integration/#usemessages-hook","title":"useMessages Hook","text":"<p>Manage conversation message history:</p> <pre><code>// hooks/useMessages.ts\nimport { useState, useCallback } from 'react';\nimport { Message } from 'agentflow-react';\n\nexport function useMessages(initialMessages: Message[] = []) {\n  const [messages, setMessages] = useState&lt;Message[]&gt;(initialMessages);\n\n  const addMessage = useCallback((message: Message) =&gt; {\n    setMessages(prev =&gt; [...prev, message]);\n  }, []);\n\n  const addMessages = useCallback((newMessages: Message[]) =&gt; {\n    setMessages(prev =&gt; [...prev, ...newMessages]);\n  }, []);\n\n  const replaceMessages = useCallback((newMessages: Message[]) =&gt; {\n    setMessages(newMessages);\n  }, []);\n\n  const clearMessages = useCallback(() =&gt; {\n    setMessages([]);\n  }, []);\n\n  const updateLastMessage = useCallback((updater: (msg: Message) =&gt; Message) =&gt; {\n    setMessages(prev =&gt; {\n      if (prev.length === 0) return prev;\n      return [...prev.slice(0, -1), updater(prev[prev.length - 1])];\n    });\n  }, []);\n\n  return {\n    messages,\n    addMessage,\n    addMessages,\n    replaceMessages,\n    clearMessages,\n    updateLastMessage\n  };\n}\n</code></pre> <p>Usage: <pre><code>function Chat() {\n  const { messages, addMessage, replaceMessages } = useMessages();\n  const { invoke } = useInvoke();\n\n  const sendMessage = async (text: string) =&gt; {\n    const userMsg = Message.text_message(text, 'user');\n    addMessage(userMsg);\n\n    const result = await invoke([...messages, userMsg]);\n    replaceMessages(result.messages);\n  };\n\n  return &lt;div&gt;{/* Render messages */}&lt;/div&gt;;\n}\n</code></pre></p>"},{"location":"client/react-integration/#component-patterns","title":"\ud83c\udfa8 Component Patterns","text":""},{"location":"client/react-integration/#loading-states","title":"Loading States","text":"<pre><code>function Chat() {\n  const { invoke, loading } = useInvoke();\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; (\n        &lt;div className=\"loading-indicator\"&gt;\n          &lt;span&gt;Thinking...&lt;/span&gt;\n          &lt;div className=\"spinner\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#error-handling","title":"Error Handling","text":"<pre><code>function Chat() {\n  const { invoke, error } = useInvoke();\n  const [showError, setShowError] = useState(false);\n\n  useEffect(() =&gt; {\n    if (error) {\n      setShowError(true);\n      setTimeout(() =&gt; setShowError(false), 5000);\n    }\n  }, [error]);\n\n  return (\n    &lt;div&gt;\n      {showError &amp;&amp; (\n        &lt;div className=\"error-banner\"&gt;\n          &lt;span&gt;Error: {error?.message}&lt;/span&gt;\n          &lt;button onClick={() =&gt; setShowError(false)}&gt;\u00d7&lt;/button&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#streaming-with-visual-feedback","title":"Streaming with Visual Feedback","text":"<pre><code>function StreamingMessage({ chunk }: { chunk: StreamChunk }) {\n  const [isNew, setIsNew] = useState(true);\n\n  useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; setIsNew(false), 300);\n    return () =&gt; clearTimeout(timer);\n  }, []);\n\n  return (\n    &lt;div className={isNew ? 'message fade-in' : 'message'}&gt;\n      {chunk.message?.content}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#tool-execution-indicator","title":"Tool Execution Indicator","text":"<p>Show when the agent is executing remote tools (client-side only).</p> <p>\u26a0\ufe0f Note: This only applies to remote tools registered client-side. Backend tools (defined in Python) execute on the server and aren't visible here.</p> <pre><code>function Chat() {\n  const { messages } = useMessages();\n  const [executingTools, setExecutingTools] = useState(false);\n\n  useEffect(() =&gt; {\n    // Check if last message contains tool calls\n    const lastMsg = messages[messages.length - 1];\n    const hasToolCalls = lastMsg?.content?.some(\n      (block: any) =&gt; block.type === 'remote_tool_call'\n    );\n    setExecutingTools(hasToolCalls || false);\n  }, [messages]);\n\n  return (\n    &lt;div&gt;\n      {executingTools &amp;&amp; (\n        &lt;div className=\"tool-indicator\"&gt;\n          \ud83d\udd27 Executing tools...\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#authentication","title":"\ud83d\udd10 Authentication","text":""},{"location":"client/react-integration/#token-from-environment","title":"Token from Environment","text":"<pre><code>// AgentFlowProvider with env token\n&lt;AgentFlowProvider\n  baseUrl={process.env.REACT_APP_AGENTFLOW_URL!}\n  authToken={process.env.REACT_APP_AUTH_TOKEN}\n&gt;\n  &lt;App /&gt;\n&lt;/AgentFlowProvider&gt;\n</code></pre>"},{"location":"client/react-integration/#token-from-auth-hook","title":"Token from Auth Hook","text":"<pre><code>function App() {\n  const { token } = useAuth(); // Your auth hook\n\n  return (\n    &lt;AgentFlowProvider\n      baseUrl=\"http://localhost:8000\"\n      authToken={token}\n    &gt;\n      &lt;YourApp /&gt;\n    &lt;/AgentFlowProvider&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#dynamic-token-updates","title":"Dynamic Token Updates","text":"<pre><code>// Context with token updates\nexport function AgentFlowProvider({ children }: { children: ReactNode }) {\n  const { token } = useAuth();\n\n  const client = useMemo(() =&gt; {\n    return new AgentFlowClient({\n      baseUrl: 'http://localhost:8000',\n      authToken: token\n    });\n  }, [token]); // Recreate client when token changes\n\n  return (\n    &lt;AgentFlowContext.Provider value={{ client }}&gt;\n      {children}\n    &lt;/AgentFlowContext.Provider&gt;\n  );\n}\n</code></pre>"},{"location":"client/react-integration/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"client/react-integration/#mock-client-for-tests","title":"Mock Client for Tests","text":"<pre><code>// __mocks__/agentflow-react.ts\nexport class AgentFlowClient {\n  async invoke(messages: any[]) {\n    return {\n      messages: [\n        { role: 'user', content: messages[0].content },\n        { role: 'assistant', content: 'Mocked response' }\n      ],\n      iterations: 1,\n      recursion_limit_reached: false\n    };\n  }\n\n  async *stream(messages: any[]) {\n    yield {\n      event: 'message',\n      message: { role: 'assistant', content: 'Mocked stream' }\n    };\n  }\n\n  registerTool() {}\n}\n</code></pre>"},{"location":"client/react-integration/#test-with-react-testing-library","title":"Test with React Testing Library","text":"<pre><code>import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { AgentFlowProvider } from '../contexts/AgentFlowContext';\nimport Chat from '../components/Chat';\n\njest.mock('agentflow-react');\n\ntest('sends message and displays response', async () =&gt; {\n  render(\n    &lt;AgentFlowProvider baseUrl=\"http://test\"&gt;\n      &lt;Chat /&gt;\n    &lt;/AgentFlowProvider&gt;\n  );\n\n  const input = screen.getByRole('textbox');\n  const button = screen.getByRole('button', { name: /send/i });\n\n  fireEvent.change(input, { target: { value: 'Hello' } });\n  fireEvent.click(button);\n\n  await waitFor(() =&gt; {\n    expect(screen.getByText('Mocked response')).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"client/react-integration/#state-management","title":"\ud83d\udcca State Management","text":""},{"location":"client/react-integration/#with-redux","title":"With Redux","text":"<pre><code>// store/agentflowSlice.ts\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { agentFlowClient } from '../utils/agentflow';\n\nexport const sendMessage = createAsyncThunk(\n  'agentflow/sendMessage',\n  async (messages: Message[]) =&gt; {\n    const response = await agentFlowClient.invoke(messages);\n    return response;\n  }\n);\n\nconst agentflowSlice = createSlice({\n  name: 'agentflow',\n  initialState: { messages: [], loading: false, error: null },\n  reducers: {},\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(sendMessage.pending, (state) =&gt; {\n        state.loading = true;\n      })\n      .addCase(sendMessage.fulfilled, (state, action) =&gt; {\n        state.messages = action.payload.messages;\n        state.loading = false;\n      })\n      .addCase(sendMessage.rejected, (state, action) =&gt; {\n        state.error = action.error.message;\n        state.loading = false;\n      });\n  }\n});\n</code></pre>"},{"location":"client/react-integration/#with-zustand","title":"With Zustand","text":"<pre><code>// store/agentflowStore.ts\nimport create from 'zustand';\nimport { Message } from 'agentflow-react';\nimport { agentFlowClient } from '../utils/agentflow';\n\ninterface AgentFlowStore {\n  messages: Message[];\n  loading: boolean;\n  sendMessage: (text: string) =&gt; Promise&lt;void&gt;;\n}\n\nexport const useAgentFlowStore = create&lt;AgentFlowStore&gt;((set, get) =&gt; ({\n  messages: [],\n  loading: false,\n\n  sendMessage: async (text: string) =&gt; {\n    set({ loading: true });\n\n    const userMsg = Message.text_message(text, 'user');\n    const currentMessages = [...get().messages, userMsg];\n\n    try {\n      const result = await agentFlowClient.invoke(currentMessages);\n      set({ messages: result.messages, loading: false });\n    } catch (error) {\n      console.error(error);\n      set({ loading: false });\n    }\n  }\n}));\n</code></pre>"},{"location":"client/react-integration/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"client/react-integration/#dos","title":"\u2705 Do's","text":"<ol> <li>Use Context Provider - Share client across app</li> <li>Memoize Client - Avoid recreating on every render</li> <li>Handle Loading States - Show feedback during requests</li> <li>Handle Errors - Display user-friendly error messages</li> <li>Type Everything - Use TypeScript for better DX</li> <li>Clean Up Effects - Prevent memory leaks with cleanup</li> <li>Use Custom Hooks - Encapsulate common patterns</li> <li>Test Components - Mock client for unit tests</li> </ol>"},{"location":"client/react-integration/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't Create Multiple Clients - One per app</li> <li>Don't Ignore Errors - Always handle failures</li> <li>Don't Block UI - Use loading states</li> <li>Don't Store Client in State - Use context or memo</li> <li>Don't Forget Cleanup - Cancel pending requests</li> <li>Don't Hard-code URLs - Use environment variables</li> </ol>"},{"location":"client/react-integration/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>React Examples - Complete component examples</li> <li>API Reference - Full API documentation</li> <li>Troubleshooting - Common issues</li> </ul> <p>Need more examples? Check out the React Examples guide for complete working components!</p>"},{"location":"client/state-schema-guide/","title":"State Schema API Guide","text":""},{"location":"client/state-schema-guide/#overview","title":"Overview","text":"<p>The State Schema API (<code>GET /v1/graph:StateSchema</code>) returns the complete JSON Schema definition for the <code>AgentState</code> object. This allows users to programmatically understand:</p> <ul> <li>What fields are available in <code>AgentState</code></li> <li>What type each field expects (string, array, object, number, boolean, etc.)</li> <li>What the default values are for each field</li> <li>Field descriptions and documentation</li> <li>Validation constraints</li> <li>Which fields are required</li> </ul> <p>This enables users to: 1. Build dynamic forms based on the schema 2. Validate data before sending to the API 3. Generate UI components automatically 4. Understand the data structure without reading source code</p>"},{"location":"client/state-schema-guide/#usage","title":"Usage","text":""},{"location":"client/state-schema-guide/#basic-example","title":"Basic Example","text":"<pre><code>import { AgentFlowClient } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token'\n});\n\n// Fetch the complete state schema\nconst schemaResponse = await client.graphStateSchema();\n\n// Access the schema data\nconst schema = schemaResponse.data;\n\nconsole.log('Title:', schema.title);\nconsole.log('Description:', schema.description);\n\n// Iterate through all available fields\nObject.entries(schema.properties).forEach(([fieldName, fieldSchema]) =&gt; {\n  console.log(`Field: ${fieldName}`);\n  console.log(`  Type: ${fieldSchema.type}`);\n  console.log(`  Description: ${fieldSchema.description}`);\n  console.log(`  Default: ${fieldSchema.default}`);\n});\n</code></pre>"},{"location":"client/state-schema-guide/#response-structure","title":"Response Structure","text":"<pre><code>{\n  data: {\n    title: \"AgentState\",\n    description: \"Schema for agent execution state\",\n    type: \"object\",\n    properties: {\n      context: {\n        type: \"array\",\n        description: \"List of context items\",\n        items: { /* item schema */ },\n        default: []\n      },\n      context_summary: {\n        description: \"Summary of context\",\n        anyOf: [{ type: \"string\" }, { type: \"null\" }],\n        default: null\n      },\n      execution_meta: {\n        type: \"object\",\n        description: \"Execution metadata\",\n        properties: {\n          current_node: { type: \"string\" },\n          step: { type: \"integer\" },\n          is_running: { type: \"boolean\" },\n          is_interrupted: { type: \"boolean\" },\n          is_stopped_requested: { type: \"boolean\" }\n        }\n      },\n      // Dynamic fields (example - actual fields depend on server config)\n      cv_text: { type: \"string\", default: \"\", description: \"CV content\" },\n      cid: { type: \"string\", default: \"\", description: \"Candidate ID\" },\n      jd_text: { type: \"string\", default: \"\", description: \"Job description\" },\n      jd_id: { type: \"string\", default: \"\", description: \"Job description ID\" }\n    }\n  },\n  metadata: {\n    request_id: \"req-123\",\n    timestamp: \"2025-10-19T15:50:53.000Z\",\n    message: \"OK\"\n  }\n}\n</code></pre>"},{"location":"client/state-schema-guide/#field-schema-structure","title":"Field Schema Structure","text":"<p>Each field in the <code>properties</code> object follows this structure:</p> <pre><code>interface FieldSchema {\n  // Basic type information\n  type?: string | string[];              // e.g., \"string\", \"array\", \"object\", \"integer\"\n  description?: string;                   // Human-readable field description\n\n  // Default value\n  default?: any;                          // Default value if not provided\n\n  // For array types\n  items?: FieldSchema;                    // Schema for array items\n\n  // For object types\n  properties?: Record&lt;string, FieldSchema&gt;;\n  required?: string[];\n\n  // For complex types\n  anyOf?: any[];                          // \"any of these types\"\n  allOf?: any[];                          // \"all of these must be true\"\n  oneOf?: any[];                          // \"exactly one of these\"\n\n  // Additional constraints\n  enum?: any[];                           // Allowed values\n\n  // Advanced features\n  $ref?: string;                          // Reference to other schema definitions\n  $defs?: Record&lt;string, any&gt;;            // Additional schema definitions\n}\n</code></pre>"},{"location":"client/state-schema-guide/#use-cases","title":"Use Cases","text":""},{"location":"client/state-schema-guide/#1-build-a-dynamic-form","title":"1. Build a Dynamic Form","text":"<pre><code>async function generateFormFields() {\n  const schemaResponse = await client.graphStateSchema();\n  const schema = schemaResponse.data;\n\n  const formFields = [];\n\n  Object.entries(schema.properties).forEach(([fieldName, fieldSchema]) =&gt; {\n    const field = {\n      name: fieldName,\n      type: fieldSchema.type,\n      label: fieldSchema.description || fieldName,\n      default: fieldSchema.default,\n      required: schema.required?.includes(fieldName) || false\n    };\n\n    formFields.push(field);\n  });\n\n  return formFields;\n}\n</code></pre>"},{"location":"client/state-schema-guide/#2-validate-data-before-sending","title":"2. Validate Data Before Sending","text":"<pre><code>function validateAgentState(data: Record&lt;string, any&gt;): {\n  valid: boolean;\n  errors: string[];\n} {\n  const schema = await client.graphStateSchema();\n  const errors = [];\n\n  // Check required fields\n  if (schema.data.required) {\n    for (const field of schema.data.required) {\n      if (!(field in data)) {\n        errors.push(`Missing required field: ${field}`);\n      }\n    }\n  }\n\n  // Check field types\n  Object.entries(data).forEach(([fieldName, value]) =&gt; {\n    const fieldSchema = schema.data.properties[fieldName];\n    if (!fieldSchema) return;\n\n    const expectedType = fieldSchema.type;\n    const actualType = typeof value;\n\n    if (expectedType &amp;&amp; !Array.isArray(expectedType)) {\n      if (expectedType === 'array' &amp;&amp; !Array.isArray(value)) {\n        errors.push(`Field ${fieldName} should be an array`);\n      } else if (expectedType !== actualType &amp;&amp; value !== null) {\n        errors.push(`Field ${fieldName} should be ${expectedType}`);\n      }\n    }\n  });\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n</code></pre>"},{"location":"client/state-schema-guide/#3-display-field-information","title":"3. Display Field Information","text":"<pre><code>async function displayFieldInfo() {\n  const schemaResponse = await client.graphStateSchema();\n  const schema = schemaResponse.data;\n\n  console.log('\ud83d\udccb AgentState Fields:');\n  console.log('\u2550'.repeat(60));\n\n  Object.entries(schema.properties).forEach(([fieldName, fieldSchema]) =&gt; {\n    console.log(`\\n\ud83d\udccc ${fieldName}`);\n    console.log(`   Type: ${fieldSchema.type || 'unknown'}`);\n\n    if (fieldSchema.description) {\n      console.log(`   Description: ${fieldSchema.description}`);\n    }\n\n    if (fieldSchema.default !== undefined) {\n      console.log(`   Default: ${JSON.stringify(fieldSchema.default)}`);\n    }\n\n    if (fieldSchema.enum) {\n      console.log(`   Allowed values: ${fieldSchema.enum.join(', ')}`);\n    }\n  });\n}\n</code></pre>"},{"location":"client/state-schema-guide/#dynamic-fields","title":"Dynamic Fields","text":"<p>The <code>AgentState</code> schema supports dynamic fields beyond the core fields (<code>context</code>, <code>context_summary</code>, <code>execution_meta</code>). Dynamic fields can vary depending on your server configuration.</p> <p>Common dynamic field examples: - <code>cv_text</code>: Candidate CV content - <code>cid</code>: Candidate ID - <code>jd_text</code>: Job description text - <code>jd_id</code>: Job description ID</p> <p>To access dynamic fields:</p> <pre><code>const schema = await client.graphStateSchema();\n\n// Core fields (always present)\nconst contextField = schema.data.properties.context;\nconst executionMetaField = schema.data.properties.execution_meta;\n\n// Dynamic fields (varies by configuration)\nObject.entries(schema.data.properties).forEach(([name, fieldSchema]) =&gt; {\n  // Check if it's a dynamic field\n  if (!['context', 'context_summary', 'execution_meta'].includes(name)) {\n    console.log(`Dynamic field: ${name} (${fieldSchema.type})`);\n  }\n});\n</code></pre>"},{"location":"client/state-schema-guide/#type-definitions","title":"Type Definitions","text":""},{"location":"client/state-schema-guide/#stateschemaresponse","title":"StateSchemaResponse","text":"<pre><code>interface StateSchemaResponse {\n  data: AgentStateSchema;\n  metadata: ResponseMetadata;\n}\n</code></pre>"},{"location":"client/state-schema-guide/#agentstateschema","title":"AgentStateSchema","text":"<pre><code>interface AgentStateSchema {\n  title?: string;\n  description?: string;\n  type?: string;\n  properties: Record&lt;string, FieldSchema&gt;;\n  required?: string[];\n  $defs?: Record&lt;string, any&gt;;\n  [key: string]: any;\n}\n</code></pre>"},{"location":"client/state-schema-guide/#fieldschema","title":"FieldSchema","text":"<pre><code>interface FieldSchema {\n  type?: string | string[];\n  description?: string;\n  default?: any;\n  items?: any;\n  properties?: Record&lt;string, FieldSchema&gt;;\n  required?: string[];\n  enum?: any[];\n  $ref?: string;\n  $defs?: Record&lt;string, any&gt;;\n  anyOf?: any[];\n  allOf?: any[];\n  oneOf?: any[];\n  [key: string]: any;\n}\n</code></pre>"},{"location":"client/state-schema-guide/#error-handling","title":"Error Handling","text":"<pre><code>try {\n  const schema = await client.graphStateSchema();\n  // Use schema\n} catch (error) {\n  if (error instanceof Error) {\n    if (error.message.includes('timeout')) {\n      console.error('Schema fetch timed out');\n    } else if (error.message.includes('HTTP')) {\n      console.error('Server error:', error.message);\n    } else {\n      console.error('Network error:', error.message);\n    }\n  }\n}\n</code></pre>"},{"location":"client/state-schema-guide/#benefits","title":"Benefits","text":"<p>\u2705 Type Safety: Know exactly what fields and types are expected \u2705 Dynamic UI Generation: Create forms automatically from schema \u2705 Data Validation: Validate before sending to server \u2705 Self-Documenting: Schema contains descriptions and defaults \u2705 Extensible: Supports both core and custom/dynamic fields \u2705 Backward Compatible: New fields can be added without breaking clients</p>"},{"location":"client/state-schema-guide/#see-also","title":"See Also","text":"<ul> <li>React Examples - React components using state schema for dynamic forms</li> <li>React Integration - useStateSchema hook for React</li> <li>API Reference - Complete state schema API documentation</li> <li>State Schema Quick Reference - Quick lookup for field types</li> <li>TypeScript Types - Type definitions for state schema</li> <li>Getting Started - Basic state schema usage</li> <li>State Schema Tests - Test examples</li> </ul>"},{"location":"client/stream-quick-ref/","title":"Stream API Quick Reference","text":""},{"location":"client/stream-quick-ref/#installation-setup","title":"Installation &amp; Setup","text":"<pre><code>import { AgentFlowClient, Message } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n    baseUrl: 'http://localhost:8000',\n    authToken: 'your-token',\n    debug: true\n});\n</code></pre>"},{"location":"client/stream-quick-ref/#basic-usage","title":"Basic Usage","text":"<pre><code>// Create messages\nconst messages = [Message.text_message('Hello!', 'user')];\n\n// Stream the response\nconst stream = client.stream(messages);\n\n// Iterate over chunks\nfor await (const chunk of stream) {\n    console.log(chunk);\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#event-handling","title":"Event Handling","text":"<pre><code>for await (const chunk of stream) {\n    switch (chunk.event) {\n        case 'message':\n            console.log('Message:', chunk.message?.content);\n            break;\n        case 'updates':\n            console.log('State updated');\n            break;\n        case 'state':\n            console.log('State:', chunk.state);\n            break;\n        case 'error':\n            console.error('Error:', chunk.data);\n            break;\n    }\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#options","title":"Options","text":"<pre><code>client.stream(messages, {\n    initial_state: {},              // Initial state\n    config: {},                     // Graph config\n    recursion_limit: 25,            // Max iterations\n    response_granularity: 'low'     // 'full' | 'partial' | 'low'\n});\n</code></pre>"},{"location":"client/stream-quick-ref/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    const stream = client.stream(messages);\n    for await (const chunk of stream) {\n        // Process chunk\n    }\n} catch (error) {\n    if (error instanceof Error) {\n        if (error.message.includes('timeout')) {\n            console.error('Timeout');\n        } else {\n            console.error('Error:', error.message);\n        }\n    }\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#collect-all-chunks","title":"Collect All Chunks","text":"<pre><code>const chunks = [];\nfor await (const chunk of client.stream(messages)) {\n    chunks.push(chunk);\n}\nconsole.log('Total chunks:', chunks.length);\n</code></pre>"},{"location":"client/stream-quick-ref/#react-hook","title":"React Hook","text":"<pre><code>function useStream(client: AgentFlowClient) {\n    const [chunks, setChunks] = useState([]);\n    const [loading, setLoading] = useState(false);\n\n    const stream = async (messages: Message[]) =&gt; {\n        setLoading(true);\n        for await (const chunk of client.stream(messages)) {\n            setChunks(prev =&gt; [...prev, chunk]);\n        }\n        setLoading(false);\n    };\n\n    return { chunks, loading, stream };\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#type-imports","title":"Type Imports","text":"<pre><code>import {\n    StreamChunk,\n    StreamEventType,\n    StreamContext,\n    StreamRequest,\n    StreamMetadata\n} from 'agentflow-react';\n</code></pre>"},{"location":"client/stream-quick-ref/#common-patterns","title":"Common Patterns","text":""},{"location":"client/stream-quick-ref/#print-streaming-messages","title":"Print streaming messages","text":"<pre><code>for await (const chunk of stream) {\n    if (chunk.event === 'message' &amp;&amp; chunk.message?.role === 'assistant') {\n        process.stdout.write(chunk.message.content[0]?.text || '');\n    }\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#accumulate-response","title":"Accumulate response","text":"<pre><code>let fullResponse = '';\nfor await (const chunk of stream) {\n    if (chunk.event === 'message') {\n        const text = chunk.message?.content[0]?.text || '';\n        fullResponse += text;\n    }\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#track-progress","title":"Track progress","text":"<pre><code>let count = 0;\nfor await (const chunk of stream) {\n    if (chunk.event === 'message') {\n        count++;\n        console.log(`Message ${count} received`);\n    }\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#timeout-handling","title":"Timeout handling","text":"<pre><code>const timeoutId = setTimeout(() =&gt; {\n    // Handle timeout\n}, 30000);\n\ntry {\n    for await (const chunk of stream) {\n        // Process\n    }\n} finally {\n    clearTimeout(timeoutId);\n}\n</code></pre>"},{"location":"client/stream-quick-ref/#comparison-with-invoke","title":"Comparison with Invoke","text":"<p>Use <code>streamInvoke</code> for: - Chat interfaces - Real-time updates - Large responses - Responsive UIs</p> <p>Use <code>invoke</code> for: - Batch processing - Automatic tool loops - Callback patterns - Full result needed at once</p>"},{"location":"client/stream-quick-ref/#debugging","title":"Debugging","text":"<p>Enable debug logging: <pre><code>const client = new AgentFlowClient({\n    baseUrl: 'http://localhost:8000',\n    debug: true  // Enables console logs\n});\n</code></pre></p> <p>Check chunk events: <pre><code>for await (const chunk of stream) {\n    console.debug('Event:', chunk.event);\n    console.debug('Chunk:', JSON.stringify(chunk, null, 2));\n}\n</code></pre></p>"},{"location":"client/stream-quick-ref/#api-endpoint","title":"API Endpoint","text":"<ul> <li>URL: <code>/v1/graph/stream</code></li> <li>Method: <code>POST</code></li> <li>Format: NDJSON (newline-delimited JSON)</li> <li>Auth: Bearer token (optional)</li> </ul>"},{"location":"client/stream-quick-ref/#configuration-defaults","title":"Configuration Defaults","text":"<ul> <li>Timeout: 5 minutes</li> <li>Recursion limit: 25</li> <li>Response granularity: 'low'</li> <li>Initial state: undefined</li> <li>Config: undefined</li> </ul>"},{"location":"client/stream-quick-ref/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use <code>response_granularity: 'low'</code> for less data</li> <li>Process chunks incrementally</li> <li>Don't store unnecessary chunks</li> <li>Use proper error handling</li> <li>Set appropriate timeout</li> <li>Monitor memory usage</li> </ol>"},{"location":"client/stream-usage/","title":"Stream API - Real-time Streaming from AgentFlow","text":"<p>This document explains how to use the <code>streamInvoke</code> method for real-time streaming responses from the AgentFlow API.</p>"},{"location":"client/stream-usage/#overview","title":"Overview","text":"<p>The <code>streamInvoke</code> method provides real-time streaming of responses from the agent graph using HTTP streaming (NDJSON format). Instead of waiting for the entire response like with <code>invoke</code>, the stream method yields chunks as they arrive from the server, enabling responsive, real-time user interfaces.</p>"},{"location":"client/stream-usage/#key-differences-from-invoke","title":"Key Differences from <code>invoke</code>","text":"Aspect <code>invoke</code> <code>streamInvoke</code> Response Pattern Wait for entire result Yield chunks in real-time Data Structure Single response object Multiple <code>StreamChunk</code> objects Use Case Batch processing Real-time UI updates, chat interfaces Return Type <code>Promise&lt;InvokeResult&gt;</code> <code>AsyncGenerator&lt;StreamChunk&gt;</code> Tool Execution Automatic loop handling Manual handling if needed Memory Usage Higher (loads all data) Lower (processes incrementally) Callback Support Yes (onPartialResult) No (use for-await loop)"},{"location":"client/stream-usage/#architecture","title":"Architecture","text":""},{"location":"client/stream-usage/#flow-diagram","title":"Flow Diagram","text":"<pre><code>Client.stream()\n    \u2193\nEndpoint.stream() [Streaming starts]\n    \u2193\nPOST /v1/graph/stream (HTTP Streaming)\n    \u2193\nReadableStream receives NDJSON chunks\n    \u2193\nParse NDJSON line by line\n    \u2193\nFor each complete line:\n    - Parse JSON to StreamChunk\n    - Yield chunk to generator\n    \u2193\nConsumer receives chunks via for-await loop\n    \u2193\nProcess/render based on event type:\n    - 'message': AI/user message arrived\n    - 'updates': State/context updated\n    - 'state': Graph state changed\n    - 'error': Error occurred\n</code></pre>"},{"location":"client/stream-usage/#stream-chunk-structure","title":"Stream Chunk Structure","text":"<p>Each chunk yielded from the stream has this structure:</p> <pre><code>interface StreamChunk {\n    event: StreamEventType | string;           // Type of event: 'message', 'updates', 'state', 'error'\n    message?: Message | null;                   // For 'message' events\n    state?: AgentState | null;                  // For 'updates'/'state' events\n    data?: any;                                 // For other event data\n    thread_id?: string;                         // Conversation thread ID\n    run_id?: string;                            // Execution run ID\n    metadata?: Record&lt;string, any&gt;;             // Metadata (node, function_name, status, etc.)\n    timestamp?: number;                         // UNIX timestamp\n}\n</code></pre>"},{"location":"client/stream-usage/#stream-event-types","title":"Stream Event Types","text":"<pre><code>enum StreamEventType {\n    MESSAGE = 'message',        // New message from agent or user\n    UPDATES = 'updates',        // State/context updates\n    STATE = 'state',            // State update\n    ERROR = 'error'             // Error occurred\n}\n</code></pre>"},{"location":"client/stream-usage/#usage","title":"Usage","text":""},{"location":"client/stream-usage/#basic-streaming-example","title":"Basic Streaming Example","text":"<pre><code>import { AgentFlowClient, Message } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n    baseUrl: 'http://127.0.0.1:8000',\n    authToken: 'your-token',\n    debug: false\n});\n\n// Create a message\nconst messages = [Message.text_message('Hello, what can you do?', 'user')];\n\n// Stream the response\nconst stream = client.stream(messages, {\n    response_granularity: 'low',\n    recursion_limit: 25\n});\n\n// Iterate over stream chunks\nfor await (const chunk of stream) {\n    console.log('Event:', chunk.event);\n    console.log('Chunk:', chunk);\n\n    switch (chunk.event) {\n        case 'message':\n            // Handle message (could be assistant response or user message)\n            if (chunk.message) {\n                console.log(`[${chunk.message.role}]: ${chunk.message.content}`);\n            }\n            break;\n        case 'updates':\n            // Handle state updates\n            if (chunk.state) {\n                console.log('State updated:', chunk.state);\n            }\n            break;\n        case 'error':\n            // Handle errors\n            console.error('Error:', chunk.data);\n            break;\n    }\n}\n\nconsole.log('Stream completed');\n</code></pre>"},{"location":"client/stream-usage/#react-chat-component-example","title":"React Chat Component Example","text":"<pre><code>import { useEffect, useRef, useState } from 'react';\nimport { AgentFlowClient, Message } from 'agentflow-react';\n\nfunction ChatComponent() {\n    const [messages, setMessages] = useState&lt;Message[]&gt;([]);\n    const [isStreaming, setIsStreaming] = useState(false);\n    const clientRef = useRef&lt;AgentFlowClient&gt;();\n\n    useEffect(() =&gt; {\n        clientRef.current = new AgentFlowClient({\n            baseUrl: 'http://127.0.0.1:8000',\n            debug: false\n        });\n    }, []);\n\n    async function handleSendMessage(text: string) {\n        if (!clientRef.current) return;\n\n        // Add user message\n        const userMsg = Message.text_message(text, 'user');\n        setMessages(prev =&gt; [...prev, userMsg]);\n\n        setIsStreaming(true);\n\n        try {\n            // Create streaming request with all previous messages\n            const stream = clientRef.current.stream(\n                [...messages, userMsg],\n                {\n                    response_granularity: 'low',\n                    recursion_limit: 25\n                }\n            );\n\n            let currentAssistantMessage: Message | null = null;\n\n            for await (const chunk of stream) {\n                if (chunk.event === 'message' &amp;&amp; chunk.message) {\n                    const msg = chunk.message;\n\n                    if (msg.role === 'assistant') {\n                        if (!currentAssistantMessage) {\n                            // New assistant message, add it to state\n                            currentAssistantMessage = msg;\n                            setMessages(prev =&gt; [...prev, msg]);\n                        } else {\n                            // Update existing assistant message\n                            currentAssistantMessage = msg;\n                            setMessages(prev =&gt; {\n                                const updated = [...prev];\n                                updated[updated.length - 1] = msg;\n                                return updated;\n                            });\n                        }\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        } finally {\n            setIsStreaming(false);\n        }\n    }\n\n    return (\n        &lt;div&gt;\n            {messages.map((msg, idx) =&gt; (\n                &lt;div key={idx} className={msg.role}&gt;\n                    {/* Render message content */}\n                &lt;/div&gt;\n            ))}\n            {isStreaming &amp;&amp; &lt;div&gt;Streaming...&lt;/div&gt;}\n        &lt;/div&gt;\n    );\n}\n\nexport default ChatComponent;\n</code></pre>"},{"location":"client/stream-usage/#advanced-stream-with-tool-execution","title":"Advanced: Stream with Tool Execution","text":"<p>For scenarios where the server sends remote tool calls during streaming, you can handle them manually.</p> <p>\u26a0\ufe0f Note: Remote tool calls are only for browser-level APIs. Most tools should be defined in your Python backend. See Tools Guide.</p> <pre><code>import { AgentFlowClient, Message, StreamEventType } from 'agentflow-react';\n\nasync function streamWithToolExecution(client: AgentFlowClient, userMessage: Message) {\n    const stream = client.stream([userMessage], {\n        response_granularity: 'low'\n    });\n\n    const allChunks: any[] = [];\n\n    for await (const chunk of stream) {\n        allChunks.push(chunk);\n\n        if (chunk.event === 'message' &amp;&amp; chunk.message) {\n            const msg = chunk.message;\n\n            // Check if message contains tool calls\n            const hasToolCalls = msg.content?.some(\n                (block: any) =&gt; block.type === 'remote_tool_call'\n            );\n\n            if (hasToolCalls &amp;&amp; client.toolExecutor) {\n                console.log('Tool calls detected in message');\n                // Tool execution would be handled here if needed\n            }\n        }\n    }\n\n    return allChunks;\n}\n</code></pre>"},{"location":"client/stream-usage/#stream-with-error-handling","title":"Stream with Error Handling","text":"<pre><code>async function streamWithErrorHandling(\n    client: AgentFlowClient,\n    messages: Message[]\n) {\n    try {\n        const stream = client.stream(messages, {\n            response_granularity: 'partial',\n            recursion_limit: 25\n        });\n\n        for await (const chunk of stream) {\n            if (chunk.event === 'error') {\n                console.error('Stream error:', chunk.data);\n                // Handle error appropriately\n                break;\n            }\n\n            // Process other events\n            console.log('Received:', chunk.event);\n        }\n    } catch (error) {\n        if (error instanceof Error) {\n            if (error.message.includes('timeout')) {\n                console.error('Stream timeout');\n            } else {\n                console.error('Stream error:', error.message);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"client/stream-usage/#cancelling-a-stream","title":"Cancelling a Stream","text":"<pre><code>async function streamWithCancellation(\n    client: AgentFlowClient,\n    messages: Message[]\n) {\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(() =&gt; abortController.abort(), 30000); // 30s timeout\n\n    try {\n        const stream = client.stream(messages, {\n            response_granularity: 'low'\n        });\n\n        for await (const chunk of stream) {\n            console.log('Chunk:', chunk.event);\n\n            // Cancel after receiving first message\n            if (chunk.event === 'message') {\n                abortController.abort();\n                break;\n            }\n        }\n    } catch (error) {\n        if ((error as Error).name === 'AbortError') {\n            console.log('Stream cancelled');\n        } else {\n            console.error('Error:', error);\n        }\n    } finally {\n        clearTimeout(timeoutId);\n    }\n}\n</code></pre>"},{"location":"client/stream-usage/#configuration-options","title":"Configuration Options","text":"<p>When calling <code>streamInvoke</code>, you can provide options:</p> <pre><code>stream(\n    messages: Message[],\n    options?: {\n        initial_state?: Record&lt;string, any&gt;;      // Initial state for the graph\n        config?: Record&lt;string, any&gt;;             // Graph config\n        recursion_limit?: number;                 // Max iterations (default: 25)\n        response_granularity?: 'full' | 'partial' | 'low';  // Level of detail\n    }\n)\n</code></pre>"},{"location":"client/stream-usage/#response-granularity","title":"Response Granularity","text":"<ul> <li>'full': Complete detailed responses</li> <li>'partial': Intermediate updates during processing</li> <li>'low': Minimal updates, optimized for streaming (recommended)</li> </ul>"},{"location":"client/stream-usage/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Memory Efficient: Stream processes data incrementally without loading entire response into memory</p> </li> <li> <p>Responsive UI: Chunks arrive as soon as they're generated, enabling real-time UI updates</p> </li> <li> <p>Network Streaming: Uses HTTP/1.1 chunked encoding for efficient data transfer</p> </li> <li> <p>NDJSON Format: Each line is a complete JSON object, easily parseable line-by-line</p> </li> </ol>"},{"location":"client/stream-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"client/stream-usage/#update-ui-on-each-message-chunk","title":"Update UI on Each Message Chunk","text":"<pre><code>for await (const chunk of stream) {\n    if (chunk.event === 'message') {\n        updateChatUI(chunk.message);\n    }\n}\n</code></pre>"},{"location":"client/stream-usage/#collect-all-chunks-then-process","title":"Collect All Chunks Then Process","text":"<pre><code>const chunks: StreamChunk[] = [];\nfor await (const chunk of stream) {\n    chunks.push(chunk);\n}\n// Process all chunks at once\nprocessAllChunks(chunks);\n</code></pre>"},{"location":"client/stream-usage/#react-hook-for-streaming","title":"React Hook for Streaming","text":"<pre><code>function useStreamInvoke() {\n    const [chunks, setChunks] = useState&lt;StreamChunk[]&gt;([]);\n    const [isLoading, setIsLoading] = useState(false);\n\n    const startStream = async (\n        client: AgentFlowClient,\n        messages: Message[]\n    ) =&gt; {\n        setIsLoading(true);\n        setChunks([]);\n\n        try {\n            const stream = client.stream(messages);\n            for await (const chunk of stream) {\n                setChunks(prev =&gt; [...prev, chunk]);\n            }\n        } finally {\n            setIsLoading(false);\n        }\n    };\n\n    return { chunks, isLoading, startStream };\n}\n</code></pre>"},{"location":"client/stream-usage/#debugging","title":"Debugging","text":"<p>Enable debug logging to see stream details:</p> <pre><code>const client = new AgentFlowClient({\n    baseUrl: 'http://127.0.0.1:8000',\n    debug: true  // Enables console logging\n});\n\nconst stream = client.stream(messages);\nfor await (const chunk of stream) {\n    // Debug logs will show in console\n}\n</code></pre>"},{"location":"client/stream-usage/#comparison-with-invoke","title":"Comparison with Invoke","text":"<p>Use <code>invoke</code> when: - You need the entire result at once - You want automatic tool execution loop handling - You have callback-based patterns - The response is relatively small</p> <p>Use <code>streamInvoke</code> when: - Building chat/conversational interfaces - You want real-time streaming responses - You need responsive UIs with incremental updates - Handling large responses efficiently - Network bandwidth is a concern - You prefer async generator patterns</p>"},{"location":"client/stream-usage/#api-reference","title":"API Reference","text":""},{"location":"client/stream-usage/#method-signature","title":"Method Signature","text":"<pre><code>stream(\n    messages: Message[],\n    options?: {\n        initial_state?: Record&lt;string, any&gt;;\n        config?: Record&lt;string, any&gt;;\n        recursion_limit?: number;\n        response_granularity?: 'full' | 'partial' | 'low';\n    }\n): AsyncGenerator&lt;StreamChunk, void, unknown&gt;\n</code></pre>"},{"location":"client/stream-usage/#endpoint","title":"Endpoint","text":"<ul> <li>URL: <code>/v1/graph/stream</code></li> <li>Method: <code>POST</code></li> <li>Content-Type: <code>application/json</code></li> <li>Response: <code>application/json</code> (NDJSON format)</li> <li>Streaming: Yes (HTTP/1.1 chunked)</li> </ul>"},{"location":"client/stream-usage/#error-handling","title":"Error Handling","text":"<p>The stream will throw errors for: - Network failures - HTTP errors (non-2xx status) - Timeout (default 5 minutes) - Invalid JSON in stream</p> <p>Wrap in try-catch to handle these gracefully.</p>"},{"location":"client/stream-usage/#migration-from-invoke-to-stream","title":"Migration from Invoke to Stream","text":"<p>If you're using callbacks with <code>invoke</code>:</p> <pre><code>// Before (with invoke)\nawait client.invoke(messages, {\n    onPartialResult: (partial) =&gt; {\n        console.log('Partial:', partial.messages);\n    }\n});\n\n// After (with streamInvoke)\nfor await (const chunk of client.stream(messages)) {\n    if (chunk.event === 'message') {\n        console.log('Message:', chunk.message);\n    }\n}\n</code></pre>"},{"location":"client/stream-usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"client/stream-usage/#stream-stops-without-completion","title":"Stream stops without completion","text":"<p>Check: 1. Network connection 2. Server is running and healthy 3. Authorization token is valid 4. Recursion limit not exceeded</p>"},{"location":"client/stream-usage/#no-chunks-received","title":"No chunks received","text":"<p>Verify: 1. Server is streaming (not hanging) 2. Response format is valid NDJSON 3. Timeout is not too short 4. Initial request is correct</p>"},{"location":"client/stream-usage/#memory-usage-increasing","title":"Memory usage increasing","text":"<p>Ensure: 1. You're not storing all chunks unnecessarily 2. The for-await loop completes properly 3. No infinite loops in chunk processing</p>"},{"location":"client/stream-usage/#examples-repository","title":"Examples Repository","text":"<p>See the <code>examples/</code> directory for complete working examples: - <code>examples/stream-basic.ts</code> - Simple streaming example - <code>examples/stream-react.tsx</code> - React component example - <code>examples/stream-chat.ts</code> - Chat application pattern</p>"},{"location":"client/stream-usage/#see-also","title":"See Also","text":"<ul> <li>React Integration - Using stream in React applications with hooks</li> <li>React Examples - Complete React streaming components</li> <li>Stream Quick Reference - Quick reference for stream events</li> <li>API Reference - Complete stream API documentation</li> <li>Invoke Usage Guide - Alternative synchronous API</li> <li>Tools Guide - Using tools with streaming</li> <li>TypeScript Types - Type definitions for streaming</li> <li>Troubleshooting - Common streaming issues</li> </ul>"},{"location":"client/thread-api/","title":"Thread API Guide","text":"<p>Complete guide to managing conversation threads and messages in AgentFlow.</p>"},{"location":"client/thread-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Thread Lifecycle</li> <li>Thread Operations</li> <li>List Threads</li> <li>Get Thread Details</li> <li>Delete Thread</li> <li>State Management</li> <li>Get Thread State</li> <li>Update Thread State</li> <li>Clear Thread State</li> <li>Message Operations</li> <li>List Messages</li> <li>Get Single Message</li> <li>Add Messages</li> <li>Delete Message</li> <li>Use Cases</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"client/thread-api/#overview","title":"Overview","text":"<p>Threads represent individual conversation sessions in AgentFlow. Each thread maintains its own state, messages, and metadata. Use threads to organize conversations by user, topic, or session.</p>"},{"location":"client/thread-api/#key-concepts","title":"Key Concepts","text":"<ul> <li>Thread: A conversation session with messages and state</li> <li>Thread State: Persistent key-value storage for the thread</li> <li>Messages: Conversation turns (user, assistant, tool, etc.)</li> <li>Metadata: Additional information about the thread</li> </ul>"},{"location":"client/thread-api/#thread-lifecycle","title":"Thread Lifecycle","text":"<pre><code>1. Create Thread (implicit)\n        \u2193\n2. Add Messages / Update State\n        \u2193\n3. Execute Agent (invoke/stream)\n        \u2193\n4. Update State / Add More Messages\n        \u2193\n5. Clear State or Delete Thread\n</code></pre>"},{"location":"client/thread-api/#thread-operations","title":"Thread Operations","text":""},{"location":"client/thread-api/#list-threads","title":"List Threads","text":"<p>Get all threads with optional search and pagination.</p> <p>Signature: <pre><code>threads(options?: ThreadsRequest): Promise&lt;ThreadsResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ThreadsRequest {\n  search?: string;   // Search query to filter threads\n  offset?: number;   // Pagination offset (default: 0)\n  limit?: number;    // Number of results (default: 20)\n}\n</code></pre></p> <p>Returns: <pre><code>interface ThreadsResponse {\n  data: {\n    threads: ThreadItem[];\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface ThreadItem {\n  thread_id: string;\n  thread_name: string | null;\n  user_id: string | null;\n  metadata: Record&lt;string, any&gt; | null;\n  updated_at: string | null;\n  run_id: string | null;\n}\n</code></pre></p> <p>Example: <pre><code>// Get all threads\nconst response = await client.threads();\nconsole.log(`Found ${response.data.threads.length} threads`);\n\nfor (const thread of response.data.threads) {\n  console.log(`${thread.thread_id}: ${thread.thread_name || 'Untitled'}`);\n}\n\n// Search threads\nconst searchResults = await client.threads({\n  search: 'customer support',\n  limit: 10\n});\n\n// Paginate through threads\nconst page1 = await client.threads({ offset: 0, limit: 20 });\nconst page2 = await client.threads({ offset: 20, limit: 20 });\n</code></pre></p>"},{"location":"client/thread-api/#get-thread-details","title":"Get Thread Details","text":"<p>Get detailed information about a specific thread.</p> <p>Signature: <pre><code>threadDetails(threadId: string): Promise&lt;ThreadDetailsResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ThreadDetailsResponse {\n  data: {\n    thread_id: string;\n    thread_name: string | null;\n    user_id: string | null;\n    metadata: Record&lt;string, any&gt; | null;\n    created_at: string | null;\n    updated_at: string | null;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const details = await client.threadDetails('thread_123');\n\nconsole.log('Thread ID:', details.data.thread_id);\nconsole.log('Name:', details.data.thread_name);\nconsole.log('User:', details.data.user_id);\nconsole.log('Created:', details.data.created_at);\nconsole.log('Updated:', details.data.updated_at);\nconsole.log('Metadata:', details.data.metadata);\n</code></pre></p>"},{"location":"client/thread-api/#delete-thread","title":"Delete Thread","text":"<p>Permanently delete a thread and all its associated data.</p> <p>Signature: <pre><code>deleteThread(\n  threadId: string,\n  request?: DeleteThreadRequest\n): Promise&lt;DeleteThreadResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface DeleteThreadRequest {\n  config?: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>Returns: <pre><code>interface DeleteThreadResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>// Delete a thread\nconst response = await client.deleteThread('thread_123');\nconsole.log('Deleted:', response.data.success);\n\n// With config\nawait client.deleteThread('thread_456', {\n  config: {\n    cascade: true  // Delete all related data\n  }\n});\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone. All messages, state, and metadata associated with the thread will be deleted.</p>"},{"location":"client/thread-api/#state-management","title":"State Management","text":""},{"location":"client/thread-api/#get-thread-state","title":"Get Thread State","text":"<p>Retrieve the current state of a thread.</p> <p>Signature: <pre><code>threadState(threadId: string): Promise&lt;ThreadStateResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.threadState('thread_123');\nconst state = response.data.state;\n\nconsole.log('Current state:', state);\nconsole.log('Step:', state.step);\nconsole.log('Progress:', state.progress);\nconsole.log('User data:', state.user_data);\n</code></pre></p> <p>State Schema:</p> <p>To understand available state fields, use the State Schema API:</p> <pre><code>const schema = await client.stateSchema();\nconsole.log('Available fields:', schema.data.fields);\n</code></pre>"},{"location":"client/thread-api/#update-thread-state","title":"Update Thread State","text":"<p>Update specific fields in the thread state.</p> <p>Signature: <pre><code>updateThreadState(\n  threadId: string,\n  request: UpdateThreadStateRequest\n): Promise&lt;UpdateThreadStateResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface UpdateThreadStateRequest {\n  state: Record&lt;string, any&gt;;    // State values to update\n  config?: Record&lt;string, any&gt;;  // Optional configuration\n}\n</code></pre></p> <p>Returns: <pre><code>interface UpdateThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>// Update single field\nawait client.updateThreadState('thread_123', {\n  state: {\n    step: 'processing'\n  }\n});\n\n// Update multiple fields\nawait client.updateThreadState('thread_123', {\n  state: {\n    step: 'completed',\n    progress: 100,\n    result: {\n      success: true,\n      data: { ... }\n    },\n    updated_at: new Date().toISOString()\n  }\n});\n\n// With validation config\nawait client.updateThreadState('thread_123', {\n  state: {\n    user_preference: 'dark_mode'\n  },\n  config: {\n    validate: true,\n    merge: true  // Merge with existing state\n  }\n});\n</code></pre></p> <p>Merge Behavior:</p> <ul> <li>Fields you specify are updated</li> <li>Fields you don't specify remain unchanged</li> <li>To delete a field, set it to <code>null</code></li> </ul> <pre><code>// Existing state: { step: 'init', progress: 0, data: {...} }\n\nawait client.updateThreadState('thread_123', {\n  state: {\n    step: 'processing',\n    progress: 50\n    // 'data' field remains unchanged\n  }\n});\n\n// New state: { step: 'processing', progress: 50, data: {...} }\n</code></pre>"},{"location":"client/thread-api/#clear-thread-state","title":"Clear Thread State","text":"<p>Clear all state data from a thread.</p> <p>Signature: <pre><code>clearThreadState(threadId: string): Promise&lt;ClearThreadStateResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier <p>Returns: <pre><code>interface ClearThreadStateResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.clearThreadState('thread_123');\nconsole.log('State cleared:', response.data.success);\n</code></pre></p> <p>Note: This only clears the state. Messages remain intact. To delete everything, use <code>deleteThread()</code>.</p>"},{"location":"client/thread-api/#message-operations","title":"Message Operations","text":""},{"location":"client/thread-api/#list-messages","title":"List Messages","text":"<p>Get all messages from a thread with pagination.</p> <p>Signature: <pre><code>threadMessages(\n  threadId: string,\n  options?: ThreadMessagesRequest\n): Promise&lt;ThreadMessagesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface ThreadMessagesRequest {\n  offset?: number;  // Pagination offset (default: 0)\n  limit?: number;   // Number of results (default: 20)\n}\n</code></pre></p> <p>Returns: <pre><code>interface ThreadMessagesResponse {\n  data: {\n    messages: Message[];\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>// Get all messages\nconst response = await client.threadMessages('thread_123');\nconsole.log(`Found ${response.data.messages.length} messages`);\n\nfor (const message of response.data.messages) {\n  console.log(`${message.role}: ${JSON.stringify(message.content)}`);\n}\n\n// Paginate messages\nconst recent = await client.threadMessages('thread_123', {\n  offset: 0,\n  limit: 10\n});\n\n// Get older messages\nconst older = await client.threadMessages('thread_123', {\n  offset: 10,\n  limit: 10\n});\n</code></pre></p>"},{"location":"client/thread-api/#get-single-message","title":"Get Single Message","text":"<p>Get a specific message from a thread by ID.</p> <p>Signature: <pre><code>threadMessage(\n  threadId: string,\n  messageId: string\n): Promise&lt;ThreadMessageResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier messageId string Yes Unique message identifier <p>Returns: <pre><code>interface ThreadMessageResponse {\n  data: {\n    message: Message;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.threadMessage('thread_123', 'msg_456');\nconst message = response.data.message;\n\nconsole.log('Role:', message.role);\nconsole.log('Content:', message.content);\n</code></pre></p>"},{"location":"client/thread-api/#add-messages","title":"Add Messages","text":"<p>Add new messages to a thread.</p> <p>Signature: <pre><code>addThreadMessages(\n  threadId: string,\n  request: AddThreadMessagesRequest\n): Promise&lt;AddThreadMessagesResponse&gt;\n</code></pre></p> <p>Parameters: <pre><code>interface AddThreadMessagesRequest {\n  messages: Message[];           // Array of messages to add\n  config?: Record&lt;string, any&gt;;  // Optional configuration\n}\n</code></pre></p> <p>Returns: <pre><code>interface AddThreadMessagesResponse {\n  data: {\n    messages: Message[];\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>import { Message } from 'agentflow-react';\n\n// Add user message\nawait client.addThreadMessages('thread_123', {\n  messages: [\n    Message.text_message('What is the weather today?', 'user')\n  ]\n});\n\n// Add multiple messages\nawait client.addThreadMessages('thread_123', {\n  messages: [\n    Message.text_message('Tell me about your services', 'user'),\n    Message.text_message('We offer three main services: A, B, and C', 'assistant'),\n    Message.text_message('Tell me more about service B', 'user')\n  ]\n});\n\n// Add system message\nawait client.addThreadMessages('thread_123', {\n  messages: [\n    Message.text_message('User preference: concise responses', 'system')\n  ]\n});\n</code></pre></p> <p>Message Types:</p> <pre><code>// User message\nMessage.text_message('User input text', 'user')\n\n// Assistant message\nMessage.text_message('Assistant response', 'assistant')\n\n// System message\nMessage.text_message('System instructions', 'system')\n\n// Tool message\nMessage.tool_message([/* tool result blocks */])\n\n// Message with content blocks\nnew Message('assistant', [\n  new TextBlock('Here is the result:'),\n  new DataBlock('application/json', JSON.stringify({ value: 42 }))\n])\n</code></pre>"},{"location":"client/thread-api/#delete-message","title":"Delete Message","text":"<p>Delete a specific message from a thread.</p> <p>Signature: <pre><code>deleteThreadMessage(\n  threadId: string,\n  messageId: string\n): Promise&lt;DeleteThreadMessageResponse&gt;\n</code></pre></p> <p>Parameters:</p> Parameter Type Required Description threadId string Yes Unique thread identifier messageId string Yes Unique message identifier <p>Returns: <pre><code>interface DeleteThreadMessageResponse {\n  data: {\n    success: boolean;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre></p> <p>Example: <pre><code>const response = await client.deleteThreadMessage('thread_123', 'msg_456');\nconsole.log('Deleted:', response.data.success);\n</code></pre></p> <p>Warning: This operation is permanent and cannot be undone.</p>"},{"location":"client/thread-api/#use-cases","title":"Use Cases","text":""},{"location":"client/thread-api/#1-multi-user-chat-application","title":"1. Multi-User Chat Application","text":"<pre><code>// Create thread for each user session\nasync function initializeUserSession(userId: string) {\n  const threadId = `thread_${userId}_${Date.now()}`;\n\n  // Set initial state\n  await client.updateThreadState(threadId, {\n    state: {\n      user_id: userId,\n      session_start: new Date().toISOString(),\n      step: 'initialized',\n      preferences: {}\n    }\n  });\n\n  // Add welcome message\n  await client.addThreadMessages(threadId, {\n    messages: [\n      Message.text_message('You are a helpful assistant', 'system'),\n      Message.text_message('Hello! How can I help you today?', 'assistant')\n    ]\n  });\n\n  return threadId;\n}\n\n// Handle user message\nasync function handleUserMessage(threadId: string, userInput: string) {\n  // Add user message\n  await client.addThreadMessages(threadId, {\n    messages: [Message.text_message(userInput, 'user')]\n  });\n\n  // Get current state for context\n  const state = await client.threadState(threadId);\n\n  // Execute agent\n  const result = await client.invoke({\n    messages: [Message.text_message(userInput, 'user')],\n    config: {\n      thread_id: threadId,\n      state: state.data.state\n    }\n  });\n\n  // Update state based on result\n  if (result.state) {\n    await client.updateThreadState(threadId, {\n      state: result.state\n    });\n  }\n\n  return result.messages;\n}\n</code></pre>"},{"location":"client/thread-api/#2-workflow-state-machine","title":"2. Workflow State Machine","text":"<pre><code>// Define workflow steps\nenum WorkflowStep {\n  INIT = 'init',\n  GATHERING_INFO = 'gathering_info',\n  PROCESSING = 'processing',\n  REVIEW = 'review',\n  COMPLETED = 'completed'\n}\n\n// Initialize workflow\nasync function startWorkflow(threadId: string) {\n  await client.updateThreadState(threadId, {\n    state: {\n      step: WorkflowStep.INIT,\n      progress: 0,\n      data: {},\n      history: []\n    }\n  });\n}\n\n// Advance workflow\nasync function advanceWorkflow(threadId: string, data: any) {\n  const current = await client.threadState(threadId);\n  const currentStep = current.data.state.step;\n\n  let nextStep: WorkflowStep;\n  let progress: number;\n\n  switch (currentStep) {\n    case WorkflowStep.INIT:\n      nextStep = WorkflowStep.GATHERING_INFO;\n      progress = 25;\n      break;\n    case WorkflowStep.GATHERING_INFO:\n      nextStep = WorkflowStep.PROCESSING;\n      progress = 50;\n      break;\n    case WorkflowStep.PROCESSING:\n      nextStep = WorkflowStep.REVIEW;\n      progress = 75;\n      break;\n    case WorkflowStep.REVIEW:\n      nextStep = WorkflowStep.COMPLETED;\n      progress = 100;\n      break;\n    default:\n      throw new Error('Invalid workflow step');\n  }\n\n  await client.updateThreadState(threadId, {\n    state: {\n      step: nextStep,\n      progress,\n      data: { ...current.data.state.data, ...data },\n      history: [...current.data.state.history, currentStep]\n    }\n  });\n}\n</code></pre>"},{"location":"client/thread-api/#3-conversation-history-export","title":"3. Conversation History Export","text":"<pre><code>async function exportConversation(threadId: string) {\n  // Get thread details\n  const details = await client.threadDetails(threadId);\n\n  // Get all messages\n  const messagesResponse = await client.threadMessages(threadId, {\n    limit: 1000  // Adjust as needed\n  });\n\n  // Get final state\n  const stateResponse = await client.threadState(threadId);\n\n  // Create export\n  const exportData = {\n    thread: {\n      id: details.data.thread_id,\n      name: details.data.thread_name,\n      created: details.data.created_at,\n      updated: details.data.updated_at\n    },\n    messages: messagesResponse.data.messages.map(msg =&gt; ({\n      role: msg.role,\n      content: msg.content,\n      timestamp: msg.timestamp || null\n    })),\n    state: stateResponse.data.state,\n    exported_at: new Date().toISOString()\n  };\n\n  return exportData;\n}\n</code></pre>"},{"location":"client/thread-api/#4-thread-cleanup-service","title":"4. Thread Cleanup Service","text":"<pre><code>async function cleanupOldThreads(daysOld: number = 30) {\n  // Get all threads\n  const threads = await client.threads({ limit: 1000 });\n\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n  const deletedThreads: string[] = [];\n\n  for (const thread of threads.data.threads) {\n    if (thread.updated_at) {\n      const updatedDate = new Date(thread.updated_at);\n\n      if (updatedDate &lt; cutoffDate) {\n        try {\n          await client.deleteThread(thread.thread_id);\n          deletedThreads.push(thread.thread_id);\n          console.log(`Deleted old thread: ${thread.thread_id}`);\n        } catch (error) {\n          console.error(`Failed to delete ${thread.thread_id}:`, error);\n        }\n      }\n    }\n  }\n\n  console.log(`Cleaned up ${deletedThreads.length} old threads`);\n  return deletedThreads;\n}\n</code></pre>"},{"location":"client/thread-api/#best-practices","title":"Best Practices","text":""},{"location":"client/thread-api/#1-use-descriptive-thread-names","title":"1. Use Descriptive Thread Names","text":"<pre><code>// \u2705 Good: Descriptive names\nconst threadId = await createThread('Customer Support - Order #12345');\nconst threadId = await createThread('User: john@example.com - Account Setup');\n\n// \u274c Bad: No name or unclear\nconst threadId = await createThread('Thread 1');\nconst threadId = await createThread('test');\n</code></pre>"},{"location":"client/thread-api/#2-initialize-state-early","title":"2. Initialize State Early","text":"<pre><code>// \u2705 Good: Initialize state when creating thread\nasync function createThread(userId: string, purpose: string) {\n  const threadId = generateThreadId();\n\n  await client.updateThreadState(threadId, {\n    state: {\n      user_id: userId,\n      purpose: purpose,\n      created_at: new Date().toISOString(),\n      step: 'initialized',\n      data: {}\n    }\n  });\n\n  return threadId;\n}\n</code></pre>"},{"location":"client/thread-api/#3-clean-state-for-long-running-threads","title":"3. Clean State for Long-Running Threads","text":"<pre><code>// Clear state periodically for long conversations\nasync function resetThreadState(threadId: string, keepFields: string[] = []) {\n  const current = await client.threadState(threadId);\n  const preserved: Record&lt;string, any&gt; = {};\n\n  for (const field of keepFields) {\n    if (current.data.state[field] !== undefined) {\n      preserved[field] = current.data.state[field];\n    }\n  }\n\n  await client.clearThreadState(threadId);\n\n  if (Object.keys(preserved).length &gt; 0) {\n    await client.updateThreadState(threadId, { state: preserved });\n  }\n}\n\n// Usage\nawait resetThreadState('thread_123', ['user_id', 'preferences']);\n</code></pre>"},{"location":"client/thread-api/#4-handle-not-found-gracefully","title":"4. Handle Not Found Gracefully","text":"<pre><code>import { NotFoundError } from 'agentflow-react';\n\nasync function getOrCreateThread(threadId: string, userId: string) {\n  try {\n    const details = await client.threadDetails(threadId);\n    return threadId;\n  } catch (error) {\n    if (error instanceof NotFoundError) {\n      // Thread doesn't exist, create it\n      await client.updateThreadState(threadId, {\n        state: {\n          user_id: userId,\n          created_at: new Date().toISOString()\n        }\n      });\n      return threadId;\n    }\n    throw error;\n  }\n}\n</code></pre>"},{"location":"client/thread-api/#5-paginate-large-message-lists","title":"5. Paginate Large Message Lists","text":"<pre><code>// \u2705 Good: Paginate for large conversations\nasync function getAllMessages(threadId: string): Promise&lt;Message[]&gt; {\n  const allMessages: Message[] = [];\n  let offset = 0;\n  const limit = 100;\n\n  while (true) {\n    const response = await client.threadMessages(threadId, {\n      offset,\n      limit\n    });\n\n    allMessages.push(...response.data.messages);\n\n    if (response.data.messages.length &lt; limit) {\n      break;  // No more messages\n    }\n\n    offset += limit;\n  }\n\n  return allMessages;\n}\n</code></pre>"},{"location":"client/thread-api/#6-store-metadata-in-state","title":"6. Store Metadata in State","text":"<pre><code>// \u2705 Good: Use state for thread metadata\nawait client.updateThreadState(threadId, {\n  state: {\n    user_id: 'user_123',\n    session_start: new Date().toISOString(),\n    user_agent: navigator.userAgent,\n    language: 'en-US',\n    timezone: 'America/New_York',\n    metadata: {\n      source: 'web_chat',\n      campaign: 'summer_2024'\n    }\n  }\n});\n</code></pre>"},{"location":"client/thread-api/#error-handling","title":"Error Handling","text":"<p>All thread operations may throw errors. See Error Handling Guide for details.</p> <pre><code>import {\n  NotFoundError,\n  ValidationError,\n  PermissionError\n} from 'agentflow-react';\n\ntry {\n  await client.threadDetails('thread_123');\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    console.log('Thread not found');\n  } else if (error instanceof ValidationError) {\n    console.log('Invalid thread ID format');\n  } else if (error instanceof PermissionError) {\n    console.log('No permission to access thread');\n  }\n}\n</code></pre>"},{"location":"client/thread-api/#complete-example","title":"Complete Example","text":"<pre><code>import {\n  AgentFlowClient,\n  Message,\n  NotFoundError\n} from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token'\n});\n\nasync function conversationExample() {\n  const threadId = 'thread_example_123';\n\n  try {\n    // 1. Check if thread exists\n    try {\n      await client.threadDetails(threadId);\n      console.log('Thread exists');\n    } catch (error) {\n      if (error instanceof NotFoundError) {\n        // Initialize new thread\n        await client.updateThreadState(threadId, {\n          state: {\n            user_id: 'user_123',\n            created_at: new Date().toISOString(),\n            step: 'init',\n            message_count: 0\n          }\n        });\n        console.log('Created new thread');\n      }\n    }\n\n    // 2. Add messages\n    await client.addThreadMessages(threadId, {\n      messages: [\n        Message.text_message('Hello, I need help', 'user')\n      ]\n    });\n\n    // 3. Get current state\n    const state = await client.threadState(threadId);\n    console.log('Current state:', state.data.state);\n\n    // 4. Execute agent (simplified)\n    const result = await client.invoke({\n      messages: [Message.text_message('Hello, I need help', 'user')],\n      config: { thread_id: threadId }\n    });\n\n    // 5. Update state\n    await client.updateThreadState(threadId, {\n      state: {\n        message_count: state.data.state.message_count + 1,\n        last_message: new Date().toISOString()\n      }\n    });\n\n    // 6. Get all messages\n    const messages = await client.threadMessages(threadId);\n    console.log(`Thread has ${messages.data.messages.length} messages`);\n\n    // 7. Export conversation\n    const exported = await exportConversation(threadId);\n    console.log('Exported:', exported);\n\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\nconversationExample();\n</code></pre>"},{"location":"client/thread-api/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>State Schema Guide - Understanding state schema</li> <li>Error Handling Guide - Error handling patterns</li> <li>Quick Start Guide - Getting started guide</li> </ul>"},{"location":"client/tools-guide/","title":"Tools Guide","text":"<p>Complete guide to tool registration, execution, and best practices in agentflow-react.</p>"},{"location":"client/tools-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What Are Tools?</li> <li>When to Use Tools</li> <li>Tool Registration</li> <li>Tool Parameters</li> <li>Tool Execution Flow</li> <li>Error Handling</li> <li>Common Tool Patterns</li> <li>Advanced Topics</li> <li>Testing Tools</li> <li>Best Practices</li> </ul>"},{"location":"client/tools-guide/#what-are-tools","title":"What Are Tools?","text":"<p>Tools are functions that your agent can call to perform actions or retrieve information. They extend the agent's capabilities beyond text generation, enabling it to:</p> <ul> <li>\ud83c\udf24\ufe0f Fetch real-time data (weather, stock prices, news)</li> <li>\ud83d\udd22 Perform calculations</li> <li>\ud83d\udcbe Query databases</li> <li>\ud83d\udcc1 Read/write files</li> <li>\ud83c\udf10 Call external APIs</li> <li>\ud83d\udd0d Search knowledge bases</li> <li>\u2709\ufe0f Send emails or notifications</li> <li>\ud83e\udd16 Control external systems</li> </ul>"},{"location":"client/tools-guide/#how-tools-work","title":"How Tools Work","text":"<ol> <li>Agent decides to use a tool based on user input</li> <li>API returns a <code>remote_tool_call</code> block with function name and arguments</li> <li>Client executes the tool locally using your registered handler</li> <li>Client sends the tool result back to the API</li> <li>Agent processes the result and continues the conversation</li> </ol> <p>Key Concept: Tools run on the client side, not on the server. This gives you full control over what actions the agent can perform and keeps sensitive operations secure.</p>"},{"location":"client/tools-guide/#when-to-use-tools","title":"When to Use Tools","text":""},{"location":"client/tools-guide/#remote-tools-vs-backend-tools","title":"Remote Tools vs Backend Tools","text":"<p>IMPORTANT: AgentFlow supports two types of tools:</p> <ol> <li>Backend Tools (Defined in Python AgentFlow library)</li> <li>\u2705 PREFERRED for most use cases</li> <li>Run on the server side as part of your agent graph</li> <li>More secure, efficient, and easier to manage</li> <li>Full access to server resources and databases</li> <li> <p>Better performance (no network round-trips for tool execution)</p> </li> <li> <p>Remote Tools (Defined in this client library)</p> </li> <li>\u26a0\ufe0f ONLY use when you need browser-level APIs</li> <li>Run on the client side (browser or Node.js)</li> <li>Required for: Browser APIs, client-side storage, DOM manipulation, WebRTC, etc.</li> <li>Example use cases: <code>localStorage</code>, <code>navigator.geolocation</code>, file uploads from user device</li> </ol> <p>Rule of Thumb: If your tool doesn't need browser-specific APIs, define it as a backend tool in your Python agent graph instead.</p>"},{"location":"client/tools-guide/#use-remote-tools-when-you-need-to","title":"\u2705 Use Remote Tools When You Need To:","text":"<ul> <li>Access browser-only APIs (localStorage, sessionStorage, IndexedDB)</li> <li>Get client device information (navigator.geolocation, navigator.mediaDevices)</li> <li>Manipulate the DOM directly from the agent</li> <li>Handle file uploads from the user's device</li> <li>Use WebRTC or other browser-specific features</li> <li>Access client-side state that exists only in the browser</li> </ul>"},{"location":"client/tools-guide/#dont-use-remote-tools-for","title":"\u274c Don't Use Remote Tools For:","text":"<ul> <li>Server-side operations (use backend tools instead)</li> <li>Database queries (should be backend tools)</li> <li>External API calls (better as backend tools for security)</li> <li>Simple calculations (the agent can do these or use backend tools)</li> <li>File system operations on the server (use backend tools)</li> <li>Authentication and authorization (must be backend tools)</li> </ul>"},{"location":"client/tools-guide/#backend-tools-preferred","title":"Backend Tools (Preferred)","text":"<p>For most use cases, define your tools in the Python AgentFlow library as part of your agent graph:</p> <pre><code># Python backend - PREFERRED APPROACH\nfrom agentflow import tool\n\n@tool\ndef get_weather(location: str) -&gt; dict:\n    \"\"\"Get current weather for a location\"\"\"\n    # This runs on your server with full access to your infrastructure\n    return fetch_weather_from_api(location)\n</code></pre>"},{"location":"client/tools-guide/#remote-tools-client-side-only","title":"Remote Tools (Client-side only)","text":"<p>Only use remote tools when you need browser APIs:</p> <pre><code>// JavaScript client - ONLY for browser APIs\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_user_location',\n  description: 'Get user location from browser',\n  handler: async () =&gt; {\n    // This MUST run in the browser\n    return new Promise((resolve, reject) =&gt; {\n      navigator.geolocation.getCurrentPosition(\n        (position) =&gt; resolve({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude\n        }),\n        (error) =&gt; reject(error)\n      );\n    });\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#example-decision-tree","title":"Example Decision Tree","text":"<pre><code>User: \"What's the weather in Paris?\"\n  \u2514\u2500&gt; \u2705 USE TOOL: Need real-time data\n\nUser: \"Explain how weather works\"\n  \u2514\u2500&gt; \u274c NO TOOL: Agent can explain directly\n\nUser: \"Calculate 5432 * 8976\"\n  \u2514\u2500&gt; \u2705 USE TOOL: Precise calculation needed\n\nUser: \"What's roughly 5000 times 9000?\"\n  \u2514\u2500&gt; \u274c NO TOOL: Agent can estimate\n\nUser: \"Save this to my database\"\n  \u2514\u2500&gt; \u2705 USE TOOL: External system interaction\n</code></pre>"},{"location":"client/tools-guide/#tool-registration","title":"Tool Registration","text":""},{"location":"client/tools-guide/#basic-registration","title":"Basic Registration","text":"<p>Register tools with the <code>registerTool()</code> method before calling <code>invoke()</code> or <code>stream()</code>:</p> <pre><code>import { AgentFlowClient } from 'agentflow-react';\n\nconst client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token'\n});\n\nclient.registerTool({\n  node: 'my_agent_node',           // Node name from your agent graph\n  name: 'get_current_time',        // Unique function name\n  description: 'Get the current time in a specific timezone',\n  parameters: {\n    type: 'object',\n    properties: {\n      timezone: {\n        type: 'string',\n        description: 'IANA timezone (e.g., America/New_York)'\n      }\n    },\n    required: ['timezone']\n  },\n  handler: async (args) =&gt; {\n    const date = new Date();\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone: args.timezone,\n      dateStyle: 'full',\n      timeStyle: 'long'\n    });\n    return { time: formatter.format(date) };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#multiple-tools","title":"Multiple Tools","text":"<p>Register as many tools as needed:</p> <pre><code>// Tool 1: Weather\nclient.registerTool({\n  node: 'assistant_node',\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: { type: 'string', description: 'City name or ZIP code' }\n    },\n    required: ['location']\n  },\n  handler: async (args) =&gt; {\n    const weather = await fetchWeatherAPI(args.location);\n    return { temp: weather.temp, condition: weather.condition };\n  }\n});\n\n// Tool 2: Calculator\nclient.registerTool({\n  node: 'assistant_node',\n  name: 'calculate',\n  description: 'Perform mathematical calculations',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: { \n        type: 'string', \n        description: 'Math expression (e.g., \"2 + 2\" or \"sqrt(16)\")'\n      }\n    },\n    required: ['expression']\n  },\n  handler: async (args) =&gt; {\n    // Use a safe math parser in production\n    const result = evaluateMathExpression(args.expression);\n    return { result };\n  }\n});\n\n// Tool 3: Database Query\nclient.registerTool({\n  node: 'assistant_node',\n  name: 'search_products',\n  description: 'Search product database',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: { type: 'string', description: 'Search query' },\n      limit: { type: 'number', description: 'Max results', default: 10 }\n    },\n    required: ['query']\n  },\n  handler: async (args) =&gt; {\n    const products = await db.products.search(args.query, args.limit);\n    return { products };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#tool-registration-object","title":"Tool Registration Object","text":"<pre><code>interface ToolRegistration {\n  node: string;              // Node name from your agent graph (required)\n  name: string;              // Unique function name (required)\n  description?: string;      // What the tool does (helps agent decide when to use it)\n  parameters?: {             // OpenAI-compatible parameter schema\n    type: 'object';\n    properties: Record&lt;string, any&gt;;\n    required: string[];\n  };\n  handler: (args: any) =&gt; Promise&lt;any&gt;;  // Async function that executes the tool\n}\n</code></pre>"},{"location":"client/tools-guide/#tool-parameters","title":"Tool Parameters","text":"<p>Tool parameters use the OpenAI function-calling schema (JSON Schema format).</p>"},{"location":"client/tools-guide/#parameter-schema-structure","title":"Parameter Schema Structure","text":"<pre><code>parameters: {\n  type: 'object',              // Always 'object' for tool parameters\n  properties: {\n    // Define each parameter here\n    parameterName: {\n      type: 'string' | 'number' | 'boolean' | 'array' | 'object',\n      description: 'What this parameter is for',\n      // ... additional validation rules\n    }\n  },\n  required: ['param1', 'param2']  // List of required parameters\n}\n</code></pre>"},{"location":"client/tools-guide/#parameter-types","title":"Parameter Types","text":""},{"location":"client/tools-guide/#string-parameters","title":"String Parameters","text":"<pre><code>location: {\n  type: 'string',\n  description: 'City name or ZIP code',\n  enum: ['New York', 'London', 'Tokyo'],  // Optional: restrict to specific values\n  pattern: '^[0-9]{5}$'                    // Optional: regex pattern\n}\n</code></pre>"},{"location":"client/tools-guide/#number-parameters","title":"Number Parameters","text":"<pre><code>temperature: {\n  type: 'number',\n  description: 'Temperature in Celsius',\n  minimum: -273.15,       // Optional: minimum value\n  maximum: 100,           // Optional: maximum value\n  default: 20             // Optional: default value\n}\n</code></pre>"},{"location":"client/tools-guide/#boolean-parameters","title":"Boolean Parameters","text":"<pre><code>includeDetails: {\n  type: 'boolean',\n  description: 'Include detailed information',\n  default: false\n}\n</code></pre>"},{"location":"client/tools-guide/#array-parameters","title":"Array Parameters","text":"<pre><code>tags: {\n  type: 'array',\n  description: 'List of tags to filter by',\n  items: {\n    type: 'string'        // Type of array elements\n  },\n  minItems: 1,            // Optional: minimum array length\n  maxItems: 10            // Optional: maximum array length\n}\n</code></pre>"},{"location":"client/tools-guide/#object-parameters","title":"Object Parameters","text":"<pre><code>filters: {\n  type: 'object',\n  description: 'Search filters',\n  properties: {\n    category: { type: 'string' },\n    minPrice: { type: 'number' },\n    maxPrice: { type: 'number' }\n  },\n  required: ['category']\n}\n</code></pre>"},{"location":"client/tools-guide/#complete-example","title":"Complete Example","text":"<pre><code>client.registerTool({\n  node: 'search_node',\n  name: 'advanced_search',\n  description: 'Search with filters and options',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: {\n        type: 'string',\n        description: 'Search query'\n      },\n      filters: {\n        type: 'object',\n        description: 'Search filters',\n        properties: {\n          category: { \n            type: 'string',\n            enum: ['electronics', 'books', 'clothing']\n          },\n          minPrice: { type: 'number', minimum: 0 },\n          maxPrice: { type: 'number', minimum: 0 },\n          inStock: { type: 'boolean', default: true }\n        }\n      },\n      sort: {\n        type: 'string',\n        enum: ['relevance', 'price_asc', 'price_desc', 'rating'],\n        default: 'relevance'\n      },\n      limit: {\n        type: 'number',\n        minimum: 1,\n        maximum: 100,\n        default: 20\n      }\n    },\n    required: ['query']\n  },\n  handler: async (args) =&gt; {\n    // Implementation\n    return await searchWithFilters(args);\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#tool-execution-flow","title":"Tool Execution Flow","text":""},{"location":"client/tools-guide/#automatic-tool-loop-invoke","title":"Automatic Tool Loop (invoke)","text":"<p>When using <code>invoke()</code>, the client automatically handles the tool execution loop:</p> <pre><code>const result = await client.invoke({\n  messages: [Message.text_message(\"What's the weather in Tokyo?\", 'user')],\n  recursion_limit: 10  // Max tool execution iterations\n});\n\n// Behind the scenes:\n// 1. Client sends message to API\n// 2. API returns: \"I need to call get_weather tool\"\n// 3. Client executes get_weather('Tokyo') locally\n// 4. Client sends tool result back to API\n// 5. API processes result and generates response\n// 6. Client returns final response to you\n</code></pre> <p>Flow Diagram:</p> <pre><code>User Input\n    \u2193\nAPI Request\n    \u2193\nAPI Response (with remote_tool_call)\n    \u2193\nExecute Tool Locally \u2190 Your handler runs here\n    \u2193\nSend Tool Result\n    \u2193\nAPI Processes Result\n    \u2193\nFinal Response\n</code></pre>"},{"location":"client/tools-guide/#manual-tool-loop-stream","title":"Manual Tool Loop (stream)","text":"<p>With <code>stream()</code>, you're responsible for the tool loop:</p> <pre><code>import { Message } from 'agentflow-react';\n\nlet messages = [Message.text_message(\"What's the weather in Tokyo?\", 'user')];\nlet continueLoop = true;\nlet iterations = 0;\nconst maxIterations = 10;\n\nwhile (continueLoop &amp;&amp; iterations &lt; maxIterations) {\n  continueLoop = false;\n  const collectedMessages: Message[] = [];\n\n  // Stream the response\n  for await (const chunk of client.stream({ messages })) {\n    if (chunk.event === 'messages_chunk') {\n      // Collect message chunks\n      // ... (accumulate messages)\n    }\n  }\n\n  // Check for tool calls\n  const toolCalls = extractToolCalls(collectedMessages);\n\n  if (toolCalls.length &gt; 0) {\n    // Execute tools\n    const toolResults = await executeTools(toolCalls);\n\n    // Add results to messages\n    messages = [...messages, ...collectedMessages, ...toolResults];\n\n    // Continue the loop\n    continueLoop = true;\n    iterations++;\n  }\n}\n</code></pre> <p>See: Stream Usage Guide for complete streaming examples.</p>"},{"location":"client/tools-guide/#recursion-limit","title":"Recursion Limit","text":"<p>The <code>recursion_limit</code> parameter prevents infinite tool loops:</p> <pre><code>const result = await client.invoke({\n  messages: [Message.text_message(\"Keep calculating until you reach 1000\", 'user')],\n  recursion_limit: 25  // Stop after 25 iterations (default)\n});\n\nif (result.recursion_limit_reached) {\n  console.log('Tool loop stopped: recursion limit reached');\n  console.log(`Completed ${result.iterations} iterations`);\n}\n</code></pre>"},{"location":"client/tools-guide/#error-handling","title":"Error Handling","text":""},{"location":"client/tools-guide/#tool-handler-errors","title":"Tool Handler Errors","text":"<p>When a tool handler throws an error, it's sent back to the agent as a tool failure:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'divide',\n  description: 'Divide two numbers',\n  parameters: {\n    type: 'object',\n    properties: {\n      a: { type: 'number' },\n      b: { type: 'number' }\n    },\n    required: ['a', 'b']\n  },\n  handler: async (args) =&gt; {\n    if (args.b === 0) {\n      throw new Error('Cannot divide by zero');\n    }\n    return { result: args.a / args.b };\n  }\n});\n\n// When called with divide(10, 0):\n// Agent receives: { error: \"Cannot divide by zero\", is_error: true }\n// Agent can then respond: \"I can't divide by zero. Please provide a non-zero divisor.\"\n</code></pre>"},{"location":"client/tools-guide/#graceful-error-handling","title":"Graceful Error Handling","text":"<p>Return error objects instead of throwing:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'fetch_user',\n  description: 'Get user information',\n  parameters: {\n    type: 'object',\n    properties: {\n      userId: { type: 'string' }\n    },\n    required: ['userId']\n  },\n  handler: async (args) =&gt; {\n    try {\n      const user = await db.users.findById(args.userId);\n\n      if (!user) {\n        return {\n          success: false,\n          error: 'User not found',\n          userId: args.userId\n        };\n      }\n\n      return {\n        success: true,\n        user: {\n          id: user.id,\n          name: user.name,\n          email: user.email\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#validation-errors","title":"Validation Errors","text":"<p>Validate parameters in your handler:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'send_email',\n  description: 'Send an email',\n  parameters: {\n    type: 'object',\n    properties: {\n      to: { type: 'string', description: 'Email address' },\n      subject: { type: 'string' },\n      body: { type: 'string' }\n    },\n    required: ['to', 'subject', 'body']\n  },\n  handler: async (args) =&gt; {\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(args.to)) {\n      throw new Error(`Invalid email address: ${args.to}`);\n    }\n\n    // Validate length\n    if (args.body.length &gt; 10000) {\n      throw new Error('Email body too long (max 10,000 characters)');\n    }\n\n    // Send email\n    await emailService.send(args.to, args.subject, args.body);\n\n    return { success: true, sent_at: new Date().toISOString() };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#common-tool-patterns","title":"Common Tool Patterns","text":""},{"location":"client/tools-guide/#1-weather-api-tool","title":"1. Weather API Tool","text":"<pre><code>import axios from 'axios';\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'City name or coordinates'\n      },\n      units: {\n        type: 'string',\n        enum: ['metric', 'imperial'],\n        default: 'metric'\n      }\n    },\n    required: ['location']\n  },\n  handler: async (args) =&gt; {\n    const apiKey = process.env.WEATHER_API_KEY;\n    const response = await axios.get('https://api.weatherapi.com/v1/current.json', {\n      params: {\n        key: apiKey,\n        q: args.location\n      }\n    });\n\n    return {\n      location: response.data.location.name,\n      temperature: response.data.current.temp_c,\n      condition: response.data.current.condition.text,\n      humidity: response.data.current.humidity,\n      wind_kph: response.data.current.wind_kph\n    };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#2-calculator-tool","title":"2. Calculator Tool","text":"<pre><code>import { evaluate } from 'mathjs';  // Safe math evaluation library\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'calculate',\n  description: 'Perform mathematical calculations',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: {\n        type: 'string',\n        description: 'Math expression (e.g., \"sqrt(144)\", \"2 * pi * 5\")'\n      }\n    },\n    required: ['expression']\n  },\n  handler: async (args) =&gt; {\n    try {\n      const result = evaluate(args.expression);\n      return {\n        expression: args.expression,\n        result: result,\n        formatted: `${args.expression} = ${result}`\n      };\n    } catch (error) {\n      throw new Error(`Invalid expression: ${args.expression}`);\n    }\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#3-database-query-tool","title":"3. Database Query Tool","text":"<pre><code>import { db } from './database';\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'search_products',\n  description: 'Search for products in the database',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: { type: 'string', description: 'Search query' },\n      category: { \n        type: 'string',\n        enum: ['electronics', 'clothing', 'books', 'all'],\n        default: 'all'\n      },\n      limit: { type: 'number', minimum: 1, maximum: 50, default: 10 }\n    },\n    required: ['query']\n  },\n  handler: async (args) =&gt; {\n    let query = db.products.where('name', 'like', `%${args.query}%`);\n\n    if (args.category !== 'all') {\n      query = query.where('category', '=', args.category);\n    }\n\n    const products = await query.limit(args.limit).get();\n\n    return {\n      query: args.query,\n      count: products.length,\n      products: products.map(p =&gt; ({\n        id: p.id,\n        name: p.name,\n        price: p.price,\n        category: p.category,\n        in_stock: p.stock &gt; 0\n      }))\n    };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#4-file-operations-tool","title":"4. File Operations Tool","text":"<pre><code>import fs from 'fs/promises';\nimport path from 'path';\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'read_file',\n  description: 'Read contents of a file',\n  parameters: {\n    type: 'object',\n    properties: {\n      filepath: {\n        type: 'string',\n        description: 'Path to the file (relative to allowed directory)'\n      }\n    },\n    required: ['filepath']\n  },\n  handler: async (args) =&gt; {\n    // Security: only allow reading from specific directory\n    const allowedDir = path.resolve('./data');\n    const requestedPath = path.resolve(allowedDir, args.filepath);\n\n    if (!requestedPath.startsWith(allowedDir)) {\n      throw new Error('Access denied: file outside allowed directory');\n    }\n\n    try {\n      const content = await fs.readFile(requestedPath, 'utf-8');\n      return {\n        filepath: args.filepath,\n        content: content,\n        size: content.length\n      };\n    } catch (error) {\n      throw new Error(`Could not read file: ${error.message}`);\n    }\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#5-external-api-tool","title":"5. External API Tool","text":"<pre><code>import axios from 'axios';\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'search_web',\n  description: 'Search the web using a search API',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: { type: 'string', description: 'Search query' },\n      num_results: { type: 'number', minimum: 1, maximum: 10, default: 5 }\n    },\n    required: ['query']\n  },\n  handler: async (args) =&gt; {\n    const apiKey = process.env.SEARCH_API_KEY;\n\n    const response = await axios.get('https://api.search.example.com/search', {\n      params: {\n        q: args.query,\n        n: args.num_results,\n        key: apiKey\n      },\n      timeout: 10000  // 10 second timeout\n    });\n\n    return {\n      query: args.query,\n      results: response.data.results.map((r: any) =&gt; ({\n        title: r.title,\n        snippet: r.snippet,\n        url: r.url\n      }))\n    };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#6-authentication-aware-tool","title":"6. Authentication-Aware Tool","text":"<pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'get_user_orders',\n  description: 'Get orders for the authenticated user',\n  parameters: {\n    type: 'object',\n    properties: {\n      status: {\n        type: 'string',\n        enum: ['all', 'pending', 'shipped', 'delivered'],\n        default: 'all'\n      },\n      limit: { type: 'number', default: 10 }\n    }\n  },\n  handler: async (args, context) =&gt; {\n    // Get user ID from context (passed from your application)\n    const userId = context.userId;\n\n    if (!userId) {\n      throw new Error('User not authenticated');\n    }\n\n    let query = db.orders.where('user_id', '=', userId);\n\n    if (args.status !== 'all') {\n      query = query.where('status', '=', args.status);\n    }\n\n    const orders = await query.limit(args.limit).get();\n\n    return {\n      user_id: userId,\n      count: orders.length,\n      orders: orders.map(o =&gt; ({\n        id: o.id,\n        total: o.total,\n        status: o.status,\n        created_at: o.created_at\n      }))\n    };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#advanced-topics","title":"Advanced Topics","text":""},{"location":"client/tools-guide/#async-tools","title":"Async Tools","text":"<p>All tool handlers are async by default:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'fetch_data',\n  handler: async (args) =&gt; {\n    // Multiple async operations\n    const [weather, stocks, news] = await Promise.all([\n      fetchWeather(args.location),\n      fetchStocks(args.symbols),\n      fetchNews(args.topic)\n    ]);\n\n    return { weather, stocks, news };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#tool-composition","title":"Tool Composition","text":"<p>Break complex tools into smaller functions:</p> <pre><code>// Helper functions\nasync function validateUser(userId: string) {\n  const user = await db.users.findById(userId);\n  if (!user) throw new Error('User not found');\n  return user;\n}\n\nasync function checkPermissions(user: any, resource: string) {\n  if (!user.permissions.includes(resource)) {\n    throw new Error('Permission denied');\n  }\n}\n\nasync function performAction(user: any, action: string) {\n  // ... implementation\n}\n\n// Composed tool\nclient.registerTool({\n  node: 'assistant',\n  name: 'user_action',\n  handler: async (args) =&gt; {\n    const user = await validateUser(args.userId);\n    await checkPermissions(user, args.resource);\n    return await performAction(user, args.action);\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#dynamic-tool-registration","title":"Dynamic Tool Registration","text":"<p>Register tools conditionally based on user or environment:</p> <pre><code>function registerUserTools(client: AgentFlowClient, user: User) {\n  // Basic tools for all users\n  client.registerTool({\n    node: 'assistant',\n    name: 'get_profile',\n    handler: async () =&gt; {\n      return { name: user.name, email: user.email };\n    }\n  });\n\n  // Admin-only tools\n  if (user.isAdmin) {\n    client.registerTool({\n      node: 'assistant',\n      name: 'list_all_users',\n      handler: async () =&gt; {\n        return await db.users.all();\n      }\n    });\n  }\n\n  // Premium user tools\n  if (user.isPremium) {\n    client.registerTool({\n      node: 'assistant',\n      name: 'advanced_analytics',\n      handler: async () =&gt; {\n        return await analytics.getAdvancedMetrics(user.id);\n      }\n    });\n  }\n}\n</code></pre>"},{"location":"client/tools-guide/#stateful-tools","title":"Stateful Tools","text":"<p>Maintain state across tool calls using closures:</p> <pre><code>function createSessionTools(sessionId: string) {\n  const sessionData = new Map&lt;string, any&gt;();\n\n  return [\n    {\n      node: 'assistant',\n      name: 'store_session_data',\n      handler: async (args: { key: string; value: any }) =&gt; {\n        sessionData.set(args.key, args.value);\n        return { success: true, key: args.key };\n      }\n    },\n    {\n      node: 'assistant',\n      name: 'get_session_data',\n      handler: async (args: { key: string }) =&gt; {\n        const value = sessionData.get(args.key);\n        return { key: args.key, value, exists: value !== undefined };\n      }\n    }\n  ];\n}\n\n// Register session tools\nconst tools = createSessionTools('session_123');\ntools.forEach(tool =&gt; client.registerTool(tool));\n</code></pre>"},{"location":"client/tools-guide/#caching-performance","title":"Caching &amp; Performance","text":"<p>Cache expensive operations:</p> <pre><code>import NodeCache from 'node-cache';\n\nconst cache = new NodeCache({ stdTTL: 300 });  // 5 minute cache\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_exchange_rate',\n  handler: async (args) =&gt; {\n    const cacheKey = `rate_${args.from}_${args.to}`;\n\n    // Check cache first\n    const cached = cache.get(cacheKey);\n    if (cached) {\n      return { ...cached, cached: true };\n    }\n\n    // Fetch fresh data\n    const rate = await fetchExchangeRate(args.from, args.to);\n\n    // Cache the result\n    cache.set(cacheKey, rate);\n\n    return { ...rate, cached: false };\n  }\n});\n</code></pre>"},{"location":"client/tools-guide/#testing-tools","title":"Testing Tools","text":""},{"location":"client/tools-guide/#unit-testing-tool-handlers","title":"Unit Testing Tool Handlers","text":"<p>Test your tool handlers independently:</p> <pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Calculator Tool', () =&gt; {\n  const handler = async (args: any) =&gt; {\n    // Your calculator handler implementation\n    const result = evaluate(args.expression);\n    return { result };\n  };\n\n  it('should calculate basic arithmetic', async () =&gt; {\n    const result = await handler({ expression: '2 + 2' });\n    expect(result.result).toBe(4);\n  });\n\n  it('should handle complex expressions', async () =&gt; {\n    const result = await handler({ expression: 'sqrt(144) * 2' });\n    expect(result.result).toBe(24);\n  });\n\n  it('should throw error for invalid expressions', async () =&gt; {\n    await expect(handler({ expression: 'invalid' }))\n      .rejects\n      .toThrow('Invalid expression');\n  });\n});\n</code></pre>"},{"location":"client/tools-guide/#integration-testing","title":"Integration Testing","text":"<p>Test tools with the agent:</p> <pre><code>import { AgentFlowClient, Message } from 'agentflow-react';\nimport { describe, it, expect, beforeEach } from 'vitest';\n\ndescribe('Weather Tool Integration', () =&gt; {\n  let client: AgentFlowClient;\n\n  beforeEach(() =&gt; {\n    client = new AgentFlowClient({\n      baseUrl: 'http://localhost:8000',\n      authToken: 'test-token'\n    });\n\n    // Register test weather tool\n    client.registerTool({\n      node: 'assistant',\n      name: 'get_weather',\n      handler: async (args) =&gt; {\n        // Mock weather data for testing\n        return {\n          location: args.location,\n          temperature: 72,\n          condition: 'sunny'\n        };\n      }\n    });\n  });\n\n  it('should execute weather tool when asked', async () =&gt; {\n    const result = await client.invoke({\n      messages: [Message.text_message(\"What's the weather in Paris?\", 'user')]\n    });\n\n    // Verify tool was executed\n    expect(result.iterations).toBeGreaterThan(0);\n\n    // Verify response mentions weather data\n    const response = result.messages[0].content;\n    expect(response).toContain('72');\n    expect(response).toContain('sunny');\n  });\n});\n</code></pre>"},{"location":"client/tools-guide/#mock-tools-for-testing","title":"Mock Tools for Testing","text":"<p>Create mock tools for testing without external dependencies:</p> <pre><code>function createMockTools(client: AgentFlowClient) {\n  client.registerTool({\n    node: 'assistant',\n    name: 'get_weather',\n    handler: async (args) =&gt; ({\n      location: args.location,\n      temperature: 72,\n      condition: 'sunny'\n    })\n  });\n\n  client.registerTool({\n    node: 'assistant',\n    name: 'search_products',\n    handler: async (args) =&gt; ({\n      products: [\n        { id: 1, name: 'Test Product', price: 29.99 }\n      ]\n    })\n  });\n\n  client.registerTool({\n    node: 'assistant',\n    name: 'send_email',\n    handler: async (args) =&gt; ({\n      success: true,\n      message_id: 'mock_message_123'\n    })\n  });\n}\n</code></pre>"},{"location":"client/tools-guide/#best-practices","title":"Best Practices","text":""},{"location":"client/tools-guide/#do","title":"\u2705 DO:","text":"<ol> <li>Use descriptive names and descriptions</li> <li>Good: <code>get_current_weather</code>, <code>calculate_loan_payment</code></li> <li> <p>Bad: <code>tool1</code>, <code>function_a</code></p> </li> <li> <p>Return structured data <pre><code>// Good\nreturn {\n  success: true,\n  data: { temp: 72, condition: 'sunny' },\n  timestamp: new Date().toISOString()\n};\n\n// Bad\nreturn \"The temperature is 72 and it's sunny\";\n</code></pre></p> </li> <li> <p>Validate inputs <pre><code>if (!args.email || !emailRegex.test(args.email)) {\n  throw new Error('Invalid email address');\n}\n</code></pre></p> </li> <li> <p>Handle errors gracefully <pre><code>try {\n  return await externalAPI.call(args);\n} catch (error) {\n  return {\n    success: false,\n    error: error.message,\n    fallback_data: getCachedData()\n  };\n}\n</code></pre></p> </li> <li> <p>Use async/await consistently <pre><code>handler: async (args) =&gt; {\n  const result = await fetchData(args);\n  return result;\n}\n</code></pre></p> </li> <li> <p>Keep tools focused (single responsibility)</p> </li> <li>One tool = one clear purpose</li> <li> <p>Split complex operations into multiple tools</p> </li> <li> <p>Add timeout protection <pre><code>handler: async (args) =&gt; {\n  const controller = new AbortController();\n  const timeout = setTimeout(() =&gt; controller.abort(), 5000);\n\n  try {\n    const result = await fetch(url, { signal: controller.signal });\n    return result;\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"client/tools-guide/#dont","title":"\u274c DON'T:","text":"<ol> <li>Don't use eval() for calculations</li> <li> <p>Use a safe math library like mathjs</p> </li> <li> <p>Don't expose sensitive data <pre><code>// Bad\nreturn { user: fullUserObject };  // Might include passwords, tokens\n\n// Good\nreturn { \n  user: { \n    id: user.id, \n    name: user.name, \n    email: user.email \n  } \n};\n</code></pre></p> </li> <li> <p>Don't perform blocking operations <pre><code>// Bad\nhandler: (args) =&gt; {\n  // Synchronous blocking operation\n  return fs.readFileSync(args.path);\n};\n\n// Good\nhandler: async (args) =&gt; {\n  return await fs.promises.readFile(args.path, 'utf-8');\n};\n</code></pre></p> </li> <li> <p>Don't ignore errors <pre><code>// Bad\ntry {\n  await riskyOperation();\n} catch (e) {\n  // Silent failure\n}\n\n// Good\ntry {\n  await riskyOperation();\n} catch (e) {\n  console.error('Operation failed:', e);\n  throw new Error('Could not complete operation');\n}\n</code></pre></p> </li> <li> <p>Don't use tools for simple data the agent knows</p> </li> <li>Let the agent handle general knowledge</li> <li>Only use tools for external/dynamic data</li> </ol>"},{"location":"client/tools-guide/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Validate and sanitize all inputs</li> <li>Use allowlists, not denylists for file paths and resources</li> <li>Never execute arbitrary code from tool arguments</li> <li>Implement rate limiting for expensive operations</li> <li>Use environment variables for API keys and secrets</li> <li>Check permissions before performing actions</li> <li>Audit tool usage in production</li> <li>Timeout protection on all external calls</li> </ol>"},{"location":"client/tools-guide/#performance-best-practices","title":"Performance Best Practices","text":"<ol> <li>Cache frequently requested data</li> <li>Use connection pooling for database tools</li> <li>Batch operations when possible</li> <li>Add timeouts to all external calls</li> <li>Monitor tool execution time</li> <li>Consider async execution for slow operations</li> <li>Limit recursion depth appropriately</li> </ol>"},{"location":"client/tools-guide/#summary","title":"Summary","text":"<ul> <li>\u2705 Tools extend your agent's capabilities with real-world actions</li> <li>\u2705 Register tools with <code>client.registerTool()</code> before invoking</li> <li>\u2705 Use OpenAI-compatible parameter schemas</li> <li>\u2705 Handlers are async and can call any JavaScript/TypeScript code</li> <li>\u2705 <code>invoke()</code> handles the tool loop automatically</li> <li>\u2705 <code>stream()</code> requires manual tool loop handling</li> <li>\u2705 Return structured data, not strings</li> <li>\u2705 Handle errors gracefully with try/catch</li> <li>\u2705 Test tools independently and with the agent</li> <li>\u2705 Follow security and performance best practices</li> </ul>"},{"location":"client/tools-guide/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Invoke Usage Guide - Using invoke with tools</li> <li>Stream Usage Guide - Streaming with tools</li> <li>React Integration - Using tools in React</li> <li>Examples - Complete code examples</li> </ul> <p>Need Help? Check out the Troubleshooting Guide for common issues with tools.</p>"},{"location":"client/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common issues and solutions for agentflow-react.</p>"},{"location":"client/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation Issues</li> <li>Connection &amp; Authentication</li> <li>Timeout Problems</li> <li>Tool Execution Issues</li> <li>Stream Connection Issues</li> <li>TypeScript Compilation Errors</li> <li>React Integration Issues</li> <li>Message &amp; State Issues</li> <li>Debugging Tips</li> <li>FAQ</li> </ul>"},{"location":"client/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"client/troubleshooting/#problem-npm-install-fails-with-peer-dependency-warnings","title":"Problem: <code>npm install</code> fails with peer dependency warnings","text":"<pre><code>npm WARN ERESOLVE overriding peer dependency\nnpm WARN Found: react@17.0.2\n</code></pre> <p>Solution:</p> <p>The library requires React 18.0 or higher. Upgrade React:</p> <pre><code>npm install react@latest react-dom@latest\n</code></pre> <p>Or if you must use React 17, use <code>--legacy-peer-deps</code>:</p> <pre><code>npm install agentflow-react --legacy-peer-deps\n</code></pre>"},{"location":"client/troubleshooting/#problem-typescript-types-not-found","title":"Problem: TypeScript types not found","text":"<pre><code>Could not find a declaration file for module 'agentflow-react'\n</code></pre> <p>Solution:</p> <p>The library includes TypeScript definitions. If they're not found:</p> <ol> <li> <p>Check your <code>tsconfig.json</code> includes <code>node_modules</code>:    <pre><code>{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n}\n</code></pre></p> </li> <li> <p>Try reinstalling:    <pre><code>rm -rf node_modules package-lock.json\nnpm install\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-module-not-found-errors-in-nextjs","title":"Problem: Module not found errors in Next.js","text":"<pre><code>Module not found: Can't resolve 'agentflow-react'\n</code></pre> <p>Solution:</p> <p>Next.js App Router requires client-side components:</p> <pre><code>'use client';  // Add this at the top\n\nimport { AgentFlowClient } from 'agentflow-react';\n</code></pre>"},{"location":"client/troubleshooting/#connection-authentication","title":"Connection &amp; Authentication","text":""},{"location":"client/troubleshooting/#problem-401-unauthorized-error","title":"Problem: <code>401 Unauthorized</code> error","text":"<pre><code>AuthenticationError: Authentication failed (401)\nRequest ID: req_abc123\n</code></pre> <p>Causes: - Missing or incorrect auth token - Token expired - Wrong API endpoint</p> <p>Solutions:</p> <ol> <li> <p>Verify your auth token: <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: process.env.AGENTFLOW_TOKEN,  // \u2705 Use env variable\n  debug: true  // Enable to see request details\n});\n</code></pre></p> </li> <li> <p>Check token in request headers:    Enable debug mode to see the actual request:    <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token',\n  debug: true  // Will log headers\n});\n</code></pre></p> </li> <li> <p>Verify API endpoint:    Ensure <code>baseUrl</code> matches your API server:    <pre><code>// Local development\nbaseUrl: 'http://localhost:8000'\n\n// Production\nbaseUrl: 'https://api.agentflow.example.com'\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-econnrefused-connection-refused","title":"Problem: <code>ECONNREFUSED</code> - Connection refused","text":"<pre><code>Error: connect ECONNREFUSED 127.0.0.1:8000\n</code></pre> <p>Causes: - API server is not running - Wrong port or host - Firewall blocking connection</p> <p>Solutions:</p> <ol> <li> <p>Check if server is running: <pre><code># Test connection\ncurl http://localhost:8000/v1/ping\n</code></pre></p> </li> <li> <p>Verify baseUrl: <pre><code>// Check port and protocol\nconst client = new AgentFlowClient({\n  baseUrl: 'http://localhost:8000',  // Not https for local\n  debug: true\n});\n</code></pre></p> </li> <li> <p>Check firewall settings:</p> </li> <li>Ensure port 8000 (or your port) is open</li> <li>Try a different port if blocked</li> </ol>"},{"location":"client/troubleshooting/#problem-cors-errors-in-browser","title":"Problem: <code>CORS</code> errors in browser","text":"<pre><code>Access to fetch at 'https://api.example.com' from origin \n'http://localhost:3000' has been blocked by CORS policy\n</code></pre> <p>Cause: Server doesn't allow requests from your origin.</p> <p>Solutions:</p> <ol> <li> <p>Server-side fix (recommended):    Configure your API server to allow your origin:    <pre><code># In your FastAPI/Flask server\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre></p> </li> <li> <p>Use server-side API calls:    Make API calls from Next.js API routes instead of client-side:    <pre><code>// app/api/agent/route.ts\nexport async function POST(request: Request) {\n  const client = new AgentFlowClient({\n    baseUrl: process.env.AGENTFLOW_API_URL\n  });\n\n  const result = await client.invoke(/* ... */);\n  return Response.json(result);\n}\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#timeout-problems","title":"Timeout Problems","text":""},{"location":"client/troubleshooting/#problem-request-timeout-after-5-minutes","title":"Problem: Request timeout after 5 minutes","text":"<pre><code>TimeoutError: Request timed out after 300000ms\nRequest ID: req_abc123\n</code></pre> <p>Cause: Default timeout is 5 minutes (300,000ms). Long-running operations exceed this.</p> <p>Solutions:</p> <ol> <li> <p>Increase timeout: <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  timeout: 600000  // 10 minutes (in milliseconds)\n});\n</code></pre></p> </li> <li> <p>Use streaming for long operations:    Stream provides feedback during processing:    <pre><code>for await (const chunk of client.stream({ messages })) {\n  // Process chunks as they arrive\n  // No timeout needed for streaming\n}\n</code></pre></p> </li> <li> <p>Optimize recursion limit:    Reduce tool execution iterations:    <pre><code>const result = await client.invoke({\n  messages: [Message.text_message('...', 'user')],\n  recursion_limit: 10  // Default is 25\n});\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-stream-disconnects-randomly","title":"Problem: Stream disconnects randomly","text":"<pre><code>Stream ended unexpectedly\n</code></pre> <p>Causes: - Network issues - Server timeout - Proxy/load balancer timeout</p> <p>Solutions:</p> <ol> <li> <p>Implement reconnection logic: <pre><code>async function streamWithRetry(messages: Message[], maxRetries = 3) {\n  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n    try {\n      for await (const chunk of client.stream({ messages })) {\n        yield chunk;\n      }\n      return;  // Success\n    } catch (error) {\n      if (attempt === maxRetries) throw error;\n      console.log(`Retry ${attempt}/${maxRetries}...`);\n      await sleep(1000 * attempt);  // Exponential backoff\n    }\n  }\n}\n</code></pre></p> </li> <li> <p>Add keep-alive headers:    Configure your HTTP client with keep-alive:    <pre><code>// In your client configuration\n{\n  timeout: 600000,\n  headers: {\n    'Connection': 'keep-alive',\n    'Keep-Alive': 'timeout=600'\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#tool-execution-issues","title":"Tool Execution Issues","text":""},{"location":"client/troubleshooting/#problem-tools-not-executing","title":"Problem: Tools not executing","text":"<pre><code>Tool 'get_weather' not found\n</code></pre> <p>Causes: - Tool not registered before invoke - Wrong tool name - Wrong node name</p> <p>Solutions:</p> <ol> <li> <p>Register tools before invoke: <pre><code>// \u2705 CORRECT ORDER\nconst client = new AgentFlowClient({ baseUrl: '...' });\n\n// Register first\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_weather',\n  handler: async (args) =&gt; { /* ... */ }\n});\n\n// Then invoke\nawait client.invoke({ messages: [...] });\n</code></pre></p> </li> <li> <p>Verify tool name matches: <pre><code>// Tool registration\nname: 'get_weather'\n\n// API returns this exact name in remote_tool_call\n{\n  type: 'remote_tool_call',\n  name: 'get_weather',  // Must match exactly\n  args: { location: 'Paris' }\n}\n</code></pre></p> </li> <li> <p>Check node name: <pre><code>client.registerTool({\n  node: 'assistant',  // Must match your agent graph node\n  name: 'get_weather',\n  // ...\n});\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-tool-handler-errors-not-showing","title":"Problem: Tool handler errors not showing","text":"<pre><code>Tool executed but error not visible\n</code></pre> <p>Solution:</p> <p>Enable debug mode to see tool execution:</p> <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  debug: true  // Shows tool execution and errors\n});\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'my_tool',\n  handler: async (args) =&gt; {\n    console.log('Tool called with:', args);  // Debug logging\n\n    try {\n      const result = await someOperation(args);\n      console.log('Tool result:', result);\n      return result;\n    } catch (error) {\n      console.error('Tool error:', error);\n      throw error;  // Re-throw to send error to agent\n    }\n  }\n});\n</code></pre>"},{"location":"client/troubleshooting/#problem-recursion-limit-reached","title":"Problem: Recursion limit reached","text":"<pre><code>{\n  recursion_limit_reached: true,\n  iterations: 25\n}\n</code></pre> <p>Cause: Agent is stuck in a tool loop, hitting the max iteration limit.</p> <p>Solutions:</p> <ol> <li> <p>Increase recursion limit: <pre><code>const result = await client.invoke({\n  messages: [...],\n  recursion_limit: 50  // Increase if needed\n});\n</code></pre></p> </li> <li> <p>Fix tool logic:    Ensure tools return clear results that help agent move forward:    <pre><code>// \u274c BAD: Vague result that might cause loops\nreturn { status: 'ok' };\n\n// \u2705 GOOD: Clear, actionable result\nreturn {\n  success: true,\n  temperature: 72,\n  condition: 'sunny',\n  message: 'Weather data successfully retrieved'\n};\n</code></pre></p> </li> <li> <p>Use callback to monitor iterations: <pre><code>const result = await client.invoke({\n  messages: [...],\n  recursion_limit: 25,\n  on_progress: (partial) =&gt; {\n    console.log(`Iteration ${partial.iterations}`);\n    if (partial.iterations &gt; 15) {\n      console.warn('Approaching recursion limit!');\n    }\n  }\n});\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#stream-connection-issues","title":"Stream Connection Issues","text":""},{"location":"client/troubleshooting/#problem-stream-not-yielding-chunks","title":"Problem: Stream not yielding chunks","text":"<pre><code>for await (const chunk of client.stream({ messages })) {\n  // Never enters this block\n}\n</code></pre> <p>Causes: - Network issues - Wrong endpoint - SSE not supported by infrastructure</p> <p>Solutions:</p> <ol> <li> <p>Verify endpoint supports SSE: <pre><code>curl -N http://localhost:8000/v1/graph/stream \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: text/event-stream\" \\\n  -d '{\"messages\": [...]}'\n</code></pre></p> </li> <li> <p>Check for proxy issues:    Some proxies buffer SSE streams. Try direct connection:    <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'http://localhost:8000',  // Direct, bypass proxy\n  debug: true\n});\n</code></pre></p> </li> <li> <p>Add error handling: <pre><code>try {\n  for await (const chunk of client.stream({ messages })) {\n    console.log('Chunk received:', chunk.event);\n  }\n} catch (error) {\n  console.error('Stream error:', error);\n}\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-partial-content-not-updating-ui","title":"Problem: Partial content not updating UI","text":"<pre><code>// UI not updating as chunks arrive\n</code></pre> <p>Solution:</p> <p>Ensure you're updating state on each chunk:</p> <pre><code>const [content, setContent] = useState('');\n\nasync function handleStream() {\n  let accumulated = '';\n\n  for await (const chunk of client.stream({ messages })) {\n    if (chunk.event === 'messages_chunk') {\n      accumulated += chunk.data;\n      setContent(accumulated);  // \u2705 Update state each chunk\n    }\n  }\n}\n</code></pre> <p>React 18+ with automatic batching: <pre><code>const [content, setContent] = useState('');\n\nasync function handleStream() {\n  for await (const chunk of client.stream({ messages })) {\n    if (chunk.event === 'messages_chunk') {\n      // Use functional update for accurate state\n      setContent(prev =&gt; prev + chunk.data);\n    }\n  }\n}\n</code></pre></p>"},{"location":"client/troubleshooting/#typescript-compilation-errors","title":"TypeScript Compilation Errors","text":""},{"location":"client/troubleshooting/#problem-type-inference-not-working","title":"Problem: Type inference not working","text":"<pre><code>const result = await client.invoke({ messages });\n// result type is 'any'\n</code></pre> <p>Solution:</p> <p>Import and use proper types:</p> <pre><code>import { AgentFlowClient, InvokeResult, Message } from 'agentflow-react';\n\nconst client: AgentFlowClient = new AgentFlowClient({ /* ... */ });\n\nconst result: InvokeResult = await client.invoke({\n  messages: [Message.text_message('Hello', 'user')]\n});\n\n// Now result.messages, result.state, etc. are properly typed\n</code></pre>"},{"location":"client/troubleshooting/#problem-message-type-errors","title":"Problem: Message type errors","text":"<pre><code>// Error: Argument of type 'string' is not assignable to parameter of type 'Message'\nclient.invoke({ messages: ['Hello'] });\n</code></pre> <p>Solution:</p> <p>Use Message helper methods:</p> <pre><code>import { Message } from 'agentflow-react';\n\n// \u2705 Correct\nconst messages = [\n  Message.text_message('Hello', 'user'),\n  Message.text_message('Hi there!', 'assistant')\n];\n\n// Or with type\nconst messages: Message[] = [\n  Message.text_message('Hello', 'user')\n];\n\nawait client.invoke({ messages });\n</code></pre>"},{"location":"client/troubleshooting/#problem-tool-handler-type-errors","title":"Problem: Tool handler type errors","text":"<pre><code>handler: (args) =&gt; {\n  // 'args' is implicitly 'any'\n}\n</code></pre> <p>Solution:</p> <p>Define parameter interfaces:</p> <pre><code>interface WeatherArgs {\n  location: string;\n  units?: 'metric' | 'imperial';\n}\n\ninterface WeatherResult {\n  temperature: number;\n  condition: string;\n  humidity: number;\n}\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_weather',\n  handler: async (args: WeatherArgs): Promise&lt;WeatherResult&gt; =&gt; {\n    // Now args.location is typed\n    const data = await fetchWeather(args.location);\n    return {\n      temperature: data.temp,\n      condition: data.condition,\n      humidity: data.humidity\n    };\n  }\n});\n</code></pre>"},{"location":"client/troubleshooting/#react-integration-issues","title":"React Integration Issues","text":""},{"location":"client/troubleshooting/#problem-client-recreated-on-every-render","title":"Problem: Client recreated on every render","text":"<pre><code>function MyComponent() {\n  // \u274c New client instance on every render!\n  const client = new AgentFlowClient({ baseUrl: '...' });\n  // ...\n}\n</code></pre> <p>Solution:</p> <p>Use <code>useMemo</code> or Context:</p> <pre><code>import { useMemo } from 'react';\n\nfunction MyComponent() {\n  // \u2705 Client created once\n  const client = useMemo(() =&gt; {\n    return new AgentFlowClient({\n      baseUrl: process.env.NEXT_PUBLIC_API_URL!\n    });\n  }, []);\n\n  // Use client\n}\n</code></pre> <p>Or better, use Context Provider:</p> <pre><code>// context/AgentFlowContext.tsx\nconst AgentFlowContext = createContext&lt;AgentFlowClient | null&gt;(null);\n\nexport function AgentFlowProvider({ children }: { children: ReactNode }) {\n  const client = useMemo(() =&gt; {\n    return new AgentFlowClient({\n      baseUrl: process.env.NEXT_PUBLIC_API_URL!\n    });\n  }, []);\n\n  return (\n    &lt;AgentFlowContext.Provider value={client}&gt;\n      {children}\n    &lt;/AgentFlowContext.Provider&gt;\n  );\n}\n\n// In components\nfunction MyComponent() {\n  const client = useContext(AgentFlowContext);\n  // ...\n}\n</code></pre>"},{"location":"client/troubleshooting/#problem-async-state-not-updating","title":"Problem: Async state not updating","text":"<pre><code>const [result, setResult] = useState(null);\n\nasync function handleInvoke() {\n  const data = await client.invoke({ messages });\n  setResult(data);  // Not updating?\n}\n</code></pre> <p>Solutions:</p> <ol> <li> <p>Check component is still mounted: <pre><code>useEffect(() =&gt; {\n  let isMounted = true;\n\n  async function fetchData() {\n    const data = await client.invoke({ messages });\n    if (isMounted) {\n      setResult(data);\n    }\n  }\n\n  fetchData();\n\n  return () =&gt; {\n    isMounted = false;\n  };\n}, [messages]);\n</code></pre></p> </li> <li> <p>Use proper async patterns: <pre><code>const [loading, setLoading] = useState(false);\nconst [result, setResult] = useState(null);\nconst [error, setError] = useState(null);\n\nasync function handleInvoke() {\n  setLoading(true);\n  setError(null);\n\n  try {\n    const data = await client.invoke({ messages });\n    setResult(data);\n  } catch (err) {\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-infinite-re-render-loop","title":"Problem: Infinite re-render loop","text":"<pre><code>function MyComponent() {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() =&gt; {\n    // \u274c Creates new array every render\n    setMessages([Message.text_message('Hello', 'user')]);\n  }, []);  // Missing dependency warning\n}\n</code></pre> <p>Solution:</p> <p>Initialize state properly:</p> <pre><code>function MyComponent() {\n  // \u2705 Initialize once\n  const [messages, setMessages] = useState(() =&gt; [\n    Message.text_message('Hello', 'user')\n  ]);\n\n  // Or if you must use useEffect\n  useEffect(() =&gt; {\n    setMessages([Message.text_message('Hello', 'user')]);\n  }, []);  // Empty array = run once\n}\n</code></pre>"},{"location":"client/troubleshooting/#message-state-issues","title":"Message &amp; State Issues","text":""},{"location":"client/troubleshooting/#problem-empty-response-messages","title":"Problem: Empty response messages","text":"<pre><code>const result = await client.invoke({ messages });\nconsole.log(result.messages);  // []\n</code></pre> <p>Causes: - Wrong granularity level - API error not caught - Empty response from agent</p> <p>Solutions:</p> <ol> <li> <p>Check granularity: <pre><code>const result = await client.invoke({\n  messages: [...],\n  granularity: 'full'  // Ensure full response\n});\n</code></pre></p> </li> <li> <p>Check all_messages: <pre><code>// result.messages = final response only\n// result.all_messages = all messages including tool calls\n\nconsole.log('Final:', result.messages);\nconsole.log('All:', result.all_messages);\n</code></pre></p> </li> <li> <p>Enable debug mode: <pre><code>const client = new AgentFlowClient({\n  baseUrl: '...',\n  debug: true  // See full request/response\n});\n</code></pre></p> </li> </ol>"},{"location":"client/troubleshooting/#problem-state-not-persisting-across-calls","title":"Problem: State not persisting across calls","text":"<pre><code>// First call\nawait client.invoke({\n  messages: [Message.text_message('Remember my name is Alice', 'user')]\n});\n\n// Second call - agent doesn't remember\nawait client.invoke({\n  messages: [Message.text_message('What is my name?', 'user')]\n});\n</code></pre> <p>Cause: Not using thread IDs to maintain conversation context.</p> <p>Solution:</p> <p>Use threads to persist state:</p> <pre><code>const threadId = 'user_123_session_456';\n\n// First call\nawait client.invoke({\n  messages: [Message.text_message('Remember my name is Alice', 'user')],\n  config: { thread_id: threadId }\n});\n\n// Second call - agent remembers\nawait client.invoke({\n  messages: [Message.text_message('What is my name?', 'user')],\n  config: { thread_id: threadId }\n});\n</code></pre> <p>Or manage message history manually:</p> <pre><code>const [messageHistory, setMessageHistory] = useState&lt;Message[]&gt;([]);\n\nasync function sendMessage(content: string) {\n  const newMessage = Message.text_message(content, 'user');\n  const allMessages = [...messageHistory, newMessage];\n\n  const result = await client.invoke({\n    messages: allMessages  // Include full history\n  });\n\n  // Update history with response\n  setMessageHistory([\n    ...allMessages,\n    ...result.messages\n  ]);\n}\n</code></pre>"},{"location":"client/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"client/troubleshooting/#enable-debug-mode","title":"Enable Debug Mode","text":"<p>Always start with debug mode when troubleshooting:</p> <pre><code>const client = new AgentFlowClient({\n  baseUrl: 'https://api.example.com',\n  authToken: 'your-token',\n  debug: true  // \ud83d\udd0d Enable debug logging\n});\n</code></pre> <p>This shows: - Request URLs and headers - Request payloads - Response status codes - Tool executions - Errors with request IDs</p>"},{"location":"client/troubleshooting/#use-request-ids","title":"Use Request IDs","text":"<p>Every API call returns a <code>request_id</code> in metadata. Use it for debugging:</p> <pre><code>try {\n  const result = await client.invoke({ messages });\n  console.log('Request ID:', result.metadata.request_id);\n} catch (error) {\n  // Request ID available in error for failed requests\n  console.error('Failed with request ID:', error.requestId);\n}\n</code></pre> <p>When reporting issues, include the request ID.</p>"},{"location":"client/troubleshooting/#log-tool-executions","title":"Log Tool Executions","text":"<p>Add logging to tool handlers:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'my_tool',\n  handler: async (args) =&gt; {\n    console.log('[TOOL] Called with:', JSON.stringify(args, null, 2));\n\n    const start = Date.now();\n\n    try {\n      const result = await performOperation(args);\n      const duration = Date.now() - start;\n\n      console.log(`[TOOL] Success in ${duration}ms:`, result);\n      return result;\n    } catch (error) {\n      console.error('[TOOL] Error:', error);\n      throw error;\n    }\n  }\n});\n</code></pre>"},{"location":"client/troubleshooting/#monitor-streaming","title":"Monitor Streaming","text":"<p>Track streaming events:</p> <pre><code>const events: string[] = [];\n\nfor await (const chunk of client.stream({ messages })) {\n  events.push(chunk.event);\n  console.log(`[${chunk.event}]`, chunk.data);\n}\n\nconsole.log('Event sequence:', events);\n// ['metadata', 'on_chain_start', 'messages_chunk', 'messages_chunk', 'on_chain_end']\n</code></pre>"},{"location":"client/troubleshooting/#network-inspection","title":"Network Inspection","text":"<p>Use browser DevTools or Charles Proxy to inspect: - Request headers (auth token present?) - Response headers (correct content-type?) - Response body (error messages?) - Timing (where are delays?)</p>"},{"location":"client/troubleshooting/#test-with-curl","title":"Test with cURL","text":"<p>Test API directly without the client:</p> <pre><code># Test ping\ncurl http://localhost:8000/v1/ping\n\n# Test invoke\ncurl -X POST http://localhost:8000/v1/graph/invoke \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer your-token\" \\\n  -d '{\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}]\n      }\n    ]\n  }'\n\n# Test stream\ncurl -N -X POST http://localhost:8000/v1/graph/stream \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Accept: text/event-stream\" \\\n  -d '{\"messages\": [...]}'\n</code></pre>"},{"location":"client/troubleshooting/#faq","title":"FAQ","text":""},{"location":"client/troubleshooting/#q-can-i-use-agentflow-react-in-nodejs-server-side","title":"Q: Can I use agentflow-react in Node.js (server-side)?","text":"<p>A: Yes! The library works in both browser and Node.js environments. Just ensure you have <code>fetch</code> available (Node 18+ has it built-in, or use <code>node-fetch</code> polyfill).</p>"},{"location":"client/troubleshooting/#q-does-the-library-support-server-side-rendering-ssr","title":"Q: Does the library support Server-Side Rendering (SSR)?","text":"<p>A: Yes, but API calls should be made: - Client-side with <code>'use client'</code> directive (Next.js App Router) - In API routes (server-side) - In <code>getServerSideProps</code> / <code>getStaticProps</code> (Next.js Pages Router)</p> <p>Do not instantiate the client in SSR render functions directly.</p>"},{"location":"client/troubleshooting/#q-how-do-i-handle-authentication-in-production","title":"Q: How do I handle authentication in production?","text":"<p>A: Best practices: 1. Store API token in environment variables 2. Never expose tokens in client-side code 3. Use server-side API routes as proxy 4. Implement token refresh logic 5. Use secure HTTP-only cookies for user sessions</p> <pre><code>// Next.js API route (server-side)\nexport async function POST(request: Request) {\n  // Get user session (secure)\n  const session = await getServerSession();\n\n  // Create client with server-side token\n  const client = new AgentFlowClient({\n    baseUrl: process.env.AGENTFLOW_API_URL!,\n    authToken: process.env.AGENTFLOW_API_TOKEN!\n  });\n\n  const result = await client.invoke(/* ... */);\n  return Response.json(result);\n}\n</code></pre>"},{"location":"client/troubleshooting/#q-can-i-cancel-ongoing-invokestream-operations","title":"Q: Can I cancel ongoing invoke/stream operations?","text":"<p>A: </p> <p>For invoke: <pre><code>const controller = new AbortController();\n\nsetTimeout(() =&gt; controller.abort(), 5000);  // Cancel after 5s\n\ntry {\n  await client.invoke({ messages }, { signal: controller.signal });\n} catch (error) {\n  if (error.name === 'AbortError') {\n    console.log('Operation cancelled');\n  }\n}\n</code></pre></p> <p>For stream: <pre><code>async function* streamWithCancel(messages: Message[], signal: AbortSignal) {\n  for await (const chunk of client.stream({ messages })) {\n    if (signal.aborted) {\n      break;\n    }\n    yield chunk;\n  }\n}\n</code></pre></p>"},{"location":"client/troubleshooting/#q-how-do-i-handle-rate-limiting","title":"Q: How do I handle rate limiting?","text":"<p>A: Implement exponential backoff:</p> <pre><code>async function invokeWithRetry(\n  messages: Message[],\n  maxRetries = 3,\n  baseDelay = 1000\n) {\n  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n    try {\n      return await client.invoke({ messages });\n    } catch (error) {\n      if (error.status === 429 &amp;&amp; attempt &lt; maxRetries) {\n        // Rate limited, wait and retry\n        const delay = baseDelay * Math.pow(2, attempt - 1);\n        console.log(`Rate limited, retrying in ${delay}ms...`);\n        await sleep(delay);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"client/troubleshooting/#q-can-i-use-multiple-agentsgraphs","title":"Q: Can I use multiple agents/graphs?","text":"<p>A: Yes, just use different client instances or different <code>config</code> parameters:</p> <pre><code>const client = new AgentFlowClient({ baseUrl: '...' });\n\n// Agent A\nconst resultA = await client.invoke({\n  messages: [...],\n  config: { graph_id: 'agent_a' }\n});\n\n// Agent B\nconst resultB = await client.invoke({\n  messages: [...],\n  config: { graph_id: 'agent_b' }\n});\n</code></pre> <p>Or separate clients:</p> <pre><code>const clientA = new AgentFlowClient({ baseUrl: 'https://agent-a.example.com' });\nconst clientB = new AgentFlowClient({ baseUrl: 'https://agent-b.example.com' });\n</code></pre>"},{"location":"client/troubleshooting/#q-how-do-i-test-my-integration","title":"Q: How do I test my integration?","text":"<p>A: Use testing frameworks with mocking:</p> <pre><code>import { describe, it, expect, vi } from 'vitest';\nimport { AgentFlowClient } from 'agentflow-react';\n\ndescribe('Agent Integration', () =&gt; {\n  it('should handle invoke', async () =&gt; {\n    const mockInvoke = vi.fn().mockResolvedValue({\n      messages: [/* mock messages */],\n      metadata: { request_id: 'test' }\n    });\n\n    const client = new AgentFlowClient({ baseUrl: 'http://test' });\n    client.invoke = mockInvoke;\n\n    const result = await client.invoke({ messages: [] });\n\n    expect(mockInvoke).toHaveBeenCalled();\n    expect(result.messages).toBeDefined();\n  });\n});\n</code></pre>"},{"location":"client/troubleshooting/#q-is-there-a-size-limit-for-messages","title":"Q: Is there a size limit for messages?","text":"<p>A: This depends on your API server configuration. Typical limits: - Message content: 100KB per message - Total request: 1MB - Tool results: 50KB per result</p> <p>Large data should be sent via reference (URLs) rather than inline.</p>"},{"location":"client/troubleshooting/#q-can-tools-call-other-tools","title":"Q: Can tools call other tools?","text":"<p>A: No, tools can't directly call other tools. The agent decides the tool call sequence. However, tools can return data that suggests the agent call another tool:</p> <pre><code>client.registerTool({\n  node: 'assistant',\n  name: 'get_user_info',\n  handler: async (args) =&gt; {\n    const user = await db.users.find(args.userId);\n\n    return {\n      user_id: user.id,\n      name: user.name,\n      // Suggest next action\n      suggested_action: 'get_user_orders',\n      suggested_params: { userId: user.id }\n    };\n  }\n});\n</code></pre>"},{"location":"client/troubleshooting/#still-having-issues","title":"Still Having Issues?","text":"<ol> <li>Check the Examples:</li> <li>Invoke Example</li> <li>Stream Example</li> <li> <p>React Examples</p> </li> <li> <p>Enable Debug Mode: <pre><code>const client = new AgentFlowClient({\n  baseUrl: '...',\n  debug: true\n});\n</code></pre></p> </li> <li> <p>Check Documentation:</p> </li> <li>Getting Started</li> <li>API Reference</li> <li> <p>Tools Guide</p> </li> <li> <p>Search Issues:    Check the GitHub issues for similar problems and solutions.</p> </li> <li> <p>Ask for Help:    Create a new issue with:</p> </li> <li>Error message</li> <li>Request ID (from metadata)</li> <li>Minimal reproduction code</li> <li>Expected vs actual behavior</li> </ol> <p>Remember: Most issues are configuration or integration problems. Double-check: - \u2705 Auth token is correct - \u2705 Base URL is correct - \u2705 Tools registered before invoke - \u2705 Debug mode enabled - \u2705 Latest library version installed</p>"},{"location":"client/typescript-types/","title":"TypeScript Types Guide","text":"<p>Complete TypeScript reference for agentflow-react.</p>"},{"location":"client/typescript-types/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation with TypeScript</li> <li>Core Interfaces</li> <li>Message Types</li> <li>Request &amp; Response Types</li> <li>Tool Types</li> <li>Memory Types</li> <li>Stream Types</li> <li>Error Types</li> <li>Type Guards</li> <li>Generic Types</li> <li>Custom Type Extensions</li> </ul>"},{"location":"client/typescript-types/#installation-with-typescript","title":"Installation with TypeScript","text":"<p>The library includes full TypeScript support with type definitions.</p>"},{"location":"client/typescript-types/#basic-setup","title":"Basic Setup","text":"<pre><code>npm install agentflow-react\n</code></pre> <p>TypeScript Configuration:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"resolveJsonModule\": true\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#importing-types","title":"Importing Types","text":"<pre><code>import {\n  // Client\n  AgentFlowClient,\n  AgentFlowConfig,\n\n  // Messages\n  Message,\n  TextBlock,\n  ImageBlock,\n  AudioBlock,\n  RemoteToolCallBlock,\n  ToolResultBlock,\n\n  // Tools\n  ToolRegistration,\n  ToolHandler,\n  ToolParameter,\n\n  // Invoke\n  InvokeRequest,\n  InvokeResult,\n  InvokePartialResult,\n  InvokeCallback,\n\n  // Stream\n  StreamRequest,\n  StreamChunk,\n  StreamEventType,\n\n  // Memory\n  MemoryType,\n  RetrievalStrategy,\n  DistanceMetric,\n  StoreMemoryRequest,\n  SearchMemoryRequest,\n\n  // Responses\n  PingResponse,\n  GraphResponse,\n  StateSchemaResponse,\n  ThreadStateResponse,\n\n  // Errors\n  AgentFlowError,\n  AuthenticationError,\n  NotFoundError,\n\n  // Metadata\n  ResponseMetadata\n} from 'agentflow-react';\n</code></pre>"},{"location":"client/typescript-types/#core-interfaces","title":"Core Interfaces","text":""},{"location":"client/typescript-types/#agentflowclient","title":"AgentFlowClient","text":"<p>The main client class for API interaction.</p> <pre><code>class AgentFlowClient {\n  constructor(config: AgentFlowConfig);\n\n  // Health &amp; Metadata\n  ping(): Promise&lt;PingResponse&gt;;\n  graph(): Promise&lt;GraphResponse&gt;;\n  graphStateSchema(): Promise&lt;StateSchemaResponse&gt;;\n\n  // Execution\n  invoke(request: InvokeRequest): Promise&lt;InvokeResult&gt;;\n  stream(request: StreamRequest): AsyncIterableIterator&lt;StreamChunk&gt;;\n\n  // Tools\n  registerTool(registration: ToolRegistration): void;\n  setup(): Promise&lt;void&gt;;\n\n  // Threads\n  threads(request?: ThreadsRequest): Promise&lt;ThreadsResponse&gt;;\n  threadDetails(threadId: string): Promise&lt;ThreadDetailsResponse&gt;;\n  threadState(threadId: string): Promise&lt;ThreadStateResponse&gt;;\n  updateThreadState(threadId: string, request: UpdateThreadStateRequest): Promise&lt;UpdateThreadStateResponse&gt;;\n  clearThreadState(threadId: string): Promise&lt;ClearThreadStateResponse&gt;;\n  deleteThread(threadId: string, request?: DeleteThreadRequest): Promise&lt;DeleteThreadResponse&gt;;\n\n  // Messages\n  threadMessages(threadId: string, options?: ThreadMessagesRequest): Promise&lt;ThreadMessagesResponse&gt;;\n  threadMessage(threadId: string, messageId: string): Promise&lt;ThreadMessageResponse&gt;;\n  addThreadMessages(threadId: string, request: AddThreadMessagesRequest): Promise&lt;AddThreadMessagesResponse&gt;;\n  deleteThreadMessage(threadId: string, messageId: string): Promise&lt;DeleteThreadMessageResponse&gt;;\n\n  // Memory\n  storeMemory(request: StoreMemoryRequest): Promise&lt;StoreMemoryResponse&gt;;\n  searchMemory(request: SearchMemoryRequest): Promise&lt;SearchMemoryResponse&gt;;\n  getMemory(memoryId: string): Promise&lt;GetMemoryResponse&gt;;\n  updateMemory(memoryId: string, request: UpdateMemoryRequest): Promise&lt;UpdateMemoryResponse&gt;;\n  deleteMemory(memoryId: string): Promise&lt;DeleteMemoryResponse&gt;;\n  listMemories(request?: ListMemoriesRequest): Promise&lt;ListMemoriesResponse&gt;;\n  forgetMemories(request: ForgetMemoriesRequest): Promise&lt;ForgetMemoriesResponse&gt;;\n}\n</code></pre>"},{"location":"client/typescript-types/#agentflowconfig","title":"AgentFlowConfig","text":"<p>Client configuration options.</p> <pre><code>interface AgentFlowConfig {\n  baseUrl: string;        // Required: API base URL\n  authToken?: string;     // Optional: Authentication token\n  timeout?: number;       // Optional: Request timeout in ms (default: 300000)\n  debug?: boolean;        // Optional: Enable debug logging (default: false)\n}\n</code></pre> <p>Example:</p> <pre><code>const config: AgentFlowConfig = {\n  baseUrl: 'https://api.example.com',\n  authToken: process.env.API_TOKEN,\n  timeout: 60000,\n  debug: true\n};\n\nconst client: AgentFlowClient = new AgentFlowClient(config);\n</code></pre>"},{"location":"client/typescript-types/#message-types","title":"Message Types","text":""},{"location":"client/typescript-types/#message","title":"Message","text":"<p>The main message class with helper methods.</p> <pre><code>class Message {\n  message_id: string | null;\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: ContentBlock[];\n  delta: boolean;\n  tools_calls?: Record&lt;string, any&gt;[];\n  timestamp: number;\n  metadata: Record&lt;string, any&gt;;\n  usages?: TokenUsages;\n  raw?: Record&lt;string, any&gt;;\n\n  constructor(\n    role: 'user' | 'assistant' | 'system' | 'tool',\n    content: ContentBlock[],\n    message_id?: string | null\n  );\n\n  // Static helper methods\n  static text_message(\n    content: string,\n    role?: 'user' | 'assistant' | 'system' | 'tool',\n    message_id?: string | null\n  ): Message;\n\n  static tool_message(\n    content: ContentBlock[],\n    message_id?: string | null,\n    meta?: Record&lt;string, any&gt;\n  ): Message;\n\n  // Instance methods\n  text(): string;\n  attach_media(media: MediaRef, as_type: 'image' | 'audio' | 'video' | 'document'): void;\n}\n</code></pre>"},{"location":"client/typescript-types/#content-blocks","title":"Content Blocks","text":"<pre><code>// Base content block types\ntype ContentBlock = \n  | TextBlock \n  | ImageBlock \n  | AudioBlock \n  | VideoBlock \n  | DocumentBlock\n  | DataBlock\n  | ToolCallBlock\n  | RemoteToolCallBlock \n  | ToolResultBlock\n  | ReasoningBlock\n  | AnnotationBlock\n  | ErrorBlock;\n\n// Text block\nclass TextBlock {\n  type: 'text' = 'text';\n  text: string;\n  annotations: AnnotationRef[];\n\n  constructor(text?: string, annotations?: AnnotationRef[]);\n}\n\n// Image block\nclass ImageBlock {\n  type: 'image' = 'image';\n  media: MediaRef;\n  alt_text?: string;\n  bbox?: number[];\n\n  constructor(media?: MediaRef, alt_text?: string, bbox?: number[]);\n}\n\n// Audio block\nclass AudioBlock {\n  type: 'audio' = 'audio';\n  media: MediaRef;\n  transcript?: string;\n  sample_rate?: number;\n  channels?: number;\n\n  constructor(media?: MediaRef, transcript?: string, sample_rate?: number, channels?: number);\n}\n\n// Video block\nclass VideoBlock {\n  type: 'video' = 'video';\n  media: MediaRef;\n  thumbnail?: MediaRef;\n\n  constructor(media?: MediaRef, thumbnail?: MediaRef);\n}\n\n// Document block\nclass DocumentBlock {\n  type: 'document' = 'document';\n  media: MediaRef;\n  pages?: number[];\n  excerpt?: string;\n\n  constructor(media?: MediaRef, pages?: number[], excerpt?: string);\n}\n\n// Data block\nclass DataBlock {\n  type: 'data' = 'data';\n  mime_type: string;\n  data_base64?: string;\n  media?: MediaRef;\n\n  constructor(mime_type?: string, data_base64?: string, media?: MediaRef);\n}\n\n// Tool call block\nclass ToolCallBlock {\n  type: 'tool_call' = 'tool_call';\n  id: string;\n  name: string;\n  args: Record&lt;string, any&gt;;\n  tool_type?: string;\n\n  constructor(id?: string, name?: string, args?: Record&lt;string, any&gt;, tool_type?: string);\n}\n\n// Remote tool call (from API)\nclass RemoteToolCallBlock {\n  type: 'remote_tool_call' = 'remote_tool_call';\n  id: string;\n  name: string;\n  args: Record&lt;string, any&gt;;\n  tool_type: string;\n\n  constructor(id?: string, name?: string, args?: Record&lt;string, any&gt;, tool_type?: string);\n}\n\n// Tool result (sent back to API)\nclass ToolResultBlock {\n  type: 'tool_result' = 'tool_result';\n  call_id: string;\n  output: any;\n  is_error: boolean;\n  status?: 'completed' | 'failed';\n\n  constructor(props: { call_id: string; output: any; status: 'completed' | 'failed'; is_error: boolean });\n}\n\n// Reasoning block\nclass ReasoningBlock {\n  type: 'reasoning' = 'reasoning';\n  summary: string;\n  details?: string[];\n\n  constructor(summary?: string, details?: string[]);\n}\n\n// Annotation block\nclass AnnotationBlock {\n  type: 'annotation' = 'annotation';\n  kind: 'citation' | 'note';\n  refs: AnnotationRef[];\n  spans?: [number, number][];\n\n  constructor(kind?: 'citation' | 'note', refs?: AnnotationRef[], spans?: [number, number][]);\n}\n\n// Error block\nclass ErrorBlock {\n  type: 'error' = 'error';\n  message: string;\n  code?: string;\n  data?: Record&lt;string, any&gt;;\n\n  constructor(message?: string, code?: string, data?: Record&lt;string, any&gt;);\n}\n</code></pre>"},{"location":"client/typescript-types/#media-references","title":"Media References","text":"<pre><code>class MediaRef {\n  kind: 'url' | 'file_id' | 'data';\n  url?: string;\n  file_id?: string;\n  data_base64?: string;\n  mime_type?: string;\n  size_bytes?: number;\n  sha256?: string;\n  filename?: string;\n  width?: number;\n  height?: number;\n  duration_ms?: number;\n  page?: number;\n\n  constructor(\n    kind?: 'url' | 'file_id' | 'data',\n    url?: string,\n    file_id?: string,\n    data_base64?: string,\n    mime_type?: string,\n    size_bytes?: number,\n    sha256?: string,\n    filename?: string,\n    width?: number,\n    height?: number,\n    duration_ms?: number,\n    page?: number\n  );\n}\n\nclass AnnotationRef {\n  url?: string;\n  file_id?: string;\n  page?: number;\n  index?: number;\n  title?: string;\n\n  constructor(url?: string, file_id?: string, page?: number, index?: number, title?: string);\n}\n\nclass TokenUsages {\n  completion_tokens: number;\n  prompt_tokens: number;\n  total_tokens: number;\n  reasoning_tokens: number;\n  cache_creation_input_tokens: number;\n  cache_read_input_tokens: number;\n  image_tokens?: number;\n  audio_tokens?: number;\n}\n</code></pre> <p>Example:</p> <pre><code>import { Message, TextBlock, ImageBlock, MediaRef } from 'agentflow-react';\n\n// Simple text message\nconst userMessage: Message = Message.text_message('Hello', 'user');\n\n// Message with multiple blocks\nconst complexMessage = new Message('user', [\n  new TextBlock('Here is an image:'),\n  new ImageBlock(\n    new MediaRef('url', 'https://example.com/image.jpg'),\n    'A beautiful landscape'\n  )\n]);\n</code></pre>"},{"location":"client/typescript-types/#request-response-types","title":"Request &amp; Response Types","text":""},{"location":"client/typescript-types/#invoke","title":"Invoke","text":"<pre><code>interface InvokeRequest {\n  messages: Message[];\n  config?: Record&lt;string, any&gt;;\n  stream?: boolean;\n  granularity?: 'low' | 'partial' | 'full';\n  recursion_limit?: number;\n  on_progress?: InvokeCallback;\n}\n\ninterface InvokeResult {\n  messages: Message[];\n  all_messages: Message[];\n  state?: Record&lt;string, any&gt;;\n  context?: any;\n  summary?: string;\n  iterations: number;\n  recursion_limit_reached: boolean;\n  metadata: ResponseMetadata;\n}\n\ninterface InvokePartialResult {\n  messages: Message[];\n  all_messages: Message[];\n  state?: Record&lt;string, any&gt;;\n  context?: any;\n  iterations: number;\n  recursion_limit_reached: boolean;\n}\n\ntype InvokeCallback = (result: InvokePartialResult) =&gt; void;\n</code></pre> <p>Example:</p> <pre><code>**Example:**\n\n```typescript\nconst request: InvokeRequest = {\n  messages: [Message.text_message('What is the weather?', 'user')],\n  granularity: 'full',\n  recursion_limit: 10,\n  on_progress: (partial: InvokePartialResult) =&gt; {\n    console.log(`Iteration ${partial.iterations}`);\n  }\n</code></pre> <p>const result: InvokeResult = await client.invoke(request); <pre><code>### State Schema\n\n```typescript\ninterface StateSchemaResponse {\n  data: {\n    fields: {\n      [fieldName: string]: FieldSchema;\n    };\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface FieldSchema {\n  type: string;\n  description?: string;\n  default?: any;\n  required?: boolean;\n  enum?: any[];\n  items?: FieldSchema;\n  properties?: Record&lt;string, FieldSchema&gt;;\n}\n</code></pre></p> <p>Example:</p> <pre><code>const schema: StateSchemaResponse = await client.graphStateSchema();\n\n// Iterate fields\nfor (const [name, field] of Object.entries(schema.data.fields)) {\n  const fieldSchema: FieldSchema = field;\n  console.log(`${name}: ${fieldSchema.type}`);\n}\n</code></pre>"},{"location":"client/typescript-types/#thread-state","title":"Thread State","text":"<pre><code>interface ThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n\ninterface UpdateThreadStateRequest {\n  config?: Record&lt;string, any&gt;;\n  state: Record&lt;string, any&gt;;\n}\n\ninterface UpdateThreadStateResponse {\n  data: {\n    state: Record&lt;string, any&gt;;\n    [key: string]: any;\n  };\n  metadata: ResponseMetadata;\n}\n</code></pre> <p>Example:</p> <pre><code>// Get current state\nconst currentState: ThreadStateResponse = await client.threadState('thread_123');\n\n// Update state\nconst updateRequest: UpdateThreadStateRequest = {\n  state: {\n    step: 'completed',\n    result: { success: true }\n  }\n};\n\nconst updated: UpdateThreadStateResponse = await client.updateThreadState(\n  'thread_123',\n  updateRequest\n);\n</code></pre>"},{"location":"client/typescript-types/#tool-types","title":"Tool Types","text":""},{"location":"client/typescript-types/#tool-registration","title":"Tool Registration","text":"<pre><code>interface ToolRegistration {\n  node: string;\n  name: string;\n  description?: string;\n  parameters?: ToolParameter;\n  handler: ToolHandler;\n}\n\ninterface ToolParameter {\n  type: 'object';\n  properties: Record&lt;string, any&gt;;\n  required: string[];\n}\n\ntype ToolHandler = (args: any) =&gt; Promise&lt;any&gt;;\n</code></pre> <p>Example with Strong Typing:</p> <pre><code>// Define parameter interface\ninterface WeatherArgs {\n  location: string;\n  units?: 'metric' | 'imperial';\n}\n\n// Define result interface\ninterface WeatherResult {\n  temperature: number;\n  condition: string;\n  humidity: number;\n}\n\n// Typed tool registration\nconst weatherTool: ToolRegistration = {\n  node: 'assistant',\n  name: 'get_weather',\n  description: 'Get current weather',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: { type: 'string', description: 'City name' },\n      units: { type: 'string', enum: ['metric', 'imperial'] }\n    },\n    required: ['location']\n  },\n  handler: async (args: WeatherArgs): Promise&lt;WeatherResult&gt; =&gt; {\n    const data = await fetchWeather(args.location, args.units);\n    return {\n      temperature: data.temp,\n      condition: data.condition,\n      humidity: data.humidity\n    };\n  }\n};\n\nclient.registerTool(weatherTool);\n</code></pre>"},{"location":"client/typescript-types/#memory-types","title":"Memory Types","text":""},{"location":"client/typescript-types/#memory-enums","title":"Memory Enums","text":"<pre><code>enum MemoryType {\n  EPISODIC = \"episodic\",\n  SEMANTIC = \"semantic\",\n  PROCEDURAL = \"procedural\",\n  ENTITY = \"entity\",\n  RELATIONSHIP = \"relationship\",\n  CUSTOM = \"custom\",\n  DECLARATIVE = \"declarative\"\n}\n\nenum RetrievalStrategy {\n  SIMILARITY = \"similarity\",\n  TEMPORAL = \"temporal\",\n  RELEVANCE = \"relevance\",\n  HYBRID = \"hybrid\",\n  GRAPH_TRAVERSAL = \"graph_traversal\"\n}\n\nenum DistanceMetric {\n  COSINE = \"cosine\",\n  EUCLIDEAN = \"euclidean\",\n  DOT_PRODUCT = \"dot_product\",\n  MANHATTAN = \"manhattan\"\n}\n</code></pre>"},{"location":"client/typescript-types/#memory-requests","title":"Memory Requests","text":"<pre><code>interface StoreMemoryRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  content: string;\n  memory_type: MemoryType;\n  category: string;\n  metadata?: Record&lt;string, any&gt;;\n}\n\ninterface SearchMemoryRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  query: string;\n  memory_type?: MemoryType;\n  category?: string;\n  limit?: number;\n  score_threshold?: number;\n  filters?: Record&lt;string, any&gt;;\n  retrieval_strategy?: RetrievalStrategy;\n  distance_metric?: DistanceMetric;\n  max_tokens?: number;\n}\n\ninterface UpdateMemoryRequest {\n  config?: Record&lt;string, any&gt;;\n  options?: Record&lt;string, any&gt;;\n  content?: string;\n  memory_type?: MemoryType;\n  category?: string;\n  metadata?: Record&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"client/typescript-types/#memory-result","title":"Memory Result","text":"<pre><code>interface MemoryResult {\n  id: string;\n  content: string;\n  score: number;\n  memory_type: string;\n  metadata: Record&lt;string, any&gt;;\n  vector: number[];\n  user_id: string;\n  thread_id: string;\n  timestamp: string;\n}\n</code></pre> <p>Example:</p> <pre><code>import { MemoryType, RetrievalStrategy, DistanceMetric } from 'agentflow-react';\n\n// Store memory\nconst storeRequest: StoreMemoryRequest = {\n  content: 'User prefers dark mode',\n  memory_type: MemoryType.SEMANTIC,\n  category: 'preferences',\n  metadata: { user_id: 'user_123' }\n};\n\nawait client.storeMemory(storeRequest);\n\n// Search memory\nconst searchRequest: SearchMemoryRequest = {\n  query: 'user interface preferences',\n  memory_type: MemoryType.SEMANTIC,\n  limit: 5,\n  score_threshold: 0.7,\n  retrieval_strategy: RetrievalStrategy.SIMILARITY,\n  distance_metric: DistanceMetric.COSINE\n};\n\nconst results = await client.searchMemory(searchRequest);\n\nresults.data.results.forEach((result: MemoryResult) =&gt; {\n  console.log(`[${result.score.toFixed(2)}] ${result.content}`);\n});\n</code></pre>"},{"location":"client/typescript-types/#stream-types","title":"Stream Types","text":""},{"location":"client/typescript-types/#stream-request-events","title":"Stream Request &amp; Events","text":"<pre><code>interface StreamRequest {\n  messages: Message[];\n  config?: Record&lt;string, any&gt;;\n  stream?: boolean;\n  granularity?: 'low' | 'partial' | 'full';\n}\n\ninterface StreamChunk {\n  event: StreamEventType;\n  data: any;\n}\n\ntype StreamEventType =\n  | 'metadata'\n  | 'on_chain_start'\n  | 'on_chain_stream'\n  | 'on_chain_end'\n  | 'messages_chunk'\n  | 'state_chunk'\n  | 'context_chunk'\n  | 'summary_chunk'\n  | 'error';\n</code></pre> <p>Example with Type Guards:</p> <pre><code>async function handleStream(messages: Message[]) {\n  for await (const chunk of client.stream({ messages })) {\n    switch (chunk.event) {\n      case 'metadata':\n        const metadata = chunk.data as ResponseMetadata;\n        console.log('Request ID:', metadata.request_id);\n        break;\n\n      case 'messages_chunk':\n        const text = chunk.data as string;\n        process.stdout.write(text);\n        break;\n\n      case 'state_chunk':\n        const state = chunk.data as Record&lt;string, any&gt;;\n        console.log('State:', state);\n        break;\n\n      case 'error':\n        const error = chunk.data as { message: string };\n        console.error('Error:', error.message);\n        break;\n    }\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#error-types","title":"Error Types","text":""},{"location":"client/typescript-types/#error-classes","title":"Error Classes","text":"<pre><code>class AgentFlowError extends Error {\n  status: number;\n  requestId?: string;\n\n  constructor(message: string, status: number, requestId?: string);\n}\n\nclass BadRequestError extends AgentFlowError {\n  constructor(message: string, requestId?: string);\n}\n\nclass AuthenticationError extends AgentFlowError {\n  constructor(message: string, requestId?: string);\n}\n\nclass PermissionError extends AgentFlowError {\n  constructor(message: string, requestId?: string);\n}\n\nclass NotFoundError extends AgentFlowError {\n  constructor(message: string, requestId?: string);\n}\n\nclass ValidationError extends AgentFlowError {\n  constructor(message: string, requestId?: string);\n}\n\nclass ServerError extends AgentFlowError {\n  constructor(message: string, status: number, requestId?: string);\n}\n</code></pre> <p>Example:</p> <pre><code>import { \n  AgentFlowError, \n  AuthenticationError, \n  NotFoundError \n} from 'agentflow-react';\n\ntry {\n  const result = await client.invoke({ messages });\n} catch (error) {\n  if (error instanceof AuthenticationError) {\n    console.error('Auth failed:', error.message);\n    console.error('Request ID:', error.requestId);\n  } else if (error instanceof NotFoundError) {\n    console.error('Resource not found:', error.message);\n  } else if (error instanceof AgentFlowError) {\n    console.error(`Error ${error.status}:`, error.message);\n  } else {\n    console.error('Unknown error:', error);\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#type-guards","title":"Type Guards","text":""},{"location":"client/typescript-types/#message-type-guards","title":"Message Type Guards","text":"<pre><code>function isTextBlock(block: ContentBlock): block is TextBlock {\n  return block.type === 'text';\n}\n\nfunction isImageBlock(block: ContentBlock): block is ImageBlock {\n  return block.type === 'image';\n}\n\nfunction isRemoteToolCall(block: ContentBlock): block is RemoteToolCallBlock {\n  return block.type === 'remote_tool_call';\n}\n\nfunction isToolResult(block: ContentBlock): block is ToolResultBlock {\n  return block.type === 'tool_result';\n}\n</code></pre> <p>Usage:</p> <pre><code>const message: Message = result.messages[0];\n\nfor (const block of message.content) {\n  if (isTextBlock(block)) {\n    console.log('Text:', block.text);\n  } else if (isImageBlock(block)) {\n    console.log('Image URL:', block.media.url);\n  } else if (isRemoteToolCall(block)) {\n    console.log('Tool call:', block.name, block.args);\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#error-type-guards","title":"Error Type Guards","text":"<pre><code>function isAgentFlowError(error: unknown): error is AgentFlowError {\n  return error instanceof AgentFlowError;\n}\n\nfunction isAuthError(error: unknown): error is AuthenticationError {\n  return error instanceof AuthenticationError;\n}\n\nfunction isNotFoundError(error: unknown): error is NotFoundError {\n  return error instanceof NotFoundError;\n}\n</code></pre> <p>Usage:</p> <pre><code>try {\n  await client.invoke({ messages });\n} catch (error) {\n  if (isAuthError(error)) {\n    // TypeScript knows error is AuthenticationError\n    redirectToLogin(error.requestId);\n  } else if (isNotFoundError(error)) {\n    // TypeScript knows error is NotFoundError\n    showNotFoundPage(error.message);\n  } else if (isAgentFlowError(error)) {\n    // TypeScript knows error is AgentFlowError\n    logError(error.status, error.message);\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#generic-types","title":"Generic Types","text":""},{"location":"client/typescript-types/#typed-invoke-result","title":"Typed Invoke Result","text":"<p>Create typed results for specific use cases:</p> <pre><code>interface ChatResult extends InvokeResult {\n  messages: Message[];\n  conversationState: {\n    topic: string;\n    sentiment: 'positive' | 'negative' | 'neutral';\n  };\n}\n\nasync function invokeChat(messages: Message[]): Promise&lt;ChatResult&gt; {\n  const result = await client.invoke({\n    messages,\n    granularity: 'full'\n  });\n\n  return {\n    ...result,\n    conversationState: result.state as any\n  };\n}\n</code></pre>"},{"location":"client/typescript-types/#typed-tool-handlers","title":"Typed Tool Handlers","text":"<pre><code>// Generic typed tool handler\ntype TypedToolHandler&lt;TArgs, TResult&gt; = (args: TArgs) =&gt; Promise&lt;TResult&gt;;\n\n// Weather tool types\ninterface WeatherArgs {\n  location: string;\n  units?: 'metric' | 'imperial';\n}\n\ninterface WeatherResult {\n  temperature: number;\n  condition: string;\n}\n\nconst weatherHandler: TypedToolHandler&lt;WeatherArgs, WeatherResult&gt; = async (args) =&gt; {\n  const data = await fetchWeather(args.location, args.units);\n  return {\n    temperature: data.temp,\n    condition: data.condition\n  };\n};\n\nclient.registerTool({\n  node: 'assistant',\n  name: 'get_weather',\n  handler: weatherHandler\n});\n</code></pre>"},{"location":"client/typescript-types/#custom-type-extensions","title":"Custom Type Extensions","text":""},{"location":"client/typescript-types/#extend-client-configuration","title":"Extend Client Configuration","text":"<pre><code>interface CustomAgentFlowConfig extends AgentFlowConfig {\n  retryAttempts?: number;\n  retryDelay?: number;\n  customHeaders?: Record&lt;string, string&gt;;\n}\n\nclass CustomAgentFlowClient extends AgentFlowClient {\n  private retryAttempts: number;\n  private retryDelay: number;\n\n  constructor(config: CustomAgentFlowConfig) {\n    super(config);\n    this.retryAttempts = config.retryAttempts ?? 3;\n    this.retryDelay = config.retryDelay ?? 1000;\n  }\n\n  async invokeWithRetry(request: InvokeRequest): Promise&lt;InvokeResult&gt; {\n    for (let attempt = 1; attempt &lt;= this.retryAttempts; attempt++) {\n      try {\n        return await this.invoke(request);\n      } catch (error) {\n        if (attempt === this.retryAttempts) throw error;\n        await this.sleep(this.retryDelay * attempt);\n      }\n    }\n    throw new Error('Max retries exceeded');\n  }\n\n  private sleep(ms: number): Promise&lt;void&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, ms));\n  }\n}\n</code></pre>"},{"location":"client/typescript-types/#extend-message-types","title":"Extend Message Types","text":"<pre><code>// Add custom message metadata\ninterface ExtendedMessage extends Message {\n  metadata: {\n    timestamp: Date;\n    userId: string;\n    sessionId: string;\n  };\n}\n\nfunction createExtendedMessage(\n  text: string,\n  userId: string,\n  sessionId: string\n): ExtendedMessage {\n  const message = Message.text_message(text, 'user') as ExtendedMessage;\n  message.metadata = {\n    timestamp: new Date(),\n    userId,\n    sessionId\n  };\n  return message;\n}\n</code></pre>"},{"location":"client/typescript-types/#custom-tool-types","title":"Custom Tool Types","text":"<pre><code>// Tool with middleware\ninterface ToolWithMiddleware extends ToolRegistration {\n  beforeExecute?: (args: any) =&gt; Promise&lt;void&gt;;\n  afterExecute?: (result: any) =&gt; Promise&lt;void&gt;;\n}\n\nfunction registerToolWithMiddleware(\n  client: AgentFlowClient,\n  tool: ToolWithMiddleware\n) {\n  const originalHandler = tool.handler;\n\n  const wrappedHandler: ToolHandler = async (args) =&gt; {\n    if (tool.beforeExecute) {\n      await tool.beforeExecute(args);\n    }\n\n    const result = await originalHandler(args);\n\n    if (tool.afterExecute) {\n      await tool.afterExecute(result);\n    }\n\n    return result;\n  };\n\n  client.registerTool({\n    ...tool,\n    handler: wrappedHandler\n  });\n}\n</code></pre>"},{"location":"client/typescript-types/#response-metadata","title":"Response Metadata","text":"<p>All API responses include metadata:</p> <pre><code>interface ResponseMetadata {\n  message: string;\n  request_id: string;\n  timestamp: string;\n}\n</code></pre> <p>Usage:</p> <pre><code>const result: InvokeResult = await client.invoke({ messages });\n\nconsole.log('Request ID:', result.metadata.request_id);\nconsole.log('Timestamp:', result.metadata.timestamp);\nconsole.log('Message:', result.metadata.message);\n</code></pre>"},{"location":"client/typescript-types/#complete-example","title":"Complete Example","text":"<p>Here's a complete TypeScript example using all type features:</p> <pre><code>import {\n  AgentFlowClient,\n  AgentFlowConfig,\n  Message,\n  InvokeRequest,\n  InvokeResult,\n  ToolRegistration,\n  MemoryType,\n  StoreMemoryRequest,\n  SearchMemoryRequest,\n  AuthenticationError,\n  NotFoundError\n} from 'agentflow-react';\n\n// Configuration\nconst config: AgentFlowConfig = {\n  baseUrl: process.env.AGENTFLOW_API_URL!,\n  authToken: process.env.AGENTFLOW_TOKEN,\n  timeout: 60000,\n  debug: true\n};\n\nconst client = new AgentFlowClient(config);\n\n// Tool types\ninterface CalculatorArgs {\n  expression: string;\n}\n\ninterface CalculatorResult {\n  result: number;\n  expression: string;\n}\n\n// Register tool\nconst calculatorTool: ToolRegistration = {\n  node: 'assistant',\n  name: 'calculate',\n  description: 'Perform calculations',\n  parameters: {\n    type: 'object',\n    properties: {\n      expression: { type: 'string' }\n    },\n    required: ['expression']\n  },\n  handler: async (args: CalculatorArgs): Promise&lt;CalculatorResult&gt; =&gt; {\n    const result = evaluateMath(args.expression);\n    return { result, expression: args.expression };\n  }\n};\n\nclient.registerTool(calculatorTool);\n\n// Invoke with types\nasync function chat(userInput: string): Promise&lt;InvokeResult&gt; {\n  const request: InvokeRequest = {\n    messages: [Message.text_message(userInput, 'user')],\n    granularity: 'full',\n    recursion_limit: 10\n  };\n\n  try {\n    const result: InvokeResult = await client.invoke(request);\n\n    // Store memory\n    const memoryRequest: StoreMemoryRequest = {\n      content: `User asked: ${userInput}`,\n      memory_type: MemoryType.EPISODIC,\n      category: 'conversations',\n      metadata: {\n        timestamp: new Date().toISOString(),\n        result_iterations: result.iterations\n      }\n    };\n\n    await client.storeMemory(memoryRequest);\n\n    return result;\n  } catch (error) {\n    if (error instanceof AuthenticationError) {\n      console.error('Authentication failed:', error.requestId);\n      throw new Error('Please check your API token');\n    } else if (error instanceof NotFoundError) {\n      console.error('Resource not found:', error.message);\n      throw new Error('API endpoint not available');\n    } else {\n      throw error;\n    }\n  }\n}\n\n// Usage\nconst result = await chat('Calculate 123 * 456');\nconsole.log('Response:', result.messages[0].content);\nconsole.log('Iterations:', result.iterations);\nconsole.log('Request ID:', result.metadata.request_id);\n</code></pre>"},{"location":"client/typescript-types/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Getting Started - Quick start guide</li> <li>React Integration - Using types in React</li> <li>Tools Guide - Tool type patterns</li> <li>Troubleshooting - Common TypeScript issues</li> </ul> <p>Pro Tip: Enable strict mode in <code>tsconfig.json</code> for maximum type safety!</p>"}]}